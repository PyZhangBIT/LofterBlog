{
  "name": "Lofterblog",
  "tagline": "",
  "body": " http://zhangpy3.lofter.com 2016-04-19 08:37  [总结]FFMPEG视音频编解码零基础学习方法 1459389461515 Text 1dad75de_a743a5c 【编程开发】 <p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p> <p>目录<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#\" >(?)</a><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#\" >[-]</a></p> <ol> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t0\" >ffmpeg程序的使用ffmpegexeffplayexeffprobeexe</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t1\" >1 ffmpegexe</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t2\" >2 ffplayexe</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t3\" >3 ffprobeexe</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t4\" >ffmpeg库的使用视频播放器</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t5\" >1 ffmpeg库的配置</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t6\" >2 最简单的视频播放器</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t7\" >3 相关结构体的研究</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t8\" >ffmpeg库的使用音频播放器</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t9\" >1 最简单的音频播放器</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t10\" >ffmpeg库的使用一个真正的播放器ffplay</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t11\" >1 真正的播放器</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t12\" >ffmpeg库的使用编码</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t13\" >1 编码</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t14\" >2 转码</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t15\" >ffmpeg源代码分析</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t16\" >FFmpeg其它几个类库的使用</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t17\" >1libavfilter加特效</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t18\" >2libavdevice读设备</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t19\" >3libswscale图像拉伸像素格式转换</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t20\" >FFmpeg封装格式的处理</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t21\" >FFmpeg流媒体方面的应用</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t22\" >FFmpeg的其他杂项</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t23\" >ffmpeg在其它平台下的应用</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t24\" >ffmpeg相关工程的学习</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t25\" >1 ffdshow</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t26\" >2 LAV filters</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t27\" >3 Mplayer</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t28\" >4 Media Player Classic - HC</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#t29\" >5 XBMC</a></p></li> </ol> <p>在CSDN上的这一段日子，接触到了很多同行业的人，尤其是使用FFMPEG进行视音频编解码的人，有的已经是有多年经验的“大神”，有的是刚开始学习的初学者。在和大家探讨的过程中，我忽然发现了一个问题：在“大神”和初学者之间好像有一个不可逾越的鸿沟。“大神”们水平高超，探讨着深奥的问题；而初学者们还停留在入门阶段。究竟是什么原因造成的这种“两极分化”呢？最后，我发现了问题的关键：FFMPEG难度比较大，却没有一个循序渐进，由简单到复杂的教程。现在网上的有关FFMPEG的教程多半难度比较大，不太适合刚接触FFMPEG的人学习；而且很多的例子程序编译通不过，极大地打消了学习的积极性。我自己在刚开始学习FFMPEG的时候也遇到了很大的困难。为了帮助更多的人快速成为“大神”，我想总结一个学习FFMPEG的方法，方便大家循序渐进的学习FFMPEG。</p> <p>PS：有不少人不清楚“FFmpeg”应该怎么读。它读作“ef ef em peg”</p> <p><img src=\"http://img.blog.csdn.net/20140616102021781\" style=\"max-width:500px;\" /><br /></p> <p><strong>0.&nbsp;背景知识</strong></p> <p>本章主要介绍一下FFMPEG都用在了哪里（在这里仅列几个我所知的，其实远比这个多）。说白了就是为了说明：FFMPEG是非常重要的。</p> <p>使用FFMPEG作为内核视频播放器：</p> <blockquote> <p>Mplayer，ffplay，射手播放器，暴风影音，KMPlayer，QQ影音...</p> </blockquote> <p>使用FFMPEG作为内核的Directshow Filter：</p> <blockquote> <p>ffdshow，lav filters...</p> </blockquote> <p>使用FFMPEG作为内核的转码工具：</p> <blockquote> <p>ffmpeg，格式工厂...</p> </blockquote> <p>事实上，FFMPEG的视音频编解码功能确实太强大了，几乎囊括了现存所有的视音频编码标准，因此只要做视音频开发，几乎离不开它。</p> <p>对于完全没有视音频技术背景的人来说，在学习FFmpeg之前最好先了解一下几种最基本的视音频数据的格式，可以参考下面的文章：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/18893769\" >[总结]视音频编解码技术零基础学习方法</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/50534150\" >视音频数据处理入门：RGB、YUV像素数据处理</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/50534316\" >视音频数据处理入门：PCM音频采样数据处理</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/50534369\" >视音频数据处理入门：H.264视频码流解析</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/50535042\" >视音频数据处理入门：AAC音频码流解析</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/50535082\" >视音频数据处理入门：FLV封装格式解析</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/50535230\" >视音频数据处理入门：UDP-RTP协议解析</a></p> <p><br /></p> <strong>1. ffmpeg程序的使用（ffmpeg.exe，ffplay.exe，ffprobe.exe）</strong> <p><strong><br /></strong></p> <p><strong>【视频资源】</strong></p> <p>本文中第1,2章是FFmpeg编程最基础的内容。这部分的内容我在给大二同学代课的时候录制成了视频，有时间的话可以看一下<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47068015\" >《基于 FFmpeg + SDL 的视频播放器的制作》课程的视频</a>。</p> <p><br /></p> <p>本章主要介绍一下ffmpeg工程包含的三个exe的使用方法。</p> <p>ffmpeg的官方网站是：<a target=\"_blank\" rel=\"nofollow\" href=\"http://ffmpeg.org/\" >http://ffmpeg.org/</a></p> <p>编译好的windows可用版本的下载地址（官网中可以连接到这个网站，和官方网站保持同步）：&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://ffmpeg.zeranoe.com/builds/\" >http://ffmpeg.zeranoe.com/builds/</a></p> <p>该网站中的FFMPEG分为3个版本：Static，Shared，Dev。</p> <p>前两个版本可以直接在命令行中使用，他们的区别在于：Static里面只有3个应用程序：ffmpeg.exe，ffplay.exe，ffprobe.exe，每个exe的体积都很大，相关的Dll已经被编译到exe里面去了。Shared里面除了3个应用程序：ffmpeg.exe，ffplay.exe，ffprobe.exe之外，还有一些Dll，比如说avcodec-54.dll之类的。Shared里面的exe体积很小，他们在运行的时候，到相应的Dll中调用功能。</p> <p>Dev版本是用于开发的，里面包含了库文件xxx.lib以及头文件xxx.h，这个版本不包含exe文件。<br /></p> <p>打开系统命令行接面，切换到ffmpeg所在的目录，就可以使用这3个应用程序了。</p> <strong>1.1 ffmpeg.exe</strong> <p>ffmpeg是用于转码的应用程序。</p> <p>一个简单的转码命令可以这样写：</p> <p>将input.avi转码成output.ts，并设置视频的码率为640kbps</p> <p><strong>[plain]</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#\" >view plain</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#\" >copy</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/344587\" ><img src=\"https://code.csdn.net/assets/CODE_ico.png\" style=\"max-width:500px;\" /></a><a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/344587/fork\" ><img src=\"https://code.csdn.net/assets/ico_fork.svg\" style=\"max-width:500px;\" /></a></p> <ol> <li><p>ffmpeg -i input.avi -b:v 640k output.ts &nbsp;</p></li> </ol> 具体的使用方法可以参考：&nbsp; <a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/12751349\" >ffmpeg参数中文详细解释</a> <p>详细的使用说明（英文）：<a target=\"_blank\" rel=\"nofollow\" href=\"http://ffmpeg.org/ffmpeg.html\" >http://ffmpeg.org/ffmpeg.html</a></p> <strong>1.2 ffplay.exe</strong> <p>ffplay是用于播放的应用程序。</p> <p>一个简单的播放命令可以这样写：</p> <p>播放test.avi</p> <p><strong>[plain]</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#\" >view plain</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15811977#\" >copy</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/344587\" ><img src=\"https://code.csdn.net/assets/CODE_ico.png\" style=\"max-width:500px;\" /></a><a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/344587/fork\" ><img src=\"https://code.csdn.net/assets/ico_fork.svg\" style=\"max-width:500px;\" /></a></p> <ol> <li><p>ffplay test.avi &nbsp;</p></li> </ol> 具体的使用方法可以参考： <a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15186441\" >ffplay的快捷键以及选项</a> <p>详细的使用说明（英文）：<a target=\"_blank\" rel=\"nofollow\" href=\"http://ffmpeg.org/ffplay.html\" >http://ffmpeg.org/ffplay.html</a><br /></p> <strong>1.3 ffprobe.exe</strong> <p>ffprobe是用于查看文件格式的应用程序。</p> <p>这个就不多介绍了。</p> <p>详细的使用说明（英文）：<a target=\"_blank\" rel=\"nofollow\" href=\"http://ffmpeg.org/ffprobe.html\" >http://ffmpeg.org/ffprobe.html</a></p> <p><br /></p> <strong>2. ffmpeg库的使用：视频播放器</strong> <p>本章开始介绍使用ffmpeg的库进行开发。</p> <strong>2.1 ffmpeg库的配置</strong> <p>从<a target=\"_blank\" rel=\"nofollow\" href=\"http://ffmpeg.zeranoe.com/builds/\" >http://ffmpeg.zeranoe.com/builds/</a>网站上</p> <p>1.下载Dev版本，里面包含了ffmpeg的xxx.h头文件以及xxx.lib库文件。</p> <p>2.下载Shared版本，里面包含了ffmpeg的dll文件。</p> <p>3.将这两部分文件拷贝到VC工程下面就可以了</p> <p>注：可能会出现问题，参见：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/12747899\" >FFMPEG 库移植到 VC 需要的步骤</a></p> <p>如果不想自己手动配置，可以下载已经配置好的工程：<a target=\"_blank\" rel=\"nofollow\" href=\"http://download.csdn.net/detail/leixiaohua1020/5122959\" >最简单的基于FFMPEG+SDL的视频播放器</a></p> <strong>2.2 最简单的视频播放器</strong> <p>学习文章《<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/8652605\" >100行代码实现最简单的基于FFMPEG+SDL的视频播放器</a>》中的代码，这是ffmpeg做视频播放器最简单的代码了，是我自己精简出来的，已经不能再简化了，每一行都很重要。</p> <p>原版是基于SDL1.2的视频播放器，后来更新了基于SDL2.0的最简单的视频播放器：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38868499\" >最简单的基于FFMPEG+SDL的视频播放器 ver2 （采用SDL2.0）</a></p> <p>上述播放器使用libavformat和libavcodec两个类库完成了视频的解码工作。实际上解码工作只需要libavcodec就可以了。因此更新了一个“纯净”的解码器。该解码器只使用libavcodec完成解码工作：&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/42181571\" >最简单的基于FFmpeg的解码器-纯净版（不包含libavformat）</a></p> <p>ffmpeg的函数介绍：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/11979565\" >ffmpeg函数介绍</a></p> <p>注1：播放视频或音频数据的时候会用到SDL。有关SDL可以参考：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/11954039\" >SDL介绍</a></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SDL参考文档：<a target=\"_blank\" rel=\"nofollow\" href=\"http://download.csdn.net/detail/leixiaohua1020/6389841\" >SDL GUIDE 中文译本</a></p> <p>注2：如果想查看解码后的数据，需要用到 YUV播放器：<a target=\"_blank\" rel=\"nofollow\" href=\"http://download.csdn.net/detail/leixiaohua1020/6374065\" >YUV播放器源代码</a>或<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.yuvplayer.com/\" >YUV Player Deluxe</a>都可以</p> <strong>2.3 相关结构体的研究</strong> <p>ffmpeg的结构体之间的关系参考文章：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/11693997\" >FFMPEG中最关键的结构体之间的关系</a></p> <p>结构体中每个变量的分析，参考文章：</p> <p><span style=\"text-decoration:underline;\" ><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/14214577\" >FFMPEG结构体分析：AVFrame</a><br /></span></p> <blockquote></blockquote> <span style=\"text-decoration:underline;\" ><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/14214705\" >FFMPEG结构体分析：AVFormatContext</a><br /></span> <blockquote></blockquote> <span style=\"text-decoration:underline;\" ><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/14214859\" >FFMPEG结构体分析：AVCodecContext</a><br /></span> <blockquote></blockquote> <span style=\"text-decoration:underline;\" ><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/14215369\" >FFMPEG结构体分析：AVIOContext</a><br /></span> <blockquote></blockquote> <span style=\"text-decoration:underline;\" ><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/14215833\" >FFMPEG结构体分析：AVCodec</a><br /></span> <blockquote></blockquote> <span style=\"text-decoration:underline;\" ><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/14215821\" >FFMPEG结构体分析：AVStream</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/14215755\" >FFMPEG结构体分析：AVPacket</a></span> <br /> <p><br /></p>3. ffmpeg库的使用：音频播放器3.1 最简单的音频播放器 <p>学习文章《<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/10528443\" >最简单的基于FFMPEG+SDL的音频播放器</a>》&nbsp;中的代码，和最简单的视频播放器一样，这是最简单的音频播放器，每一行代码都很重要。</p> <p>原版是基于SDL1.2的音频播放器，后来更新了一个基于SDL2.0的最简单的音频播放器：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38979615\" >最简单的基于FFMPEG+SDL的音频播放器 ver2 （采用SDL2.0）</a><br /></p> <p><br /></p> <p>注：如果想要查看解码后的数据（PCM数据），需要用到Audition。<br /><br /></p> <strong>4. ffmpeg库的使用：一个真正的播放器——ffplay</strong>4.1 真正的播放器 <p>ffplay流程图如文章《<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/11980843\" >FFplay源代码分析：整体流程图</a>》&nbsp;所示。ffplay代码比较复杂，但是其核心代码和《<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/8652605\" >100行代码实现最简单的基于FFMPEG+SDL的视频播放器</a>》&nbsp;是一样的。可以两个工程结合着学习。</p> <p>ffplay代码简介资料：<a target=\"_blank\" rel=\"nofollow\" href=\"http://download.csdn.net/detail/leixiaohua1020/6373783\" >如何用FFmpeg编写一个简单播放器</a></p> <p>ffplay使用说明：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15186441\" >ffplay的快捷键以及选项</a></p> <p>ffplay已经移植到VC下的工程：<a target=\"_blank\" rel=\"nofollow\" href=\"http://download.csdn.net/detail/sxcong/4672795\" >ffplay_vc2005</a>（别人做的，质量很不错）</p> <p>ffplay移植到MFC下的工程，包含了简单的图形界面和一些控制按钮：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/28685327\" >ffplay播放器移植VC的工程：ffplay for MFC</a><br /></p> <p>上述软件的代码简介：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/33450345\" >ffplay for mfc 代码备忘</a></p> <p>ffplay.c函数结构简单分析：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39762143\" >ffplay.c函数结构简单分析（画图）</a></p> <strong>5. ffmpeg库的使用：编码</strong> <p>5.1 编码</p> <p>ffmpeg编码我自己研究的不是很多，可以参考文章&nbsp;：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/11885429\" >使用FFmpeg类库实现YUV视频序列编码为视频</a></p> <p>上面那篇文章是用的类库比较旧，新版类库的的使用可以参考下面几篇文章。</p> <p>图像的编码可以参考：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/25346147\" >最简单的基于FFMPEG的图像编码器（YUV编码为JPEG）</a><br /></p> <p>音频的编码可以参考：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/25430449\" >最简单的基于FFMPEG的音频编码器（PCM编码为AAC）</a><br /></p> <p>视频的编码可以参考：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/25430425\" >最简单的基于FFMPEG的视频编码器（YUV编码为H.264）</a><br /></p> <p>HEVC（H.265）视频编码可以参考：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39770947\" >最简单的基于FFmpeg的视频编码器-更新版（YUV编码为HEVC(H.265)）</a></p> <p>上述编码器使用libavformat和libavcodec两个类库完成了视频的编码工作。实际上编码工作只需要libavcodec就可以了。因此更新了一个“纯净”的编码器。该编码器只使用libavcodec完成编码工作：&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/42181271\" >最简单的基于FFmpeg的编码器-纯净版（不包含libavformat）</a><br /></p>5.2 转码 <p>转码实际上是先解码然后编码。</p> <p>不进行转码，只进行封装格式转换的程序可参考：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/25422685\" >最简单的基于FFMPEG的封装格式转换器（无编解码）</a></p> <p>转码程序可参考：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/26838535\" >最简单的基于FFMPEG的转码程序</a></p> <p>比较复杂的转码程序可以参考ffmpeg.c，它移植到MFC下的工程：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/28744935\" >ffmpeg转码器移植VC的工程：ffmpeg for MFC</a></p> <p>ffmpeg.c函数结构简单分析：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39760711\" >ffmpeg.c函数结构简单分析（画图）</a></p> <p><br /></p> <strong>6. ffmpeg源代码分析</strong> <p>通晓了ffmpeg库的使用以后，可以看一下ffmpeg的源代码。注意ffmpeg的源代码只有在linux下才能编译，在windows下可以使用MinGW进行编译。推荐使用Eclipse查看ffmpeg的源代码。</p> <p>有一个很完整的ffmpeg源代码的分析文档：<a target=\"_blank\" rel=\"nofollow\" href=\"http://download.csdn.net/detail/leixiaohua1020/6377803\" >ffdoc</a></p> <p><br /></p> <p>FFmpeg的库函数源代码分析文章列表如下：</p> <p><br /></p> <p>【架构图】</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44220151\" >FFmpeg源代码结构图&nbsp;-&nbsp;解码</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44226355\" >FFmpeg源代码结构图&nbsp;-&nbsp;编码</a></p> <p>【通用】</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/12677129\" >FFmpeg 源代码简单分析：av_register_all()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/12677265\" >FFmpeg 源代码简单分析：avcodec_register_all()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/41176777\" >FFmpeg 源代码简单分析：内存的分配和释放（av_malloc()、av_free()等）</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/41181155\" >FFmpeg 源代码简单分析：常见结构体的初始化和销毁（AVFormatContext，AVFrame等）</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/41199947\" >FFmpeg 源代码简单分析：avio_open2()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44084557\" >FFmpeg 源代码简单分析：av_find_decoder()和av_find_encoder()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44117891\" >FFmpeg 源代码简单分析：avcodec_open2()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44206699\" >FFmpeg 源代码简单分析：avcodec_close()</a></p> <p>【解码】</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/8661601\" >图解FFMPEG打开媒体的函数avformat_open_input</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44110683\" >FFmpeg 源代码简单分析：avformat_open_input()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44084321\" >FFmpeg 源代码简单分析：avformat_find_stream_info()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/12678577\" >FFmpeg 源代码简单分析：av_read_frame()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/12679719\" >FFmpeg 源代码简单分析：avcodec_decode_video2()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44110683\" >FFmpeg 源代码简单分析：avformat_close_input()</a></p> <p>【编码】</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/41198929\" >FFmpeg 源代码简单分析：avformat_alloc_output_context2()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44116215\" >FFmpeg 源代码简单分析：avformat_write_header()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44206485\" >FFmpeg 源代码简单分析：avcodec_encode_video()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44199673\" >FFmpeg 源代码简单分析：av_write_frame()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44201645\" >FFmpeg 源代码简单分析：av_write_trailer()</a></p> <p>【其它】</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44243155\" >FFmpeg源代码简单分析：日志输出系统（av_log()等）</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44268323\" >FFmpeg源代码简单分析：结构体成员管理系统-AVClass</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44279329\" >FFmpeg源代码简单分析：结构体成员管理系统-AVOption</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44305697\" >FFmpeg源代码简单分析：libswscale的sws_getContext()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44346687\" >FFmpeg源代码简单分析：libswscale的sws_scale()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/41211121\" >FFmpeg源代码简单分析：libavdevice的avdevice_register_all()</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44597955\" >FFmpeg源代码简单分析：libavdevice的gdigrab</a></p> <p>【脚本】</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44556525\" >FFmpeg源代码简单分析：makefile</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44587465\" >FFmpeg源代码简单分析：configure</a></p> <p>偏底层的libavcodec的源代码分析文章列表如下：</p> <p>【解码- libavcodec H.264 解码器】</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/44864509\" >FFmpeg的H.264解码器源代码简单分析：概述</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/45001033\" >FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/45042755\" >FFmpeg的H.264解码器源代码简单分析：解码器主干部分</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/45114453\" >FFmpeg的H.264解码器源代码简单分析：熵解码（EntropyDecoding）部分</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/45143075\" >FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/45195291\" >FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧间宏块（Inter）</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/45224579\" >FFmpeg的H.264解码器源代码简单分析：环路滤波（LoopFilter）部分</a></p> <p>【解码-libavcodec HEVC 解码器】</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/46412023\" >FFmpeg的HEVC解码器源代码简单分析：概述</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/46412607\" >FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/46412897\" >FFmpeg的HEVC解码器源代码简单分析：解码器主干部分</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/46414483\" >FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTUDecode）部分-PU</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/46451119\" >FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-TU</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/46483721\" >FFmpeg的HEVC解码器源代码简单分析：环路滤波（LoopFilter）</a></p> <br /> <br />7.FFmpeg其它几个类库的使用7.1.libavfilter（加特效） <p>AVFilter可以给视音频添加各种滤镜效果。有两个例子，一个是给视频添加水印：<br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/29368911\" >最简单的基于FFmpeg的AVfilter例子（水印叠加）</a><br /></p> <p>另一个是给YUV数据加特效：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/50618190\" >最简单的基于FFmpeg的AVfilter的例子-纯净版</a><br /></p>7.2.libavdevice（读设备） <p>AVDevice可以读取电脑的多媒体设备的数据，或者输出数据到指定的多媒体设备上。</p> <p>直接使用ffmpeg.exe命令行工具的文章：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38284961\" >FFmpeg获取DirectShow设备数据（摄像头，录屏）</a></p> <p>编程方面做了2个有关的例子：</p> <p>读取摄像头：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39702113\" >最简单的基于FFmpeg的AVDevice例子（读取摄像头）</a><br /></p> <p>屏幕录制：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39706721\" >最简单的基于FFmpeg的AVDevice例子（屏幕录制）</a></p>7.3.libswscale（图像拉伸，像素格式转换） <p>Swscale类库可以转换像素数据的格式，同时可以拉伸图像的大小。</p> <p>libswscale的使用示例：&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/42134965\" >最简单的基于FFmpeg的libswscale的示例（YUV转RGB）</a></p>此外，这个示例还附带了一个程序，用于生成测试图片：&nbsp; <a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/42135539\" >最简单的基于FFmpeg的libswscale的示例附件：测试图片生成工具</a>8.FFmpeg封装格式的处理使用FFmpeg进行封装格式的处理，主要是通过AVFormat完成。有关封装格式的处理，做了3个例子： <p>封装格式转换器：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/25422685\" >最简单的基于FFMPEG的封装格式转换器（无编解码）</a><br /></p> <p>视音频分离器简化版（demuxer-simple）：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39767055\" >最简单的基于FFmpeg的封装格式处理：视音频分离器简化版（demuxer-simple）</a><br /></p> <p>视音频分离器（demuxer）：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39802819\" >最简单的基于FFmpeg的封装格式处理：视音频分离器（demuxer）</a><br /></p> <p>视音频复用器（muxer）：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39802913\" >最简单的基于FFmpeg的封装格式处理：视音频复用器（muxer）</a><br /></p>9.FFmpeg流媒体方面的应用使用FFmpeg进行流媒体方面的应用，主要是流媒体的发送和接收。 <p>直接使用ffmpeg.exe命令行工具的文章：<br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38283297\" >FFmpeg发送流媒体的命令（UDP，RTP，RTMP）</a><br /></p> <p>编程方面做了一个例子：</p> <p>基于FFmpeg的推流器：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39803457\" >最简单的基于FFmpeg的推流器（以推送RTMP为例）</a></p> <p><br /></p>10.FFmpeg的其他杂项使用FFmpeg读写内存（而非文件）的例子： <p>内存播放器：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39759163\" >最简单的基于FFmpeg的内存读写的例子：内存播放器</a><br /></p> <p>内存转码器：<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/39759623\" >最简单的基于FFmpeg的内存读写的例子：内存转码器</a><br /></p> <p><br /></p>11. ffmpeg在其它平台下的应用 <p>把FFmpeg应用于Android、IOS、Windows Phone的示例程序可以参考：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47008825\" >最简单的基于FFmpeg的移动端例子：Android HelloWorld</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47010637\" >最简单的基于FFmpeg的移动端例子：Android 视频解码器</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47011021\" >最简单的基于FFmpeg的移动端例子：Android 视频解码器-单个库版</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47056051\" >最简单的基于FFmpeg的移动端例子：Android 推流器</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47056365\" >最简单的基于FFmpeg的移动端例子：Android 视频转码器</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47056733\" >最简单的基于FFmpeg的移动端例子附件：Android 自带播放器</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47059553\" >最简单的基于FFmpeg的移动端例子附件：SDL Android HelloWorld</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47071547\" >最简单的基于FFmpeg的移动端例子：IOS HelloWorld</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47072257\" >最简单的基于FFmpeg的移动端例子：IOS 视频解码器</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47072519\" >最简单的基于FFmpeg的移动端例子：IOS 推流器</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47072673\" >最简单的基于FFmpeg的移动端例子：IOS 视频转码器</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47072861\" >最简单的基于FFmpeg的移动端例子附件：IOS自带播放器</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/47191283\" >最简单的基于FFmpeg的移动端例子：Windows PhoneHelloWorld</a></p> <p><br /></p> <p><br /></p>12. ffmpeg相关工程的学习 <p>学习完成ffmpeg，还可以了解一下基于ffmpeg的相关的多媒体开源工程，在这里推荐以下几个：</p>12.1 ffdshow <p>ffdshow是基于ffmpeg的解码器类库libavcodec的DirectShow Filter。广泛安装在PC上。</p> <p><img src=\"http://img.blog.csdn.net/20140616103037171\" style=\"max-width:500px;\" /><br /></p> <p>有关ffdshow的源代码分析文章（更新中）：</p> <p><span style=\"text-decoration:underline;\" ><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/12013619\" >ffdshow 源代码分析1&nbsp;：&nbsp;整体结构</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/12981725\" >ffdshow 源代码分析 2：&nbsp;位图覆盖滤镜（对话框部分Dialog）</a><br /></span></p> <blockquote></blockquote> <span style=\"text-decoration:underline;\" ><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13004051\" >ffdshow 源代码分析 3：&nbsp;位图覆盖滤镜（设置部分Settings）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13006213\" >ffdshow 源代码分析 4：&nbsp;位图覆盖滤镜（滤镜部分Filter）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13660583\" >ffdshow 源代码分析 5：&nbsp;位图覆盖滤镜（总结）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15493329\" >ffdshow 源代码分析 6：&nbsp;对解码器的dll的封装（libavcodec）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15493521\" >ffdshow 源代码分析 7： libavcodec视频解码器类（TvideoCodecLibavcodec）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15493743\" >ffdshow 源代码分析 8：&nbsp;视频解码器类（TvideoCodecDec）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/15493961\" >ffdshow 源代码分析 9：&nbsp;编解码器有关类的总结</a></span> <br />12.2 LAV filters <p>LAV Filter是基于ffmpeg的解码器类库libavcodec，以及解封装器类库libavformat的DirectShow Filter。广泛安装在PC上。</p> <p>有关LAV Filter的源代码分析文章：<br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/12711379\" >LAV Filter 源代码分析 1：&nbsp;总体结构</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/12711723\" >LAV Filter 源代码分析 2： LAV Splitter</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13022201\" >LAV Filter 源代码分析 3： LAV Video （1）</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13272409\" >LAV Filter 源代码分析 4： LAV Video （2）</a></p> <p><br /></p>12.3 Mplayer <p>Mplayer是Linux下使用最广泛的播放器，也有Windows版本的。其中使用了ffmpeg。</p> <p><img src=\"http://img.blog.csdn.net/20140616103059000\" style=\"max-width:500px;\" /><br /></p> <p>有关Mplayer的源代码分析文章：<br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/11885509\" >MPlayer源代码分析</a><br /></p>12.4 Media Player Classic - HC <p>现在广为使用很多播放器都是构建于Media Player Classic - HC的基础之上的。</p> <p><img src=\"http://img.blog.csdn.net/20140616103124140\" style=\"max-width:500px;\" /><br /></p> <p>有关Media Player Classic - HC的源代码分析文章：<br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13280659\" >Media Player Classic - HC 源代码分析 1：整体结构</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13290345\" >Media Player Classic - HC 源代码分析 2：核心类&nbsp;（CMainFrame）（1）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13297291\" >Media Player Classic - HC 源代码分析 3：核心类&nbsp;（CMainFrame）（2）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13298397\" >Media Player Classic - HC 源代码分析 4：核心类&nbsp;（CMainFrame）（3）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13297555\" >Media Player Classic - HC 源代码分析 5：关于对话框&nbsp;（CAboutDlg）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13297589\" >Media Player Classic - HC 源代码分析 6：MediaInfo选项卡&nbsp;（CPPageFileMediaInfo）</a><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/13297621\" >Media Player Classic - HC 源代码分析 7：详细信息选项卡（CPPageFileInfoDetails）</a><br /></p>12.5 XBMC <p>XBMC是一个优秀的自由和开源的（GPL）媒体中心软件。<br /></p> <p><img src=\"http://img.blog.csdn.net/20140616105517937\" style=\"max-width:500px;\" /><br /></p> <p>有关XBMC源代码分析文章：<br /></p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/17454977\" >XBMC源代码分析 1：整体结构以及编译方法</a> <br /> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/17511993\" >XBMC源代码分析 2：Addons（皮肤Skin）</a><br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/17512743\" >XBMC源代码分析 3：核心部分（core）-综述</a><br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/17512509\" >XBMC源代码分析 4：视频播放器（dvdplayer）-解码器（以ffmpeg为例）</a><br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/17512633\" >XBMC源代码简析 5：视频播放器（dvdplayer）-解复用器（以ffmpeg为例）</a><br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/17512653\" >XBMC源代码分析 6：视频播放器（dvdplayer）-文件头（以ffmpeg为例）</a><br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/17512667\" >XBMC源代码分析 7：视频播放器（dvdplayer）-输入流（以libRTMP为例）</a></p> <p><br /></p>  【VS开发】MFC多线程编程注意事项 1458291373404 Text 1dad75de_a511047 【编程开发】 <p><strong>MFC</strong><strong>多线程编程注意事项</strong></p> <p>PeterLee整理 2008-05-26</p> <p><strong><a target=\"_blank\" rel=\"nofollow\" >1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表现——错误示例</a></strong></p> <p>关于启动线程时传输窗口对象（指针？句柄？）的问题：&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;在选择菜单中的开始线程后：&nbsp;&nbsp;&nbsp;<br />&nbsp; void &nbsp; cmainframe::onmenu_start()&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; afxbeginthread(mythread,&nbsp;&nbsp; this);&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;线程函数如下：&nbsp;&nbsp;&nbsp;<br />&nbsp; uint &nbsp; mythread(lpvoid &nbsp; pparam)&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmainframe*&nbsp;&nbsp; pmainfrm &nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(cmainframe&nbsp;&nbsp;&nbsp;*)pparam;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;问题一：&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的代码是不是有问题？&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（文档中说线程间不能直接传输mfc对象的指针，应该通过传输句柄实现）&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;问题二：&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样使用开始好像没有问题，直接通过pmainfrm访问窗口中的view都正常。&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但发现访问状态条时：&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pmainfrm－&gt;m_wndstatusbar.setpanetext(2,&nbsp;&nbsp;&nbsp;&quot;test);&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;出现debug &nbsp; assertion &nbsp; failed!（在窗口线程中没有问题）&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位置是wincore.cpp中的&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assert((p &nbsp;&nbsp;=&nbsp;&nbsp; pmap-&gt;lookuppermanent(m_hwnd))&nbsp;&nbsp;&nbsp;!=&nbsp;&nbsp; null &nbsp;&nbsp;||&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(p &nbsp;&nbsp;=&nbsp;&nbsp; pmap-&gt;lookuptemporary(m_hwnd))&nbsp;&nbsp;&nbsp;!=&nbsp;&nbsp; null);&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么访问view能正常，但访问状态条时不可以呢？&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;问题三：&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果通过传输句柄实现，怎样做呢？&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我用下面的代码执行时有问题：&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void &nbsp; cmainframe::onmenu_start()&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd &nbsp; hwnd &nbsp;&nbsp;=&nbsp;&nbsp; getsafehwnd();&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; afxbeginthread(mythread,&nbsp;&nbsp; hwnd);&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint &nbsp; mythread(lpvoid &nbsp; pparam)&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmainframe*&nbsp;&nbsp; pmainfrm &nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(cmainframe&nbsp;&nbsp;&nbsp;*)(cwnd::fromhandle((hwnd)pparam));&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行时通过线程中得到pmainfrm，访问其成员时不正常。&nbsp;</p> <p>&nbsp;</p> <p>网友：hewwatt</p> <p>大致原因解释如下：&nbsp;&nbsp;</p> <p> 1.&nbsp;&nbsp; mfc的大多数类不是线程安全的，cwnd及其消息路由是其中之最&nbsp;&nbsp;</p> <p> 2.&nbsp;&nbsp; mfc界面类的大多数方法，最后都是通过sendmessage实现的，而消息处理的&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过程中会引发其他消息的发送及处理。如果消息处理函数本身不是线程安全的&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你从工作线程中调用这些方法迟早会同你界面线程的用户消息响应发生冲突&nbsp;&nbsp;</p> <p> 3.&nbsp;&nbsp; cxxxx::fromhandle会根据调用者所在线程查表，如果查不到用户创建的cxxxx &nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对应对象，它会创建一个临时对象出来。由于你在工作线程中调用该方法，当然&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不可能查到界面主线程中你所建立起来的那个对象了。这时mfc会你创建一个临时&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象并返回给你，你根本不可能期望它的成员变量会是有意义的。&nbsp;&nbsp;&nbsp;所以要用&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也只能用cwnd::fromhandle，因为它只包含一个m_hwnd成员。&nbsp;&nbsp;&nbsp;不过，要记住&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨线程直接或间接地调用::sendmessage,通常都是行为不可预测的。&nbsp;&nbsp;</p> <p>&nbsp;</p> <p><strong><a target=\"_blank\" rel=\"nofollow\" >2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因分析</a></strong></p> <p>MFC界面包装类（多线程时成员函数调用的断言失败）</p> <p>日期：2006-9-17 18:06:00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Host01.Com]&nbsp;</p> <p><strong>MFC</strong><strong>界面包装类</strong></p> <p><strong>——多线程时成员函数调用的断言失败</strong></p> <p>&nbsp;&nbsp;&nbsp;经常在论坛上看到如下的问题：<br />DWORD WINAPI ThreadProc( void *pData&nbsp;)&nbsp;&nbsp;//&nbsp;线程函数（比如用于从COM口获取数据）<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;数据获取循环<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;数据获得后放在变量i中<br />&nbsp;&nbsp;&nbsp; CAbcDialog *pDialog&nbsp;= reinterpret_cast&lt; CAbcDialog*&nbsp;&gt;( pData );<br />&nbsp;&nbsp;&nbsp; ASSERT( pDialog );&nbsp;&nbsp;//&nbsp;此处如果ASSERT_VALID( pDialog )将断言失败<br />&nbsp;&nbsp;&nbsp; pDialog-&gt;m_Data = i;<br />&nbsp;&nbsp;&nbsp; pDialog-&gt;UpdateData( FALSE );&nbsp;&nbsp;// UpdateData内部ASSERT_VALID( this )断言失败<br />&nbsp;&nbsp;&nbsp;…<br />}<br />BOOL CAbcDialog::OnInitDialog()<br />{<br />&nbsp;&nbsp;&nbsp; CDialog::OnInitDialog();<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其他初始化代码<br />&nbsp;&nbsp;&nbsp; CreateThread( NULL, 0, ThreadProc, this, 0, NULL );&nbsp;&nbsp;//&nbsp;创建线程<br />&nbsp;&nbsp;&nbsp; return TRUE;<br />}<br />&nbsp;&nbsp;&nbsp;注意上面注释中的两处断言失败，本文从MFC底层的实现来解释为什么会断言失败，并说明MFC为什么要这样实现及相应的处理办法。<br />&nbsp;&nbsp;&nbsp;在说明MFC界面包装类的底层实现之前，由于其和窗口有关，故先讲解窗口类这个基础知识以为后面做铺垫。</p> <p><br /><strong>窗口类</strong></p> <p>&nbsp;&nbsp;&nbsp;窗口类是一个结构，其一个实例代表着一个窗口类型，与C++中的类的概念非常相近（虽然其表现形式完全不同，C++的类只不过是内存布局和其上的操作这个概念的类型），故被称作为窗口类。<br />&nbsp;&nbsp;&nbsp;窗口是具有设备操作能力的逻辑概念，即一种能操作设备（通常是显示器）的东西。由于窗口是窗口类的实例，就象C++中的一个类的实例，是可以具有成员函数的（虽然表现形式不同），但一定要明确窗口的目的——操作设备（这点也可以从Microsoft针对窗口所制订的API的功能看出，主要出于对设备操作的方便）。因此不应因为其具有成员函数的功能而将窗口用于功能对象的创建，这虽然不错，但是严重违反了语义的需要（关于语义，可参考我的另一篇文章——《语义的需要》），是不提倡的，但却由于MFC界面包装类的加入导致大多数程序员经常将逻辑混入界面。<br />&nbsp;&nbsp;&nbsp;窗口类是个结构，其中的大部分成员都没什么重要意义，只是Microsoft一相情愿制订的，如果不想使用界面API（Windows User Interface API），可以不管那些成员。其中只有一个成员是重要的——lpfnWndProc，消息处理函数。<br />&nbsp;&nbsp;&nbsp;外界（使用窗口的代码）只能通过消息操作窗口，这就如同C++中编写的具有良好的面向对象风格的类的实例只能通过其公共成员函数对其进行操作。因此消息处理函数就代表了一个窗口的一切（忽略窗口类中其他成员的作用）。很容易发现，窗口这个实例只具有成员函数（消息处理函数），不具有成员变量，即没有一块特定内存和一特定的窗口相关联，则窗口将不能具有状态（Windows还是提供了Window Properties API来缓和这种状况）。这也正是上面问题发生的根源。<br />&nbsp;&nbsp;&nbsp;为了处理窗口不能具有状态的问题（这其实正是Windows灵活的表现），可以有很多种方法，而MFC出于能够很容易的对已有窗口类进行扩展，选择了使用一个映射将一个窗口句柄（窗口的唯一标示符）和一个内存块进行绑定，而这块内存块就是我们熟知的MFC界面包装类（从CWnd开始派生延续）的实例。</p> <p><br /><strong>MFC</strong><strong>状态</strong></p> <p>&nbsp;&nbsp;&nbsp;状态就是实例通过某种手段使得信息可以跨时间段重现，C++的类的实例就是由外界通过公共成员函数改变实例的成员变量的值以实现具有状态的效果。在MFC中，具有三种状态：模块状态、进程状态、线程状态。分别为模块、进程和线程这三种实例的状态。由于代码是由线程运行，且和另外两个的关系也很密切，因此也被称作本地数据。<br /><strong>模块本地数据</strong><br />&nbsp;&nbsp;&nbsp;具有模块本地性的变量。模块指一个加载到进程虚拟内存空间中的PE文件，即exe文件本身和其加载的dll文件。而模块本地性即同样的指针，根据代码从不同的模块执行而访问不同的内存空间。这其实只用每个模块都声明一个全局变量，而前面的“代码”就在MFC库文件中，然后通过一个切换的过程（将欲使用的模块的那个全局变量的地址赋给前述的指针）即可实现模块本地性。MFC中，这个过程是通过调用AfxSetModuleState来切换的，而通常都使用AFX_MANAGE_STATE这个宏来处理，因此下面常见的语句就是用于模块状态的切换的：<br />AFX_MANAGE_STATE( AfxGetStaticModuleState()&nbsp;);<br />&nbsp;&nbsp;&nbsp; MFC中定义了一个结构（AFX_MODULE_STATE），其实例具有模块本地性，记录了此模块的全局应用程序对象指针、资源句柄等模块级的全局变量。其中有一个成员变量是线程本地数据，类型为AFX_MODULE_THREAD_STATE，其就是本文问题的关键。<br /><strong>进程本地数据</strong><br />&nbsp;&nbsp;&nbsp;具有进程本地性的变量。与模块本地性相同，即同一个指针，在不同进程中指向不同的内存空间。这一点Windows本身的虚拟内存空间这个机制已经实现了，不过在dll中定义的全局变量，如果dll支持Win32s，则其是共享其全局变量的，即不同的进程加载了同一dll将访问同一内存。Win32s是为了那些基于Win32的应用程序能在Windows 3.1上运行，由于Windows 3.1是16位操作系统，早已被淘汰，而现行的dll模型其本身就已经实现了进程本地性（不过还是可以通过共享节来实现Win32s中的dll的效果），因此进程状态其实就是一全局变量。<br />&nbsp;&nbsp;&nbsp; MFC中作为本地数据的结构有很多，如_AFX_WIN_STATE、_AFX_DEBUG_STATE、_AFX_DB_STATE等，都是MFC内部自己使用的具有进程本地性的全局变量。<br /><strong>线程本地数据</strong><br />&nbsp;&nbsp;&nbsp;具有线程本地性的变量。如上，即同一个指针，不同的线程将会访问不同的内存空间。这点MFC是通过线程本地存储（TLS——Thread Local Storage，其使用方法由于与本文无关，在此不表）实现的。<br />&nbsp;&nbsp;&nbsp; MFC中定义了一个结构（_AFX_THREAD_STATE）以记录某些线程级的全局变量，如最近一次的模块状态指针，最近一次的消息等。<br /><strong>模块线程状态</strong><br />&nbsp;&nbsp;&nbsp; MFC中定义的一个结构（AFX_MODULE_THREAD_STATE），其实例即具有线程本地性又具有模块本地性。也就是说不同的线程从同一模块中和同一线程从不同模块中访问MFC库函数都将导致操作不同的内存空间。其应用在AFX_MODULE_STATE中，记录一些线程相关但又模块级的数据，如本文的重点——窗口句柄映射。</p> <p><br /><strong>包装类对象和句柄映射</strong></p> <p>&nbsp;&nbsp;&nbsp;句柄映射——CHandleMap，MFC提供的一个底层辅助类，程序员是不应该直接使用它的。其有两个重要的成员变量：CMapPtrToPtr m_permanentMap, m_temporaryMap;。分别记录永久句柄绑定和临时句柄绑定。前面说过，MFC使用一个映射将窗口句柄和其包装类的实例绑定在一起，m_permanentMap和m_temporaryMap就是这个映射，分别映射永久包装类对象和临时包装类对象，而在前面提到过的AFX_MODULE_THREAD_STATE中就有一个成员变量：CHandleMap* m_pmapHWND;（之所以是CHandleMap*是使用懒惰编程法，尽量节约资源）以专门完成HWND的绑定映射，除此以外还有如m_pmapHDC、m_pmapHMENU等成员变量以分别实现HDC、HMENU的绑顶映射。而为什么这些映射要放在模块线程状态而不放在线程状态或模块状态是很明显的——这些包装类包装的句柄都是和线程相关的（如HWND只有创建它的线程才能接收其消息）且这个模块中的包装类对象可能不同于另一个模块的（如包装类是某个DLL中专门派生的一个类，如a.dll中定义的CAButton的实例和b.dll中定义的CBButton的实例如果同时在一个线程中。此时线程卸载了a.dll，然后CAButton的实例得到消息并进行处理，将发生严重错误——类代码已经被卸载掉了）。</p> <p>包装类存在的意义有二：包装对HWND的操作以加速代码的编写和提供窗口子类化（不是超类化）的效果以派生窗口类。包装类对象针对线程分为两种：永久包装类对象（以后简称永久对象）和临时包装类对象（以后简称临时对象）。临时对象的意义仅仅只有包装对HWND的操作以加速代码编写，不具有派生窗口类的功能。永久对象则具有前面说的包装类的两个意义。<br />&nbsp;&nbsp;&nbsp;&nbsp;在创建窗口时（即CWnd::CreateEx中），MFC通过钩子提前（WM_CREATE和WM_NCCREATE之前）处理了通知，用AfxWndProc子类化了创建的窗口并将对应的CWnd*加入当前线程的永久对象的映射中，而在AfxWndProc中，总是由CWnd::FromHandlePermanent（获得对应HWND的永久对象）得到当前线程中当前消息所属窗口句柄对应的永久对象，然后通过调用得到的CWnd*的WindowProc成员函数来处理消息以实现派生窗口类的效果。这也就是说永久对象具有窗口子类化的意义，而不仅仅是封装HWND的操作。<br />&nbsp;&nbsp;&nbsp;&nbsp;要将一个HWND和一个已有的包装类对象相关联，调用CWnd::Attach将此包装类对象和HWND映射成永久对象（但这种方法得到的永久对象不一定具有子类化功能，很可能仍和临时对象一样，仅仅起封装的目的）。如果想得到临时对象，则通过CWnd::FromHandle这个静态成员函数以获得。临时对象之所以叫临时，就是其是由MFC内部（CHandleMap::FromHandle）生成，其内部（CHandleMap::DeleteTemp）销毁（一般通过CWinThread::OnIdle中调用AfxUnlockTempMaps）。因此程序员是永远不应该试图销毁临时对象的（即使临时对象所属线程没有消息循环，不能调用CwinThread::OnIdle，在线程结束时，CHandleMap的析构仍然会销毁临时对象）。</p> <p><br /><strong>原因</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;为什么要分两种包装类对象？很好玩吗？注意前面提过的窗口模型——只能通过消息机制和窗口交互。注意，也就是说窗口是线程安全的实例。窗口过程的编写中不用考虑会有多个线程同时访问窗口的状态。如果不使用两种包装类对象，在窗口创建的钩子中通过调用SetProp将创建的窗口句柄和对应的CWnd*绑定，不一样也可以实现前面说的窗口句柄和内存块的绑定？<br />&nbsp;&nbsp;&nbsp; CWnd的派生类CA，具有一个成员变量m_BGColor以决定使用什么颜色填充底背景。线程1创建了CA的一个实例a，将其指针传进线程2，线程2设置a.m_BGColor为红色。这已经很明显了，CA::m_BGColor不是线程安全的，如果不止一个线程2，那么a.m_BGColor将会出现线程访问冲突。这严重违背窗口是线程安全的这个要求。因为使用了非消息机制与窗口进行交互，所以失败。<br />&nbsp;&nbsp;&nbsp;&nbsp;继续，如果给CA一个公共成员函数SetBGColor，并在其中使用原子操作以保护m_BGColor，不就一切正常了？呵，在CA::OnPaint中，会两次使用m_BGColor进行绘图，如果在两次绘图之间另一线程调用CA::SetBGColor改变了CA::m_BGColor，问题严重了。也就是说不光是CA::m_BGColor的写操作需要保护，读操作亦需要保护，而这仅仅是一个成员变量。<br />&nbsp;&nbsp;&nbsp;&nbsp;那么再继续，完全按照窗口本身的定义，只使用消息与它交互，也就是说自定义一个消息，如AM_SETBGCOLOR，然后在CA::SetBGColor中SendMessage这个消息，并在其响应函数中修改CA::m_BGColor。完美了，这是即符合窗口概念又很好的设计，不过它要求每一个程序员编写每一个包装类时都必须注意到这点，并且最重要的是，C++类的概念在这个设计中根本没有发挥作用，严重地资源浪费。<br />&nbsp;&nbsp;&nbsp;&nbsp;因此，MFC决定要发挥C++类的概念的优势，让包装类对象看起来就等同于窗口本身，因此使用了上面的两种包装类对象。让包装类对象随线程的不同而不同可以对包装类对象进行线程保护，也就是说一个线程不可以也不应该访问另一个线程中的包装类对象（因为包装类对象就相当于窗口，这是MFC的目标，并不是包装类本身不能被跨线程访问），“不可以”就是通过在包装类成员函数中的断言宏实现的（在CWnd::AssertValid中），而“不应该”前面已经解释地很清楚了。因此本文开头的断言失败的根本原因就是因为违反了“不可以”和“不应该”。<br />&nbsp;&nbsp;&nbsp;&nbsp;虽然包装类对象不能跨线程访问，但是窗口句柄却可以跨线程访问。因为包装类对象不仅等同于窗口，还改变了窗口的交互方式（这也正是C++类的概念的应用），使得不用非得使用消息机制才能和窗口交互。注意前面提到的，如果跨线程访问包装类对象，而又使用C++类的概念操作它，则其必须进行线程保护，而“不能跨线程访问”就消除了这个问题。因此临时对象的产生就只是如前面所说，方便代码的编写而已，不提供子类化的效果，因为窗口句柄可以跨线程访问。</p> <p><br /><strong>解决办法</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;已经了解失败的原因，因此做如下修改：<br />DWORD WINAPI ThreadProc( void *pData&nbsp;)&nbsp;&nbsp;//&nbsp;线程函数（比如用于从COM口获取数据）<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;数据获取循环<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;数据获得后放在变量i中<br />&nbsp;&nbsp;&nbsp; CAbcDialog *pDialog&nbsp;= static_cast&lt; CAbcDialog*&nbsp;&gt;(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWnd::FromHandle( reinterpret_cast&lt; HWND &gt;( pData )&nbsp;)&nbsp;);<br />&nbsp;&nbsp;&nbsp; ASSERT_VALID( pDialog );&nbsp;&nbsp;//&nbsp;此处可能断言失败<br />&nbsp;&nbsp;&nbsp; pDialog-&gt;m_Data = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这是不好的设计，详情可参看我的另一篇文章：《语义的需要》<br />&nbsp;&nbsp;&nbsp; pDialog-&gt;UpdateData( FALSE );&nbsp;&nbsp;// UpdateData内部ASSERT_VALID( this )可能断言失败<br />&nbsp;&nbsp;&nbsp;&nbsp;…<br />}<br />BOOL CAbcDialog::OnInitDialog()<br />{<br />&nbsp;&nbsp;&nbsp; CDialog::OnInitDialog();<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其他初始化代码<br />&nbsp;&nbsp;&nbsp; CreateThread( NULL, 0, ThreadProc, m_hWnd, 0, NULL );&nbsp;&nbsp;//&nbsp;创建线程<br />&nbsp;&nbsp;&nbsp; return TRUE;<br />}<br />&nbsp;&nbsp;&nbsp;&nbsp;之所以是“可能”，因为这里有个重点就是临时对象是HWND操作的封装，不是窗口类的封装。因此所有的HWND临时对象都是CWnd的实例，即使上面强行转换为CAbcDialog*也依旧是CWnd*，所以在ASSERT_VALID里调用CAbcDialog::AssertValid时，其定义了一些附加检查，则可能发现这是一个CWnd的实例而非一个CAbcDialog实例，导致断言失败。因此应将CAbcDialog全部换成CWnd，这下虽然不断言失败了，但依旧错误（先不提pDialog-&gt;m_Data怎么办），因为临时对象是HWND操作的封装，而不幸的是UpdateData只是MFC自己提供的一个对话框数据交换的机制（DDX）的操作，其不是通过向HWND发送消息来实现的，而是通过虚函数机制。因此在UpdateData中调用实例的DoDataExchange将不能调用CAbcDialog::DoDataExchange，而是调用CWnd::DoDataExchange，因此将不发生任何事。<br />&nbsp;&nbsp;&nbsp;&nbsp;因此合理（并不一定最好）的解决方法是向CAbcDialog的实例发送一个消息，而通过一个中间变量（如一全局变量）来传递数据，而不是使用CAbcDialog::m_Data。当然，如果数据少，比如本例，就应该将数据作为消息参数进行传递，减少代码的复杂性；数据多则应该通过全局变量传递，减少了缓冲的管理费用。修改后如下：<br />#define AM_DATANOTIFY ( WM_USER + 1 )<br />static DWORD g_Data = 0;<br />DWORD WINAPI ThreadProc( void *pData&nbsp;)&nbsp;&nbsp;//&nbsp;线程函数（比如用于从COM口获取数据）</p> <p>{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;数据获取循环<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;数据获得后放在变量i中<br />&nbsp;&nbsp;&nbsp; g_Data = i;<br />&nbsp;&nbsp;&nbsp; CWnd *pWnd&nbsp;= CWnd::FromHandle( reinterpret_cast&lt; HWND &gt;( pData )&nbsp;);<br />&nbsp;&nbsp;&nbsp; ASSERT_VALID( pWnd );&nbsp;&nbsp;//&nbsp;本例应该直接调用平台SendMessage而不调用包装类的，这里只是演示<br />&nbsp;&nbsp;&nbsp; pWnd-&gt;SendMessage( AM_DATANOTIFY, 0, 0 );<br />&nbsp;&nbsp;&nbsp;&nbsp;…<br />}<br />BEGIN_MESSAGE_MAP( CAbcDialog, CDialog )<br />&nbsp;&nbsp;&nbsp;&nbsp;…<br />&nbsp;&nbsp;&nbsp; ON_MESSAGE( AM_DATANOTIFY, OnDataNotify )<br />&nbsp;&nbsp;&nbsp;&nbsp;…<br />END_MESSAGE_MAP()<br />BOOL CAbcDialog::OnInitDialog()<br />{<br />&nbsp;&nbsp;&nbsp; CDialog::OnInitDialog();<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;其他初始化代码<br />&nbsp;&nbsp;&nbsp; CreateThread( NULL, 0, ThreadProc, m_hWnd, 0, NULL );&nbsp;&nbsp;//&nbsp;创建线程<br />&nbsp;&nbsp;&nbsp; return TRUE;<br />}<br />LRESULT CAbcDialog::OnDataNotify( WPARAM /* wParam */, LPARAM /* lParam */&nbsp;)<br />{<br />&nbsp;&nbsp;&nbsp; UpdateData( FALSE );<br />&nbsp;&nbsp;&nbsp; return 0;<br />}<br />void CAbcDialog::DoDataExchange( CDataExchange *pDX&nbsp;)<br />{<br />&nbsp;&nbsp;&nbsp; CDialog::DoDataExchange( pDX );<br />&nbsp;&nbsp;&nbsp; DDX_Text( pDX, IDC_EDIT1, g_Data );<br />}</p> <p>&nbsp;</p> <p><strong><a target=\"_blank\" rel=\"nofollow\" >3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意事项</a></strong></p> <p><strong>“</strong><strong>线程安全</strong><strong>”</strong><strong>是一个什么概念？</strong></p> <p>以前常听高手告诫MFC对象不要跨线程使用，因为MFC不是线程安全的。比如CWnd对象不要跨线程使用,可以用窗口句柄（HWND）代替。CSocket/CAsyncSocket对象不要跨线程使用,用SOCKET句柄代替.那么到底什么是线程安全呢?什么时候需要考虑?如果程序涉及到多线程的话，就应该考虑线程安全问题。比如说设计的接口，将来需要在多线程环境中使用，或者需要跨线程使用某个对象时，这个就必须考虑了。关于线程安全也没什么权威定义。在这里我只说说我的理解：所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;一般而言“线程安全”由多线程对共享资源的访问引起。如果调用某个接口时需要我们自己采取同步措施来保护该接口访问的共享资源,则这样的接口不是线程安全的.MFC和STL都不是线程安全的.&nbsp;怎样才能设计出线程安全的类或者接口呢?如果接口中访问的数据都属于私有数据,那么这样的接口是线程安全的.或者几个接口对共享数据都是只读操作,那么这样的接口也是线程安全的.如果多个接口之间有共享数据,而且有读有写的话,如果设计者自己采取了同步措施，调用者不需要考虑数据同步问题，则这样的接口是线程安全的，否则不是线程安全的。</p> <p>&nbsp;</p> <p>&nbsp;</p> <p><strong>多线程的程序设计应该注意些什么呢</strong></p> <p>1、尽量少的使用全局变量、static变量做共享数据，尽量使用参数传递对象。被参数传递的对象，应该只包括必需的成员变量。所谓必需的成员变量，就是必定会被多线程操作的。很多人图省事，会把this指针（可能是任意一个对象指针）当作线程参数传递，致使线程内部有过多的操作权限，对this中的参数任意妄为。整个程序由一个人完成，可能会非常注意，不会出错，但只要一转手，程序就会面目全非。当两个线程同时操作一个成员变量的时候，程序就开始崩溃了，更糟的是，这种错误很难被重现。（我就在郁闷这个问题，我们是几个人，把程序编成debug版，经过数天使用，才找到错误。而找到错误只是开始，因为你要证明这个bug被修改成功了，也非常困难。）其实，线程间数据交互大多是单向的，在线程回调函数入口处，尽可能的将传入的数据备份到局部变量中（当然，用于线程间通讯的变量不能这么处理），以后只对局部变量做处理，可以很好的解决这种问题。</p> <p>2、在MFC中请慎用线程。因为MFC的框架假定你的消息处理都是在主线程中完成的。首先窗口句柄是属于线程的，如果拥有窗口句柄的线程退出了，如果另一个线程处理这个窗口句柄，系统就会出现问题。而MFC为了避免这种情况的发生，使你在子线程中调用消息（窗口）处理函数时，就会不停的出Assert错误，烦都烦死你。典型的例子就时CSocket，因为CSocket是使用了一个隐藏窗口实现了假阻塞，所以不可避免的使用了消息处理函数，如果你在子线程中使用CSocket，你就可能看到assert的弹出了。</p> <p>3、不要在不同的线程中同时注册COM组件。两个线程，一个注册1.ocx, 2.ocx, 3.ocx, 4.ocx;&nbsp;而另一个则注册5.ocx, 6.ocx, 7.ocx, 8.ocx，结果死锁发生了，分别死在FreeLibrary和DllRegisterServer，因为这8个ocx是用MFC中做的，也可能是MFC的Bug，但DllRegisterServer却死在GetModuleFileName里，而GetModuleFileName则是个API唉！如果有过客看到，恰巧又知道其原因，请不吝赐教。</p> <p>4、不要把线程搞的那么复杂。很多初学者，恨不能用上线程相关的所有的函数，这里互斥，那里等待，一会儿起线程，一会儿关线程的，比起goto语句有过之而无不及。好的多线程程序，应该是尽量少的使用线程。这句话怎么理解呐，就是说尽量统一一块数据共享区存放数据队列，工作子线程从队列中取数据，处理，再放回数据，这样才会模块化，对象化；而不是每个数据都起一个工作子线程处理，处理完了就关闭，写的时候虽然直接，等维护起来就累了。</p> <p><br /></p>  【DSP开发】6678加载问题 1455965527351 Text 1dad75de_a03daf1 【DSP开发】 <p>&nbsp;首先C6678是一个多核处理器（8个C66XX核），每个核都有自己独立32KB的LIP、32KB的L1D以及512KB的L2，此外8个核还有4M的共享的MSM，接口资源包括，SRIO，PCIe，Hyperlink，Gigabit Ethernet (GbE)，EMIF，TSIP，UART，I2C，SPI接口。其中SRIO、Hyperlink、PCIe为常用的高速接口可以满足片间（两个C6678之间）、板件（两个C6678板卡之间）高速的数据交换需求。而UART、I2C、SPI则为常用典型的低速接口，以满足某些典型的低速芯片访问需求，例如SPI-norflash、I2C-eeprom等。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一、加载模式，加载模式是DSP针对芯片启动首先需要考虑的问题，因为实际应用当中不可能总是使用仿真器来完成程序的加载工作，作为成熟的方案，程序总是通过上电后用某个实现设定好的接口完成程序的加载工作。而&nbsp;针对这些接口，RBL（ROM bootloader）确实支持多种程序加载模式，包括，EMIF bootmode,SRIO bootmode,Ethernet bootmode ,PCIe bootmode,I2C bootmode,SPI bootmode,Hyperlink bootmode,UART bootmode。这些启动方式的选择是由RBL启动时读取配置引脚（C6678EVM板是由拨动开关控制的）电平来决定的。针对各种加载方式以下为简单描述。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）SPI加载方式，可以通过SPI外挂一个NorFlash，将待加载的程序通过TI官方提供的转化工具将需要加载的.out程序转化成.h文件，然后通过仿真器将数据烧写到norFlash中，最后将6678配置成SPI启动方式，重新上电即可。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）PCIE加载模式，由于目前版本的C6678存在PLL频率锁不住的问题，所以需将C6678配置成二次加载模式，具体而言就是先用SPI加载，然后通过SPI加载的程序初始化好PLL始终以及PCIE接口，然后通过PCIE接口来加载程序，PCIE加载模式是由上位机通过PCIE直接写DSP内存来实现加载功能的。首先通过TI官方提供的工具将需要加载的.out程序转化成.bin文件，然后读取bin文件通过PCIE接口直接写到DSP内存，然后触发运行即可。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）以太网口加载模式（EMAC boot），该加载模式是通过网口发送udp包来完成的，首先是文件的处理，将需要加载.out文件用TI官网提供的工具转化成.eth文件，然后将DSP配置成以太网加载模式，DSP会通过网口想外界广播BOOTP的广播包，通过抓包工具抓包，并分析DSP的MAC地址，再通过ARP命令将该MAC地址映射到与上位机同一网段的IP地址上，最后用TI提供的pcsendpkt工具将.eth文件发送给DSP，DSP受到上位机发送的UDP的数据包后，会自动凭借数据，最后自动触发运行程序。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、3种加载方式的优缺点比较。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这三种加载模式各有优缺点，第一种加载方式-SPI加载方式，适合在程序已经开发得很成熟的时候，此时将程序固化到FLASH中，将芯片配置成以SPI加载模式以后，重新上电后芯片便会从FLASH中读取程序启动。但是这种加载模式由于需要将程序固化到FLASH中，增在了程序加载的稳定性，但是同时也不利于更改和调试。第二种加载模式-PCIE加载模式，适合用于上位机对DSP的测试，因为这种加载模式加载非常灵活，而且调试起来也很容易，因为上位机可以通过PCIE直接读写DSP内存，很多时候甚至可以做到仿真器可以做到的事情。第三种方式-以太网加载，以太网加载的好处是可以更加方便、快捷的实现加载功能，尤其是实现远程加载功能，而这正好弥补了第一种和第二种加载方式的不足，缺点是上位机无法像PCIE、SRIO那样直接将DSP内存直接映射过来从而完成对DSP内存的直接读写，所以不利于调试。</p> <p><br /></p>  【编程开发】JFIF文件格式即JPEG文件交换格式 1455891006414 Text 1dad75de_a021b30 【编程开发】 <p>JFIF文件格式即JPEG文件交换格式(JPEG File Interchonge Format)。<br />一般的JFIF文件由下面的9个部分组成：<br />（字段偏移量&nbsp;字段长度（若未说明“长度不定”则表明在任何情况下长度均为所写的值）&nbsp;字段内容（若未说明“内容不定”则在任何情况下内容均为所写的值，为方便表示还可以把内容设为某值））<br />(1)&nbsp;图像开始SOI(Start of Image)标记<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0h 2字节 0xFFD8<br />(2) APP0标记(Marker)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0h 2字节 0xFFE0<br />&nbsp;&nbsp;① APP0长度(length)（①~⑨九个字段的总长度）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2h 2字节&nbsp;内容不定（①~⑨九个字段的总长度）&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;②&nbsp;标识符(identifier)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4h 5字节 0x4A46494600 即“JFIF0”<br />&nbsp;&nbsp;③&nbsp;版本号(version)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9h 2字节 0x0102 JFIF的版本号目前基本上都是1.2 &nbsp;&nbsp;<br />&nbsp;&nbsp;④ X和Y的密度单位(units=0：无单位；units=1：点数/英寸；units=2：点数/厘米)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bh 1字节&nbsp;只有0，1，2三个值可选，其分别代表的意义如上<br />&nbsp;&nbsp;⑤ X方向像素密度(X density)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ch 2字节&nbsp;取值范围未知<br />&nbsp;&nbsp;⑥ Y方向像素密度(Y density)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eh 2字节&nbsp;取值范围未知&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;⑦&nbsp;缩略图水平像素数目(thumbnail horizontal pixels)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10h 1字节&nbsp;取值范围未知<br />&nbsp;&nbsp;⑧&nbsp;缩略图垂直像素数目(thumbnail vertical pixels)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11h 1字节&nbsp;取值范围未知<br />&nbsp;&nbsp;⑨&nbsp;缩略图RGB位图(thumbnail RGB bitmap)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12h 长度可能是3的倍数&nbsp;内容不定<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本段（APP0）可以包含图像的一个微缩版本，存为24位的RGB像素。如果没有微缩图像<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（这种情况更常见），则⑦“缩略图水平像素数目”和⑧“缩略图垂直像素数目”的值均为0。<br />(3) APPn标记(Markers)，其中n=1～15(任选)<br />&nbsp;&nbsp;① APPn长度(length)（①②两个字段的总长度）<br />&nbsp;&nbsp;②&nbsp;详细信息(application specific information)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对每个APP：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若为APPN（N＝1～F（以16进制表示，N任选其中一个））<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标记&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mh 2字节 0xFFEN<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长度&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m+2)h 2字节&nbsp;内容不定（设为n（10进制））（本字段与下一字段的总长度）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;详细信息<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m+4)h n－2字节（即长度减2）&nbsp;内容不定<br />(4)&nbsp;一个或者多个量化表DQT(Difine Quantization Table)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0h 2字节 0xFFDB<br />&nbsp;&nbsp;①&nbsp;量化表长度(quantization table length)（①~②两个字段的总长度）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2h 2字节&nbsp;内容不定（①~②两个字段的总长度）&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;②&nbsp;量化表(quantization table)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) P/T(高四位：精度，低四位：表ID)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b)&nbsp;表项<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对每个量化表：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P/T(高四位：精度，低四位：表ID)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mh 1字节&nbsp;精度, 0 表示 8 bit, 1表示 16 bit；ID取值范围为0～3,&nbsp;否则错误&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表项<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m+1)h (64&times;(精度+1))字节&nbsp;内容长，故略<br />(5)&nbsp;帧图像开始SOF0(Start of Frame)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0h 2字节 0xFFC0<br />&nbsp;&nbsp;①&nbsp;帧开始长度(start of frame length)&nbsp;（①~⑥六个字段的总长度）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2h 2字节&nbsp;内容不定（①~⑥六个字段的总长度）<br />&nbsp;&nbsp;②&nbsp;精度(precision)，每个颜色分量每个像素的位数(bits per pixel per color component)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4h 1字节&nbsp;每个样本位数,&nbsp;通常是 8 (大多数<a target=\"_blank\" rel=\"nofollow\" href=\"http://tbhacker.com/\" >软件</a>不支持 12 和 16)<br />&nbsp;&nbsp;③&nbsp;图像高度(image height)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5h 2字节&nbsp;内容不定（如果不支持 DNL 就必须&nbsp;&gt;0）<br />&nbsp;&nbsp;④&nbsp;图像宽度(image width)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7h 2字节&nbsp;内容不定（如果不支持 DNL 就必须&nbsp;&gt;0）<br />&nbsp;&nbsp;⑤&nbsp;颜色分量数(number of color components)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9h 1字节&nbsp;内容不定（灰度图是 1, YCbCr/YIQ 彩色图是 3, CMYK 彩色图是 4，我们<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里讨论的JFIF使用的是YCbCr，故这里颜色分量数为3）<br />&nbsp;&nbsp;⑥&nbsp;对每个颜色分量(for each component)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) ID <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b)&nbsp;垂直方向的样本因子(vertical sample factor)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c)&nbsp;水平方向的样本因子(horizontal sample factor)&nbsp;（b) c)共占用1字节，b)占用低4<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;位，c)占用高4位）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d)&nbsp;量化表号(quantization table#)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JFIF格式使用的是YCbCr所以有3个分量（这里特别要注意的是颜色分量的ID号是有<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;含义的，1代表Y，2代表Cb，3代表Cr，4代表I，5代表Q）：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1) ID <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ah 1字节 0x01<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（高四位）水平（低四位）垂直样本因子&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bh 共1字节 0x22<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;量化表号&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ch 1字节&nbsp;内容不定（本分量使用的量化表的ID号）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) ID <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dh 1字节 0x02<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（高四位）水平（低四位）垂直样本因子&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eh 共1字节 0x11<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;量化表号&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fh 1字节&nbsp;内容不定（本分量使用的量化表的ID号）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) ID <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10h 1字节 0x03<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（高四位）水平（低四位）垂直样本因子&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11h 共1字节 0x11<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;量化表号&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12h 1字节&nbsp;内容不定（本分量使用的量化表的ID号）<br />(6)&nbsp;一个或者多个霍夫曼表DHT(Difine Huffman Table)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0h 2字节 0xFFC4<br />&nbsp;&nbsp;&nbsp;&nbsp;①&nbsp;霍夫曼表的长度(Huffman table length)&nbsp;（①~②两个字段的总长度）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2h 2字节&nbsp;内容不定（①~②两个字段的总长度）<br />&nbsp;&nbsp;&nbsp;&nbsp;②&nbsp;对每个霍夫曼表(一般情况下，霍夫曼表不止一个，但是绝对不多于4个)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a)&nbsp;表号<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b)&nbsp;类型：AC或者DC(Type, AC or DC。其中0为DC表，1为AC表)（a) b)共占用1字<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节，a)占用低4位，b)占用高4位）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c)&nbsp;长16个字节的编码，其代码代数和为接下来的编码的长度<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d)&nbsp;内容编码<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对每个霍夫曼表：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（高四位）类型和（低四位）表号&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mh 共1字节&nbsp;内容不定（有四个可能：0x00表示第0个DC表，0x01表示第1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;个DC表，0x10表示第0个AC表，0x11表示第1个AC表）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长16个字节的编码&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m+1)h 16字节&nbsp;内容不定（设这16个字节上数据之和为n）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内容编码&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m+17)h n字节&nbsp;内容长，故略<br />(7)&nbsp;定义重新开始间隔DRI(Difine Restart Interval)（在没有DRI标记，或间隔为零时，就不存在重<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开始间隔和重开始标记）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0h 2字节 0xFFDD<br />&nbsp;&nbsp;①&nbsp;长度<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2h 2字节 0x0004（①~②两个字段的总长度）<br />&nbsp;&nbsp;② MCU 块的单元中的重新开始间隔<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4h 2字节&nbsp;内容不定（设为n，则意思是说，每n个MCU块就有一个RSTn标记。第一个标记<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是RST0，然后是RST1等，RST7后再从RST0重复）<br />(8)&nbsp;扫描开始SOS(Start of Scan)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0h 2字节 0xFFDA<br />&nbsp;&nbsp;①&nbsp;扫描开始长度(start of scan length)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2h 2字节&nbsp;内容不定（①~③再加上④的a) b) c)的总长度）<br />&nbsp;&nbsp;②&nbsp;颜色分量数(number of color components)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4h 1字节&nbsp;应该和⑸⑤的值相同（灰度图是1, YCbCr/YIQ 彩色图是3, CMYK 彩色图是4）<br />&nbsp;&nbsp;③&nbsp;每个颜色分量<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) ID <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b)&nbsp;交流系数表号(AC table #)&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c)&nbsp;直流系数表号(DC table #)（b) c)共占用1字节，b)占用低4位，c)占用高4位）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由②得到这里的颜色分量数为3（这里的颜色分量的ID号的含义和⑸⑥的一样，1代表<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y，2代表Cb，3代表Cr，4代表I，5代表Q）：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1) ID <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5h 1字节 0x01<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（高四位）直流（低四位）交流数表号&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6h 共1字节 0x00<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) ID <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7h 1字节 0x02<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（高四位）直流（低四位）交流数表号&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8h 共1字节 0x11<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) ID <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9h 1字节 0x03<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（高四位）直流（低四位）交流数表号&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ah 共1字节 0x11<br />&nbsp;&nbsp;④&nbsp;压缩图像数据(compressed image data)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a)&nbsp;谱选择开始<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bh 1字节 0x00<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b)&nbsp;谱选择结束<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ch 1字节 0x3F<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c)&nbsp;两个4位字段，高位和低位的谱选择<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dh 1字节&nbsp;在基本JPEG中总为00<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d)&nbsp;数据<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eh 长度不定&nbsp;内容长，故略<br />(9)&nbsp;图像结束EOI(End of Image)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0h 2字节 0xFFD9 <br /></p>  【硬件开发】TTL CMOS RS232电平 1455846755141 Text 1dad75de_a006d39 【硬件开发】 <p>工作中遇到一个关于电平选择的问题,居然给忘记RS232电平的定义了,当时无法反应上来,回来之后查找资料才了解两者之间的区别,视乎两年多的时间,之前非常熟悉的一些常识也开始淡忘,这个可不是一个好的现象.:-),还是把关于三种常见的电平的区别copy到这里.做加深记忆的效果之用..</p> <p>什么是TTL电平、CMOS电平、RS232电平？它们有什么区别呢？一般说来，CMOS电平比TTL电平有着更高的噪声容限。</p> <p>（一）、TTL电平标准&nbsp;<br />输出 L：&nbsp;&lt;0.8V ； H：&gt;2.4V。&nbsp;<br />输入 L：&nbsp;&lt;1.2V ； H：&gt;2.0V <br />TTL器件输出低电平要小于0.8V，高电平要大于2.4V。输入，低于1.2V就认为是0，高于2.0就认为是1。于是TTL电平的输入低电平的噪声容限就只有(0.8-0)/2=0.4V，高电平的噪声容限为(5-2.4)/2=1.3V。</p> <p>（二）、CMOS电平标准&nbsp;<br />输出 L：&nbsp;&lt;0.1*Vcc ； H：&gt;0.9*Vcc。&nbsp;<br />输入 L：&nbsp;&lt;0.3*Vcc ； H：&gt;0.7*Vcc.&nbsp;<br />由于CMOS电源采用12V，则输入低于3.6V为低电平，噪声容限为1.8V，高于3.5V为高电平，噪声容限高为1.8V。比TTL有更高的噪声容限。</p> <p>（三）、RS232标准<br />逻辑1的电平为-3～-15V，逻辑0的电平为+3～+15V，注意电平的定义反相了一次。</p> <p>TTL与CMOS电平使用起来有什么区别&nbsp;<br />1.电平的上限和下限定义不一样，CMOS具有更大的抗噪区域。&nbsp;同是5伏供电的话，ttl一般是1.7V和3.5V的样子，CMOS一般是2.2V,2.9V的样子，不准确，仅供参考。</p> <p>2.电流驱动能力不一样，ttl一般提供25毫安的驱动能力，而CMOS一般在10毫安左右。</p> <p>3.需要的电流输入大小也不一样，一般ttl需要2.5毫安左右，CMOS几乎不需要电流输入。</p> <p>4.很多器件都是兼容TTL和CMOS的，datasheet会有说明。如果不考虑速度和性能，一般器件可以互换。但是需要注意有时候负载效应可能引起电路工作不正常，因为有些ttl电路需要下一级的输入阻抗作为负载才能正常工作。</p> <p>1.&nbsp;&nbsp;&nbsp;&nbsp; TTL电路和CMOS电路的逻辑电平</p> <p>VOH:&nbsp;&nbsp;逻辑电平 1 的输出电压</p> <p>VOL:&nbsp;&nbsp;逻辑电平 0 的输出电压</p> <p>VIH&nbsp;:&nbsp;&nbsp;逻辑电平 1 的输入电压</p> <p>VIH&nbsp;:&nbsp;&nbsp;逻辑电平 0 的输入电压</p> <p>TTL电路临界值：</p> <p>VOHmin&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp; 2.4V &nbsp;&nbsp; VOLmax &nbsp;=&nbsp;&nbsp;&nbsp; 0.4V</p> <p>VIHmin &nbsp;&nbsp;=&nbsp;&nbsp;&nbsp; 2.0V &nbsp;&nbsp; VILmax &nbsp;=&nbsp;&nbsp;&nbsp; 0.8V</p> <p>CMOS电路临界值（电源电压为＋5V）</p> <p>VOHmin &nbsp;&nbsp;=&nbsp;&nbsp;&nbsp; 4.99V &nbsp;&nbsp;&nbsp; VOLmax &nbsp;=&nbsp;&nbsp;&nbsp; 0.01V</p> <p>VIHmin &nbsp;&nbsp;=&nbsp;&nbsp;&nbsp; 3.5V &nbsp;&nbsp; VILmax &nbsp;=&nbsp;&nbsp;&nbsp; 1.5V</p> <p>2.&nbsp;&nbsp;&nbsp;&nbsp; TTL和CMOS的逻辑电平转换</p> <p>CMOS电平能驱动TTL电平</p> <p>TTL电平不能驱动CMOS电平，需加上拉电阻。</p> <p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常用逻辑芯片特点</p> <p>74LS系列：&nbsp;&nbsp;&nbsp; TTL &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入:&nbsp;&nbsp; TTL &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出:&nbsp;&nbsp;&nbsp; TTL</p> <p>74HC系列：&nbsp;&nbsp;&nbsp; CMOS &nbsp;&nbsp;&nbsp;输入:&nbsp;&nbsp; CMOS &nbsp;&nbsp;&nbsp;输出:&nbsp;&nbsp;&nbsp; CMOS</p> <p>74HCT系列：&nbsp; CMOS &nbsp;&nbsp;&nbsp;输入:&nbsp;&nbsp; TTL &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出:&nbsp;&nbsp;&nbsp; CMOS</p> <p>CD4000系列：CMOS &nbsp;&nbsp;&nbsp;输入:&nbsp;&nbsp; CMOS &nbsp;&nbsp;输出:&nbsp;&nbsp;&nbsp; CMOS</p> <p><br /></p>  【编程开发】P制,N制,奇场,偶场,隔行扫描,逐行扫描 1455782740421 Text 1dad75de_9fe5790 【编程开发】 <p>场的概念原于电视，电视由于要克服信号频率带宽的限制，无法在制式规定的刷新时间内（PAL制式是25fps）同时将一帧图象显现在屏幕上，只能将图象分成两个半幅的图像，一先一后地显现，由于刷新速度快，肉眼是看不见地。普通电视都是采用隔行扫描方式。隔行扫描方式是将一帧电视画面分成奇数场和偶数场两次扫描。第一次扫出由1、3、5、7…等所有奇数行组成的奇数场，第二次扫出由2、4、6、8…等所有偶数行组成的偶数场（premiere中称为顶部场Upper Field 和底部场 Low Field,关系为偶数场Even field 应对应顶部场 upper field ,奇数场odd field 应对应底部场 lower field ）。这样，每一幅图象经过两场扫描，所有的象素便全部扫完。<br /><br />众所周知，电视荧光屏上的扫描频率（即帧频）有30Hz（美国、日本等，帧频为30fps的称为NTFS制式）和25Hz（西欧、中国等，帧频为25fps的称为PAL制式）两种，即电视每秒钟可传送30帧或25帧图像，30Hz和25Hz分别与相应国家电源的频率一致。电影每秒钟放映24个画格，这意味着每秒传送24幅图像，与电视的帧频24Hz意义相同。电影和电视确定帧频的共同原则是为了使人们在银幕上或荧屏上能看到动作连续的活动图像，这要求帧频在24Hz以上。&nbsp;为了使人眼看不出银幕和荧屏上的亮度闪烁，电影放映时，每个画格停留期间遮光一次，换画格时遮光一次，于是在银幕上亮度每秒钟闪烁48次。电视荧光屏的亮度闪烁频率必须高于48Hz才能使人眼觉察不出闪烁。由于受信号带宽的限制，电视采用隔行扫描的方式满足这一要求。每帧分两场扫描，每个场消隐期间荧光屏不发光，于是荧屏亮度每秒闪烁50次（25帧）和60次（30帧）。这就是电影和电视帧频不同的历史原因。但是电影的标准在世界上是统一的。&nbsp;<br /><br />场是因隔行扫描系统而产生的，两场为一帧，目前我们所看到的普通电视的成像，实际上是由两条叠加的扫描折线组成的，比如你想把一张白纸涂黑，你就拿起铅笔，在纸上从上边开始，左右划折线，一笔不断的一直画到纸的底部，这就是一场，然而很不幸，这是你发现画的太稀，于是你又插缝重复补画一次，于是就是电视的一帧。场频的锯齿波与你画的并无异样，只不过在回扫期间，也就是逆程信号是被屏蔽了的；然而这先后的两笔就存在时间上的差异，反映在电视上就是频闪了，造成了视觉上的障碍，于是我们通常会说不清晰。<br />现在，随着器件的发展，逐行系统也就应运而生了，因为它的一幅画面不需要第二次扫描，所以场的概念也就可以忽略了，同样是在单位时间内完成的事情，由于没有时间的滞后及插补的偏差，逐行的质量要好得多，这就是大家要求弃场的原因了，当然代价是，要求硬件（如电视）有双倍的带宽，和线性更加优良的器件，如行场锯齿波发生器及功率输出级部件，其特征频率必然至少要增加一倍。当然，由于逐行生成的信号源（碟片）具有先天优势，所以同为隔行的电视播放，效果也是有显著的差异的。&nbsp;<br /><br />就采集设备而言，它所采集的AVI本身就存在一个场序的问题,而这又是采集卡的驱动程序和主芯片以及所采集的视频制式所共同决定的；就播放设备而言,它所播放的机器本身还存在一个场序的问题,而这又是播放设备所采用的工业规范标准以及所播放的视频制式所决定的；上述两个设备的场序是既定的，不可更改的。具体设置可以参看下面的图表STDLIST。<br /><br />在实际制作中，就用PREMIERE,在采集制作时的场序则可以根据我们的意愿作适当的调整,其根本宗旨是把采集设备的场序适当的调整到播放设备的场序。首先要确定采集设备在采集不同制式不同信号源时,所采用的场序，这可以从采集设备技术说明书中查到；其次要确定你最终输出视频格式和播放机所采用的场序，这可以从所播放的视频制式工业规范标准以中查到；好了，现在我们就可以用采集设备的场序来采集，用播放设备的场序来输出。这正是我们在PREMIERE中作场序调整的目的之所在。&nbsp;<br /><br />在premiere中输出的时候，注意输出的场跟源文件的场要一致,否则会抖动的很厉害或有锯齿。<br />还有有些插件不支持场输出，比如Final Effect（模拟各类天气效果的，雨、雪等），Power sms（有1000多个转场的那个）。&nbsp;<br />还有好莱坞中（Hollywood）请注意设置场的顺序（要不然会出现抖动情况的）。<br />在premiere中慢动作的设置和做vcd的设置不一样，请自己根据设备的不同进行研究&nbsp;。<br /><br />还有一个问题，就是我们在渲染动画图片时到底带不带场？这里有几个可以遵循的原则：<br /><br />1.如果渲染的图像要和将来的实拍影像合成，最好带场输出，在合成软件中先对他们去场，合成后再带场渲染输出。<br /><br />2.如果是单纯的动画，根据图像决定，如果画面有大幅度的水平移动（包括近处物体的移动、物体的快速飞行、整个摄像机的摇移等），<br /><br />应该带场输出，避免抖动产生。<br /><br />3.如果没有必要带场输出，最好不要带。因为这样产生的图像品质更高。&nbsp;<br /><br />最后渲染图片一般还要拿到合成软件中进行后期加工，这时一般先去场，然后进行合成操作，最后渲染输出时再把场打开。在奇偶场<br /><br />的选择上没有什么规律，根据输出设备的设置而定，所以最保险的方法是先进行渲染测试，只要在监视器上播出部抖动就没有问题，如果<br /><br />抖动就把渲染时输出场的设置方向反一下。<br /><br />下面是一些工业格式影片规范标准：<br /><br />格式&nbsp;帧尺寸&nbsp;帧纵横比&nbsp;像素比&nbsp;帧速度&nbsp;场顺序<br /><br />NTSC 640x480 4:3 1 29.97Fps UpperFirst<br /><br />NTSC Full 640x486 4:3 1 29.97Fps UpperFirst<br /><br />NTSC-DV 720x480 3:2 0.9 29.97Fps LowerFirst<br /><br />D-1 NTSC 720x486 4:3 0.9 29.97Fps LowerFirst<br /><br />PAL 768x576 4:3 1 25Fps UpperFirst<br /><br />PAL-DV 720x576 5:4 1.067 25Fps UpperFirst<br /><br />D-1 PAL 720x576 4:3 1.067 25Fps UpperFirst <br /><br />HDTV 720/30P 1280x720 16:9 1 30Fps UpperFirst <br /><br />HDTV 1080/24P 1920x1080 16:9 1 30Fps UpperFirst <br /><br />Motion Picture 2K 2048x1536 8:3 2 24Fps NoFirst<br /><br />Cineon Full 3656x2664 457:333 2 24Fps NoFirst<br /><br />Cineon Half 1828x1332 8:3 2 24Fps NoFirst <br /><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://bbs.cgpower.com.cn/post/view?bid=19&amp;id=7671&amp;sty=1&amp;tpg=1&amp;age=0\" >http://bbs.cgpower.com.cn/post/view?bid=19&amp;id=7671&amp;sty=1&amp;tpg=1&amp;age=0</a><br /></p>  【编程开发】JPEG文件编/解码详解 1455777203914 1455777226105 Text 1dad75de_9fe5618 【编程开发】 <p>JPEG文件编/解码详解</p> <p>cat_ng 猫猫</p> <p>JPEG（Joint Photographic Experts Group）是联合图像专家小组的英文缩写。它由国际电话与电报咨询委员会</p> <p>CCITT（The International Telegraph and Telephone Consultative Committee）与国际标准化组织ISO于1986年联合</p> <p>成立的一个小组，负责制定静态数字图像的编码标准。</p> <p>小组一直致力于标准化工作，开发研制出连续色调、多级灰度、静止图像的数字图像压缩编码方法，即JPEG</p> <p>算法。JPEG算法被确定为国际通用标准，其适用范围广泛，除用于静态图像编码外，还推广到电视图像序列的帧</p> <p>内图像压缩。而用JPEG算法压缩出来的静态图片文件称为JPEG文件，扩展名通常为*.jpg、*.jpe*.jpeg。</p> <p>JPEG专家组开发了两种基本的压缩算法、两种数据编码方法、四种编码模式。具体如下：</p> <p>压缩算法：</p> <ul> <li><p>有损的离散余弦变换（Discrete Cosine Transform，DCT）；</p></li> <li><p>无损的预测技术压缩。</p></li> </ul> <p>数据编码方法：</p> <ul> <li><p>哈夫曼编码；</p></li> <li><p>算术编码；</p></li> </ul> <p>编码模式：</p> <ul> <li><p>基于DCT顺序模式：编/解码通过一次扫描完成；</p></li> <li><p>基于DCT递进模式：编/解码需要多次扫描完成，扫描效果从粗糙到精细，逐级递进；</p></li> <li><p>无损模式：基于DPCM，保证解码后完全精确恢复到原图像采样值；</p></li> <li><p>层次模式：图像在多个空间多种分辨率进行编码，可以根据需要只对低分辨率数据作解码，放弃高分辨率信息。</p></li> </ul> <p>在实际应用中，JPEG图像使用的是离散余弦变换、哈夫曼编码、顺序模式。</p> <p>&nbsp;</p> <p>JPEG压缩编码算法的主要计算步骤如下：</p> <p>(0) 8*8分块。</p> <p>(1)&nbsp;正向离散余弦变换(FDCT)。</p> <p>(2)&nbsp;量化(quantization)。</p> <p>(3) Z字形编码(zigzag scan)。</p> <p>(4)&nbsp;使用差分脉冲编码调制(DPCM)对直流系数(DC)进行编码。</p> <p>(5)&nbsp;使用行程长度编码(RLE)对交流系数(AC)进行编码。</p> <p>(6)&nbsp;熵编码。</p> <p>&nbsp;</p> <p>笔者在实践过程中查阅了大量的资料，发现大多数书籍资料和网上资料都是从编码角度分析JPEG的编/解码方式，</p> <p>并且都只是介绍编码过程中的主要方法。所以，本文从解码角度详细分析JPEG的编/解码过程，并且加入许多笔</p> <p>者实践过程中遇到的问题和解决方法，希望从另一个角度说明问题，以更好帮助读者结合其他资料解决问题。</p> <p>不过，介绍解码过程之前，首先要了解JPEG文件中数据的存储格式。</p> <p><br /></p> <p><strong>一、</strong><strong>JPEG</strong><strong>文件格式介绍</strong></p> <p>JPEG文件使用的数据存储方式有多种。最常用的格式称为JPEG文件交换格式（JPEG File Interchange Format，JFIF</p> <p>）。而JPEG文件大体上可以分成两个部分：标记码(Tag)和压缩数据。</p> <p>标记码由两个字节构成，其前一个字节是固定值0xFF，后一个字节则根据不同意义有不同数值。在每个标记码之前</p> <p>还可以添加数目不限的无意义的0xFF填充，也就说连续的多个0xFF可以被理解为一个0xFF，并表示一个标记码</p> <p>的开始。而在一个完整的两字节的标记码后，就是该标记码对应的压缩数据流，记录了关于文件的诸种信息。</p> <p>常用的标记有<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/lpt19832003/archive/2007/07/28/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&amp;Toolbar=Default#SOI\" >SOI</a>、<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/lpt19832003/archive/2007/07/28/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&amp;Toolbar=Default#APP0\" >APP0</a>、<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/lpt19832003/archive/2007/07/28/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&amp;Toolbar=Default#DQT\" >DQT</a>、<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/lpt19832003/archive/2007/07/28/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&amp;Toolbar=Default#SOF\" >SOF0</a>、<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/lpt19832003/archive/2007/07/28/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&amp;Toolbar=Default#DHT\" >DHT</a>、<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/lpt19832003/archive/2007/07/28/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&amp;Toolbar=Default#DRI\" >DRI</a>、<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/lpt19832003/archive/2007/07/28/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&amp;Toolbar=Default#SOS\" >SOS</a>、<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/lpt19832003/archive/2007/07/28/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&amp;Toolbar=Default#EOI\" >EOI</a>。</p> <p>注意，SOI等都是标记的名称。在文件中，标记码是以标记代码形式出现。例如SOI的标记代码为0xFFD8</p> <p>，即在JPEG文件中的如果出现数据0xFFD8，则表示此处为一个SOI标记。</p> <p>本文<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/lpt19832003/archive/2007/07/28/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&amp;Toolbar=Default#%E9%99%84%E5%BD%951%EF%BC%9AJPEG%E5%AE%9A%E4%B9%89%E7%9A%84%E6%A0%87%E8%AE%B0\" >附录</a>列出一张完整的JPEG定义的标记表，供读者查阅。这里仅列出几个常用标记的标记代码、占用字</p> <p>节长度和表示的意义。</p> <p>&nbsp;</p> <p>l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOI，Start of Image，图像开始</p> <ul> <li><p>标记代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0xFFD8</p></li> </ul> <p>&nbsp;</p> <p>l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; APP0，Application，应用程序保留标记0</p> <ul> <li><p>标记代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0xFFE0</p></li> <li><p>包含9个具体字段：<br />&nbsp;①&nbsp;数据长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①~⑨9个字段的总长度<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即不包括标记代码，但包括本字段<br />&nbsp;②&nbsp;标识符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5字节&nbsp;&nbsp;&nbsp;&nbsp;固定值0x4A46494600，即字符串“JFIF0”<br />&nbsp;&nbsp;③&nbsp;版本号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;一般是0x0102，表示JFIF的版本号1.2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能会有其他数值代表其他版本<br />&nbsp;④ X和Y的密度单位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有三个值可选<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0：无单位；1：点数/英寸；2：点数/厘米<br />&nbsp;⑤ X方向像素密度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值范围未知<br />&nbsp;⑥ Y方向像素密度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值范围未知&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;⑦&nbsp;缩略图水平像素数目&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值范围未知<br />&nbsp;⑧&nbsp;缩略图垂直像素数目&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取值范围未知<br />&nbsp;⑨&nbsp;缩略图RGB位图&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;长度可能是3的倍数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缩略图RGB位图数据</p></li> </ul> <p>&nbsp;</p> <p>本标记段可以包含图像的一个微缩版本，存为24位的RGB像素。如果没有微缩图像（这种情况更常见），则</p> <p>字段⑦“缩略图水平像素数目”和字段⑧“缩略图垂直像素数目”的值均为0。</p> <p>&nbsp;</p> <ol> <li><p>APPn，Application，应用程序保留标记n，其中n=1～15(任选)</p></li> <li><p>标记代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0xFFE1~0xFFF</p></li> <li><p>包含2个具体字段：<br />&nbsp;①&nbsp;数据长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①~②2个字段的总长度<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即不包括标记代码，但包括本字段<br />&nbsp;②&nbsp;详细信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据长度-2字节&nbsp;&nbsp;&nbsp;内容不定<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p></li> </ol> <p>例如，Adobe Photoshop生成的JPEG图像中就用了APP1和APP13两个标记段分别存储了一幅图像的副本。</p> <p>&nbsp;</p> <p>l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DQT，Define Quantization Table，定义量化表</p> <ul> <li><p>标记代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0xFFDB</p></li> <li><p>包含9个具体字段：<br />&nbsp;①&nbsp;数据长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字段①和多个字段②的总长度<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即不包括标记代码，但包括本字段<br />&nbsp;②&nbsp;量化表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据长度-2字节</p></li> </ul> <p>a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;精度及量化表ID &nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高4位：精度，只有两个可选值<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0：8位；1：16位<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;低4位：量化表ID，取值范围为0～3</p> <p>b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表项&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(64&times;(精度+1))字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如8位精度的量化表<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其表项长度为64&times;（0+1）=64字节</p> <p>&nbsp;</p> <p>本标记段中，字段②可以重复出现，表示多个量化表，但最多只能出现4次。</p> <p>&nbsp;</p> <p>l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOF0，Start of Frame，帧图像开始</p> <ul> <li><p>标记代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0xFFC0</p></li> <li><p>包含9个具体字段：<br />&nbsp;①&nbsp;数据长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①~⑥六个字段的总长度<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即不包括标记代码，但包括本字段<br />&nbsp;②&nbsp;精度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个数据样本的位数<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常是8位，一般软件都不支持 12位和16位<br />&nbsp;③&nbsp;图像高度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图像高度（单位：像素），如果不支持 DNL 就必须&nbsp;&gt;0<br />&nbsp;&nbsp;④&nbsp;图像宽度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图像宽度（单位：像素），如果不支持 DNL 就必须&nbsp;&gt;0<br />&nbsp;&nbsp;⑤&nbsp;颜色分量数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有3个数值可选<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1：灰度图；3：YCrCb或YIQ；4：CMYK<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而JFIF中使用YCrCb，故这里颜色分量数恒为3<br />&nbsp;&nbsp;⑥颜色分量信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;颜色分量数&times;3字节（通常为9字节）</p></li> </ul> <p>a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;颜色分量ID &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;水平/垂直采样因子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高4位：水平采样因子<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;低4位：垂直采样因子<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（曾经看到某资料把这两者调转了）</p> <p>c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;量化表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前分量使用的量化表的ID<br /><br /></p> <p>本标记段中，字段⑥应该重复出现，有多少个颜色分量（字段⑤），就出现多少次（一般为3次）。</p> <p>&nbsp;</p> <p>l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DHT，Difine Huffman Table，定义哈夫曼表</p> <ul> <li><p>标记代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0xFFC4</p></li> <li><p>包含2个具体字段：<br />&nbsp;①数据长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字段①和多个字段②的总长度<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即不包括标记代码，但包括本字段<br />&nbsp;②&nbsp;哈夫曼表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据长度-2字节</p></li> </ul> <p>a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表ID和表类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高4位：类型，只有两个值可选<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0：DC直流；1：AC交流<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;低4位：哈夫曼表ID，<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，DC表和AC表分开编码</p> <p>b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同位数的码字数量&nbsp;&nbsp;&nbsp; 16字节</p> <p>c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编码内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16个不同位数的码字数量之和（字节）<br /><br /></p> <p>本标记段中，字段②可以重复出现（一般4次），也可以致出现1次。例如，Adobe Photoshop 生成</p> <p>的JPEG图片文件中只有1个DHT标记段，里边包含了4个哈夫曼表；而Macromedia Fireworks生成</p> <p>的JPEG图片文件则有4个DHT标记段，每个DHT标记段只有一个哈夫曼表。</p> <p>&nbsp;</p> <p>l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DRI，Define Restart Interval，定义差分编码累计复位的间隔</p> <ul> <li><p>标记代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0xFFDD</p></li> <li><p>包含2个具体字段：<br />&nbsp;①数据长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0x0004，①~②两个字段的总长度<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即不包括标记代码，但包括本字段<br />&nbsp;②MCU块的单元中的重新开始间隔<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设其值为n，则表示每n个MCU块就有一个<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RSTn标记。第一个标记是RST0，第二个是<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RST1等，RST7后再从RST0重复。</p></li> </ul> <p>&nbsp;</p> <p>如果没有本标记段，或间隔值为0时，就表示不存在重开始间隔和标记RST</p> <p>&nbsp;</p> <p>l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOS，Start of Scan，扫描开始 12字节</p> <ul> <li><p>标记代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0xFFDA</p></li> <li><p>包含2个具体字段：<br />&nbsp;①数据长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①~④两个字段的总长度<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即不包括标记代码，但包括本字段<br />&nbsp;②颜色分量数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应该和SOF中的字段⑤的值相同，即：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1：灰度图是；3： YCrCb或YIQ；4：CMYK。</p></li> </ul> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而JFIF中使用YCrCb，故这里颜色分量数恒为3<br />&nbsp;&nbsp;&nbsp;③颜色分量信息<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a)&nbsp;颜色分量ID &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b)&nbsp;直流/交流系数表号 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高4位：直流分量使用的哈夫曼树编号<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;低4位：交流分量使用的哈夫曼树编号</p> <p>&nbsp;④&nbsp;压缩图像数据<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a)谱选择开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0x00<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b)谱选择结束&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0x3F<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c)谱选择&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在基本JPEG中总为00</p> <p>&nbsp;</p> <p>本标记段中，字段③应该重复出现，有多少个颜色分量（字段②），就出现多少次（一般为3次）。</p> <p>本段结束后，紧接着就是真正的图像信息了。图像信息直至遇到一个标记代码就自动结束，一般就是以EOI标记表示结束。</p> <p>&nbsp;</p> <ol> <li><p> EOI，End of Image，图像结束 2字节</p></li> <li><p>标记代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;固定值0xFFD9</p></li> </ol> <p>&nbsp;</p> <p>这里补充说明一下，由于在JPEG文件中0xFF具有标志性的意思，所以在压缩数据流(真正的图像信息)中</p> <p>出现0xFF，就需要作特别处理。具体方法是，在数据0xFF后添加一个没有意义的0x00。换句话说，如果在图像数</p> <p>据流中遇到0xFF，应该检测其紧接着的字符，如果是</p> <p>1）0x00，则表示0xFF是图像流的组成部分，需要进行译码；</p> <p>2）0xD9，则与0xFF组成标记EOI，则图像流结束，同时图像文件结束；</p> <p>3）0xD0~0xD7,则组成RSTn标记，则要忽视整个RSTn标记，即不对当前0xFF和紧接的0xDn两个字节进行译码，并按RST标记的规则调整译码变量；</p> <p>3）0xFF，则忽视当前0xFF，对后一个0xFF再作判断；</p> <p>4）其他数值，则忽视当前0xFF，并保留紧接的此数值用于译码。</p> <p>&nbsp;</p> <p><strong>二、&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong><strong>JPEG</strong><strong>解码过程详解</strong></p> <p><strong>&nbsp;</strong></p> <p>下面来详细讲述JPEG文件的解码过程。</p> <p>&nbsp;</p> <p><strong>1</strong><strong>．读入文件的相关信息</strong></p> <p>按照上述的JPEG文件数据存储方式，把要解码的文件的相关信息一一读出，为接下来的解码工作做好准备。</p> <p>参考方法是，设计一系列的结构体对应各个标记，并存储标记内表示的信息。其中图像长宽、多个量化</p> <p>表和哈夫曼表、水平/垂直采样因子等多项信息比较重要。以下给出读取过程中的两个问题。</p> <p>&nbsp;</p> <p>1）整个文件的大体结构</p> <p>JFIF格式的JPEG文件(*.jpg)的一般顺序为：</p> <p>SOI(0xFFD8)</p> <p>APP0(0xFFE0)</p> <p>[APPn(0xFFEn)]可选</p> <p>DQT(0xFFDB)</p> <p>SOF0(0xFFC0)</p> <p>DHT(0xFFC4)</p> <p>SOS(0xFFDA)</p> <p>压缩数据</p> <p>EOI(0xFFD9)</p> <p>&nbsp;</p> <p>2）字的高低位问题</p> <p>JPEG文件格式中，一个字（16位）的存储使用的是 Motorola 格式,&nbsp;而不是 Intel 格式。也就是说,一个字的</p> <p>高字节（高8位）在数据流的前面,&nbsp;低字节（低8位）在数据流的后面，与平时习惯的Intel格式不一样。.</p> <p>&nbsp;</p> <p>3）读出哈夫曼表数据</p> <p>a）理论说明</p> <p>在标记段DHT内，包含了一个或者多个的哈夫曼表。对于单一个哈夫曼表，应该包括了三部分：</p> <ul> <li><p>哈夫曼表ID和表类型<br />这个字节的值为一般只有四个0x00、0x01、0x10、0x11。<br />0x00表示DC直流0号表；<br />0x01表示DC直流1号表；<br />0x10表示AC交流0号表；<br />0x11表示AC交流1号表。</p></li> <li><p>不同位数的码字数量</p></li> </ul> <p>JPEG文件的哈夫曼编码只能是1~16位。这个字段的16个字节分别表示1~16位的编码码字在哈夫曼树中的个数。</p> <ul> <li><p>编码内容</p></li> </ul> <p>这个字段记录了哈夫曼树中各个叶子结点的权。所以，上一字段（不同位数的码字数量）的16个数</p> <p>值之和就应该是本字段的长度，也就是哈夫曼树中叶子结点个数。</p> <p>&nbsp;</p> <p>b）举例说明</p> <p>以下面一段哈夫曼表数据举例说明（数据全部以16进制表示）：</p> <p>11 00 02 02 00 05 01 06 01 00 00 00 00 00 00 00 00<br />00 01 11 02 21 03 31 41 12 51 &nbsp; 61 71 81 91 22 13 32<br /><br /></p> <p>红色部分（第1字节）为哈夫曼表ID和表类型，其值0x11表示此部分数据描述的是AC交流1号表。</p> <p>蓝色部分（2~17字节）为不同位数的码字的数量。这16个数值实际意义为：没有1位和4</p> <p>位的哈夫曼码字；2位和3位的码字各有2个；5位码字有5个；6位和8位码字各有1个；7位码字各有6个；没有9位或以上的码字。</p> <p>绿色部分（18~34字节）为编码内容。由蓝色部分数据知道，此哈夫曼树有0+2+2+0+5+1+6+1=17个叶子结点，</p> <p>即本字段应该有17个字节。这段数据表示17个叶子结点按从小到大排列，其权值依次为0、1、11、2、21、3、31、41……</p> <p>&nbsp;</p> <p>4）建立哈夫曼树</p> <p>a）理论说明</p> <p>在读出哈夫曼表的数据后，就要建立哈夫曼树。具体方法为：</p> <p>1）第一个码字必定为0。<br />如果第一个码字位数为1，则码字为0；<br />如果第一个码字位数为2，则码字为00；<br />如此类推。</p> <p>2）从第二个码字开始，<br />如果它和它前面的码字位数相同，则当前码字为它前面的码字加1；<br />如果它的位数比它前面的码字位数大，则当前码字是前面的码字加1后再在后边添若干个0，直至满足位数长度为止。</p> <p>b）举例说明</p> <p>继续以上边的例子说明问题。</p> <ul> <li><p>由于没有1位的码字，所以第一个码字的位数为2，即码字为00；</p></li> <li><p>由于2位的码字有两个，所以第二个码字位数仍为2，即码字为00+1=01；</p></li> <li><p>第三个码字为3位，比第二个码字长1位，所以第三个码字为：01+1=10，然后再添1个“0”，得100；</p></li> <li><p>……</p></li> </ul> <p>如此类推，最后得到这个哈夫曼树如下：</p> <p>&nbsp;</p> <p>特别注意的是，如果中间有某个位数的码字缺失，例如没有4位码字，则应该在3位码字加1后，添加“00”补足5位，形成下一个5位码字。</p> <p>&nbsp;</p> <p>在准备好所有的图片信息后，就可以对图片数据进行解码了。</p> <p>&nbsp;</p> <p><strong>2</strong><strong>．初步了解图像数据流的结构</strong></p> <p>1）理论说明</p> <p>分析图像数据流的结构，笔者准备以一个从宏观到微观的顺序为读者详细剖析，即：</p> <p>&nbsp;</p> <p>数据流&agrave;最小编码单元&agrave;数据单元与颜色分量。</p> <p>&nbsp;</p> <p>a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在图片像素数据流中，信息可以被分为一段接一段的最小编码单元（Minimum Coded Unit，MCU）数据流。</p> <p>所谓MCU，是图像中一个正方矩阵像素的数据。</p> <p>矩阵的大小是这样确定的：</p> <p>查阅标记SOF0，可以得到图像不同颜色分量的采样因子，即Y、Cr、Cb三个分量各自的水平采样因子和垂直采</p> <p>样因子。大多图片的采样因子为4：1：1或1：1：1。其中，4：1：1即（2*2）：（1*1）：（1*1））；1：1：1</p> <p>即（1*1）：（1*1）：（1*1）。记三个分量中水平采样因子最大值为Hmax，垂直采样因子最大值为Vmax，那么</p> <p>单个MCU矩阵的宽就是Hmax*8像素，高就是Vmax*8像素。</p> <p>如果，整幅图像的宽度和高度不是MCU</p> <p>宽度和高度的整数倍，那么编码时会用某些数值填充进去，保证解码过程中MCU的完整性（解码完成后，可直接</p> <p>忽视图像宽度和高度外的数据）。</p> <p>在数据流中，MCU的排列方法是从左到右，从上到下。</p> <p>&nbsp;</p> <p>b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个MCU又分为若干个数据单元。数据单元的大小必定为8*8，所以每个MCU的数据单元个数为Hmax*Vmax。</p> <p>另外JPEG的压缩方法与BMP</p> <p>文件有所不同，它不是把每个像素的颜色分量连续存储在一起的，而是把图片分成Y，Cr，Cb三张子图，然后分</p> <p>别压缩。而三个颜色分量的采样密度（即采样因子）可能一样（例如1：1：1）也可能不一样（例如4：1：1）。</p> <p>每个MCU内部，数据的顺序是Y、Cr、Cb。如果一个颜色分量有多个数据单元，则顺序是从左到右，从上到下。</p> <p>&nbsp;</p> <p>2）举例说明</p> <p>下面通过一幅32*35的图像，对上面两个问题列出两种采样因子的具体说明。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>图 1 整张完整的图像（4：1：1）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图 2 将图像的MCU1放大</p> <p>&nbsp;</p> <p>图1及图3中灰色部分为实际图像大小（32px*35px）；粗虚线表示各个MCU的分界；细虚线表示MCU内部数据单元的分界。</p> <p>&nbsp;</p> <p>a）&nbsp;&nbsp;&nbsp;&nbsp;采样因子为4：1：1</p> <p>此时，Hmax=max（2，1，1）=2，Vmax=max（2，1，1）=2。所以，MCU的宽为Hmax*8=16</p> <p>像素，高为Vmax*8=16像素。图像实际的宽刚好是2个MCU，但高则稍稍大于2个MCU的高度，所以要补足3行MCU。</p> <p>在数据流中，MCU的顺序是MCU1&agrave;MCU2&agrave;MCU3&agrave;MCU4&agrave;MCU5&agrave;MCU6。</p> <p>每个MCU又分为Hmax*Vmax=2*2=4个数据单元。由于采样因子是4：1：1，即（2*2）：（1*1）：（1*1</p> <p>），所以Y分量的水平和垂直方向都是每2个像素采样2次；Cr分量和Cb分量的水平和垂直方向都是每2个像素采样1次。</p> <p>因此，在一个MCU来里边，Y分量有256个采样点，即4个完整的数据单元；Cr分量和Cb分量各自只有64个采样点。</p> <p>如果以MCU1说明MCU数据的次序，则依次为Y1&nbsp;、Y2&nbsp;、Y5&nbsp;、Y6&nbsp;、Cr1256&nbsp;、Cb1256&nbsp;。图2中全部256个点均是Y的采样点，红色部分为Cr分量和Cr分量的采样点。</p> <p>换句话说，对于整张图片来说，数据流的数据依次是：<br />[Y1 、Y2&nbsp;、Y5&nbsp;、Y6&nbsp;、Cr1256&nbsp;、Cb1256]&nbsp;、[Y3&nbsp;、Y4&nbsp;、Y7&nbsp;、Y8&nbsp;、Cr3478&nbsp;、Cb3478]&nbsp;、[Y9&nbsp;、Y10、Y13&nbsp;、Y14&nbsp;、Cr9101314&nbsp;、Cb9101314&nbsp;]、……</p> <p>图 3 整张完整的图像（1：1：1）</p> <p>&nbsp;</p> <p>b）&nbsp;&nbsp;&nbsp;&nbsp;采样因子为1：1：1</p> <p>如图3。Hmax=max（1，1，1）=1，Vmax=max（1，1，1）=2。所以，MCU的宽为Hmax*8=8像素，高为Vmax*8=8像素。</p> <p>图像实际的宽刚好是4个MCU，但高则稍稍大于4个MCU的高度，所以要补足5行MCU。</p> <p>在数据流中，MCU的顺序是：<br />MCU1&agrave;MCU2&agrave;MCU3&agrave;MCU4&agrave;&nbsp;…………&nbsp;&agrave;MCU18&agrave;MCU19&agrave;MCU20。</p> <p>每个MCU又分为Hmax*Vmax=1*1=1个数据单元，也就是一个数据单元就是一个MCU。由于采样因子是1：1：1，</p> <p>即（1*1）：（1*1）：（1*1），所以Y分量、Cr分量和Cb分量的水平和垂直方向都是每1个像素采样1次，也就是</p> <p>图象的每一个像素都是采样点。因此，在一个MCU来里边，Y分量、Cr分量和Cb分量各自有64个采样点。有</p> <p>因此，对于整张图片来说，数据流的数据依次是：<br />[Y1 、Cr1、Cb1]&nbsp;、[Y2&nbsp;&nbsp;、Cr2&nbsp;、Cb2]&nbsp;、[Y3&nbsp;、Cr3、Cb3]&nbsp;、…………&nbsp;[Y19&nbsp;、Cr19、Cb19]、[Y20、Cr20、Cb20]。</p> <p>&nbsp;</p> <p><strong>3</strong><strong>．颜色分量单元的内部解码</strong></p> <p>1）理论说明</p> <p>“颜色分量单元”是笔者为说明问题而建立的概念，指的是MCU中某个颜色分量中的一个8*8数据块，例如上面提到的Y1&nbsp;、Cr1、Cb1&nbsp;都是一个颜色分量单元。</p> <p>图像数据流是以位（bit）为单位存储信息的。并且内部的数据都是在编码时通过正向离散余弦变换（FDCT）进</p> <p>行时空域向频率域变换而得到的结果，所以对于每个颜色分量单元都应该由两部分组成：1个直流分量和63个交流分量。</p> <p>解码的过程其实就是哈夫曼树的查找过程。</p> <p>首先查阅标记段SOS中的颜色分量信息，可以得出各个颜色分量对应使用的直流分量和交流分量使用的哈夫曼树编号。一般来说，<br />Y分量：直流分量：直流0号哈夫曼树，交流分量：交流0号哈夫曼树；</p> <p>Cr分量：直流分量：直流1号哈夫曼树，交流分量：交流1号哈夫曼树；</p> <p>Cb分量：直流分量：直流1号哈夫曼树，交流分量：交流1号哈夫曼树。</p> <p>&nbsp;</p> <p>颜色分量单元内部综合运用了RLE行程编码和哈夫曼编码来压缩数据。每个像素的数据流由两部分构成：编码和数值，并且</p> <p>两者基本以互相隔开方式出现（除非该编码的权值为零）。具体读入单个颜色分量单元的步骤如下：</p> <p>a）从此颜色分量单元数据流的起点开始一位一位的读入，直到读入的编码与该分量直流哈夫曼树的某个码字（叶子结点）一</p> <p>致，然后用直流哈夫曼树查得该码字对应的权值。权值（共8位）表示该直流分量数值的二进制位数，也就是接下来需要读入的位数。</p> <p>b）继续读入位数据，直到读入的编码与该分量交流哈夫曼树的某个码字（叶子结点）一致，然后用交流哈夫曼树查得该码字</p> <p>对应的权值。权值的高4位表示当前数值前面有多少个连续的零，低4位表示该交流分量数值的二进制位数，也就是接下来需要读入的位数。</p> <p>c）不断重复步骤b，直到满足交流分量数据结束的条件。而结束条件有两个，只要满足其中一个即可：</p> <p>①当读入码字的权值为零，表示往后的交流变量全部为零；</p> <p>②已经读入63个交流分量。</p> <p>d）各个数值的译码是按下表进行的：</p> <p>&nbsp;</p> <p>2）举例说明</p> <p>下面举例说明以上几点。某个颜色分量单元数据如下：</p> <p>D3 5E 6E 4D 35 f5 8A</p> <p>若以二进制表示，则为：</p> <p>1101 0011 0101 1110 0110 1110 0100 1101 0011 0101 1111 0101 1000 1010</p> <p>假设该颜色分量单元对应以下直流哈夫曼树和交流哈夫曼树，则可将各个以位为单位的数据流拆分如下：</p> <p><span style=\"text-decoration:underline;\" >110 1001101</span>&nbsp;<span style=\"text-decoration:underline;\" >01 1</span>&nbsp;<span style=\"text-decoration:underline;\" >11001 101</span>&nbsp;<span style=\"text-decoration:underline;\" >11001 001</span>&nbsp;<span style=\"text-decoration:underline;\" >101 00</span>&nbsp;<span style=\"text-decoration:underline;\" >11010 1</span>&nbsp;<span style=\"text-decoration:underline;\" >1111010 11</span>&nbsp;<span style=\"text-decoration:underline;\" >00</span> 01010</p> <p>&nbsp;</p> <p>直流哈夫曼树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;交流哈夫曼树</p> <p>&nbsp;</p> <p>详细说明一下：</p> <p>读入数据流并对照直流哈夫曼树，第一个哈夫曼编码为110，其权值为6，所以往后读入6位数据“1001101”，译码成数值为77。因为每个颜色分量单元只有一个直流分量，所以下一个就是第一个交流分量了。</p> <p>继续读入数据流并对照交流哈夫曼树，得哈夫曼编码为01，其权值为1，所以它的前面没有零，并往后读如1位数据“1”，译码成数值为1。如此往复，最后读到哈夫曼编码“00”，其权值为0，所以满足交流变量结束条件（最后剩余的“01010”对本颜色分量单元来说是冗余的，它可能属于下一个颜色分量单元）。</p> <p>实际上，这段数据译码为：</p> <p>77，（0，1），（0，5），（0，-6），（0，-3），（5，1），（2，3）</p> <p>因此，把它置于1个8*8的矩阵中应为：</p> <p>&nbsp;</p> <p><strong>4</strong><strong>．直流系数的差分编码</strong></p> <p>把所有的颜色分量单元按颜色分量（Y、Cr、Cb）分类。每一种颜色分量内，相邻的两个颜色分量单元的直流变</p> <p>量是以差分来编码的。也就是说，通过步骤3解码出来的直流变量数值只是当前颜色分量单元的实际直流变量减去</p> <p>前一个颜色分量单元的实际直流变量。也就是说，当前直流变量要通过前一个颜色分量单元的实际（非解码）直流分量来校正：</p> <p>DCn=DCn-1+Diff</p> <p>其中Diff为差分校正变量，也就是直接解码出来的直流系数。但如果当前颜色分量单元是第一个单元，则解码出来的直流数值就是真正的直流变量。</p> <p>再次提醒的是，3个颜色分量的直流变量是分开进行差分编码的。也就是说，为1张图片解码时应设置3个独立的直</p> <p>流校正变量。另一个问题是，当数据流中出现标记RSTn，则3个颜色分量的直流差分校正变量Diff都需要重新复位到0。</p> <p>&nbsp;</p> <p><strong>5</strong><strong>．反量化</strong></p> <p>不同的颜色分量使用不同的量化表，这个可以从标记段SOF中的颜色分量信息字段查得。一般是Y分量使用量化表0，而Cr、Cb两个分量共同使用量化表1。</p> <p>反量化的过程比较简单。只需要对8*8的颜色分量单元的64个值逐一乘以对应的量化表内位置相同的值则可。图像内全部的颜色分量单元都要进行反量化。</p> <p>&nbsp;</p> <p>6．<strong>反</strong><strong>Zig-zag</strong><strong>编码</strong></p> <p>如果将反量化后的每个8*8颜色分量单元的每个元素编号，如下图4，那么各反Zig-zag编码的过程就是把矩阵元素按图5重新排列。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>图 4 将颜色分量单元元素编码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图 5 反Zig-zag编码</p> <p>&nbsp;</p> <p>关于量化和反Zig-zag编码的先后顺序，笔者查阅的几份资料有不同的见解。经过实践试验，解码的过程中，是应该直</p> <p>接用文件提供的量化表反量化矩阵数据，再将其反Zig-zag编码才能正确解码。</p> <p>&nbsp;</p> <p><strong>7</strong><strong>．隔行的正负纠正</strong></p> <p>这个问题比较特别，因为在笔者认真阅读的几份资料中都没有提及此问题。而是笔者通过对已知图像进行JPEG编码压缩，</p> <p>然后和该图的JPEG文件数据对比发现的问题。具体原因不明。</p> <p>实际上，就是必须对每个颜色分量单元的奇数行（每个颜色分量单元有8行，假设把它按0、1、……、6、7编出行号）</p> <p>，即1、3、5、7行，进行取相反数操作（正的变负，负的变正）。</p> <p>&nbsp;</p> <p><strong>8</strong><strong>．反离散余弦变换</strong></p> <p>之前提到，文件中的数据是在编码时通过正向离散余弦变换（FDCT）进行时空域向频率域变换而得到的结果，所以</p> <p>现在解码就必须将其反向离散余弦变换（IDCT），就是把颜色分量单元矩阵中的频率域数值向时空域转换。并且，原</p> <p>来的频率域的矩阵大小为8*8，则经过反向离散余弦变换后，时空域的矩阵仍然是8*8。</p> <p>设正负纠正后的频率域矩阵为F[u][v]，而反向离散余弦变换后的矩阵为f[i][j]，其中0≤u,v,i,j≤7。具体使用的公式如下：</p> <p>，其中</p> <p>C（u）=&nbsp;（当u=0），C（u）=1（当u≠0）；</p> <p>C（v）=&nbsp;（当v=0），C（u）=1（当v≠0）；</p> <p>&nbsp;</p> <p>另外补充一下正向离散余弦变换的公式，用于编码：</p> <p>&nbsp;</p> <p><strong>9</strong><strong>．YCrCb</strong><strong>向RGB</strong><strong>转换</strong></p> <p>要在屏幕上显示图像，就必须以RGB模式表示图像的颜色。所以，解码时需要把YCrCb模式向RGB模式转换。</p> <p>正如前面提到，并不是每种颜色分量的采样因子都一样，所以转换时需要注意。如果采样因子是1：1：1，则每一个</p> <p>像素点的3个颜色分量都被采样，所以没有问题。但4：1：1的采样因子就不一样了。由“初步了解图像数据流的结构”</p> <p>一节中对4：1：1的采样因子的分析，可以知道一个MCU里有4个Y分量单元，而Cr分量和Cb分量各自只有1个分量单元</p> <p>。以图2为例，仅有的一个Cr分量单元（红色的64个采样点）应该平铺用于4个Y分量单元，即左上角16个值用于Y1，右</p> <p>上角16个值用于Y2，左下角16个值用于Y5，右下角16个值用于Y6。换句话说，一个Cr采样点服务于4个Y采样点。对于Cb分量，道理一样。</p> <p>另外，由于离散余弦变化要求定义域的对称，所以在编码时把RGB的数值范围从[0，255]统一减去128偏移成[-128，127]。</p> <p>因此解码时必须为每个分量加上128。具体公式如下：</p> <p>R=Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1.402*Cb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+128;</p> <p>G=Y-0.34414*Cr&nbsp;&nbsp;&nbsp;&nbsp;-0.71414*Cb&nbsp;&nbsp;&nbsp;+128;</p> <p>B=Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1.772*Cb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+128;</p> <p>还有一个问题，通过变换得出的R、G、B值可能超出了其定义域，所以要作出检查。如果大于255，则截断为255；如果小于0，则截断为0。</p> <p>&nbsp;</p> <p>下面补充RGB模式向YCrCb模式的公式：</p> <p>Y&nbsp;=0.299*R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0.587*G&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0.114*B&nbsp;&nbsp;&nbsp;&nbsp;;</p> <p>Cr=&nbsp;&nbsp;&nbsp;-0.1687*R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 0.3313*G &nbsp;&nbsp;&nbsp;&nbsp;+0.5*B&nbsp;+128;</p> <p>Cb=0.5&nbsp;*R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 0.4187*G &nbsp;&nbsp;&nbsp;&nbsp;- 0.0813*B+128;</p> <p>&nbsp;</p> <p>至此，每个MCU的解码已经完成。而每一个MCU如何组成一幅完整的图像，请参考<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/lpt19832003/archive/2007/07/28/Editor/FCKeditor/editor/fckeditor.html?InstanceName=ctl00_ContentPlaceHolder1_EntryEditor1_richTextEditor_richTextEditor&amp;Toolbar=Default#%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%BB%93%E6%9E%84\" >“初步了解图像数据流的结构”</a>分析。</p> <p><br /></p> <p>参考文献</p> <p>[1]&nbsp;李才伟，中山大学计算机系多媒体课程教学课件．</p> <p>[2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;张益贞，Visual C++实现MPEG/JPEG编解码技术．北京：人民邮电出版社</p> <p>[3] CCIT，Information Technology-digital Compression and Conding of Continuous-ton Still Images-requirements and Guidelines．<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.wotsit.org/download.asp?f=itu-1150PDF\" >http://www.wotsit.org/download.asp?f=itu-1150PDF</a>&nbsp;（访问日期：2007-1-1）</p> <p>[4]&nbsp;公子御风，JFIF文件格式即JPEG文件交换格式(JPEG File Interchonge Format)．<a target=\"_blank\" rel=\"nofollow\" href=\"http://cat1226.bokee.com/4574350.html\" >http://cat1226.bokee.com/4574350.html</a>&nbsp;（访问日期：2006-12-29）</p> <p>[5]&nbsp;云风，JPEG 简易文档 V2.11．<a target=\"_blank\" rel=\"nofollow\" href=\"http://rtornados.bokee.com/2442419.html\" >http://rtornados.bokee.com/2442419.html</a>&nbsp;（访问日期：2006-12-30）</p> <p><br /></p> <p>附录：JPEG定义的标记</p> <p>&nbsp;</p> <p>如本文有任何差错和疑问，希望网友指正和共同研讨。<br />电邮：<a target=\"_blank\" rel=\"nofollow\" href=\"mailto:cat_ng@163.com\" >cat_ng@163.com</a></p> <p>Blog:&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://hi.baidu.com/cat_ng/\" >http://hi.baidu.com/cat%5Fng/</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://hi.baidu.com/cat_ng/\" >http://blog.csdn.net/lpt19832003/archive/2007/07/28/1713718.aspx</a></p> <p><br /></p>  【编程开发】关于内存对齐与补齐 1455366927097 Text 1dad75de_9f0ae80 【编程开发】 <p>首先我们先看看下面的C语言的结构体：</p> <p><strong>[cpp]</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/cyousui/article/details/17655051#\" >view plain</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/cyousui/article/details/17655051#\" >copy</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/133240\" ><img src=\"https://code.csdn.net/assets/CODE_ico.png\" style=\"max-width:500px;\" /></a><a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/133240/fork\" ><img src=\"https://code.csdn.net/assets/ico_fork.svg\" style=\"max-width:500px;\" /></a></p> <ol> <li><p>typedef&nbsp;struct MemAlign &nbsp;</p></li> <li><p>{&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;int a;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;char b[3];&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;int c;&nbsp;&nbsp;</p></li> <li><p>}MemAlign;&nbsp;&nbsp;</p></li> </ol> <p>&nbsp;&nbsp;&nbsp;&nbsp;以上这个结构体占用内存多少空间呢？也许你会说，这个简单，计算每个类型的大小，将它们相加就行了，以32为平台为例，int类型占4字节，char占用1字节，所以：4 + 3 + 4 = 11，那么这个结构体一共占用11字节空间。好吧，那么我们就用实践来证明是否正确，我们用sizeof运算符来求出这个结构体占用内存空间大小，sizeof(MemAlign)，出乎意料的是，结果居然为12？看来我们错了？当然不是，而是这个结构体被优化了，这个优化有个另外一个名字叫“对齐”，那么这个对齐到底做了什么样的优化呢，听我慢慢解释，再解释之前我们先看一个图，图如下：</p> <p><img src=\"http://img.blog.csdn.net/20131229162304718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3lvdXN1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;相信学过汇编的朋友都很熟悉这张图，这张图就是CPU与内存如何进行数据交换的模型，其中，左边蓝色的方框是CPU，右边绿色的方框是内存，内存上面的0～3是内存地址。这里我们这张图是以32位CPU作为代表，我们都知道，32位CPU是以双字（DWORD）为单位进行数据传输的，也正因为这点，造成了另外一个问题，那么这个问题是什么呢？这个问题就是，既然32位CPU以双字进行数据传输，那么，如果我们的数据只有8位或16位数据的时候，是不是CPU就按照我们数据的位数来进行数据传输呢？其答案是否定的，如果这样会使得CPU硬件变的更复杂，所以32位CPU传输数据无论是8位或16位都是以双字进行数据传输。那么也罢，8位或16位一样可以传输，但是，事情并非像我们想象的那么简单，比如，一个int类型4字节的数据如果放在上图内存地址1开始的位置，那么这个数据占用的内存地址为1～4，那么这个数据就被分为了2个部分，一个部分在地址0～3中，另外一部分在地址4～7中，又由于32位CPU以双字进行传输，所以，CPU会分2次进行读取，一次先读取地址0～3中内容，再一次读取地址4～7中数据，最后CPU提取并组合出正确的int类型数据，舍弃掉无关数据。那么反过来，如果我们把这个int类型4字节的数据放在上图从地址0开始的位置会怎样呢？读到这里，也许你明白了，CPU只要进行一次读取就可以得到这个int类型数据了。没错，就是这样，这次CPU只用了一个周期就得到了数据，由此可见，对内存数据的摆放是多么重要啊，摆放正确位置可以减少CPU的使用资源。</p> <p>那么，内存对齐有哪些原则呢？我总结了一下大致分为三条：<br /><strong>第一条：第一个成员的首地址为0<br />第二条：每个成员的首地址是自身大小的整数倍<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二条补充：以4字节对齐为例，如果自身大小大于4字节，都以4字节整数倍为基准对齐。<br />第三条：最后以结构总体对齐。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三条补充：以4字节对齐为例，取结构体中最大成员类型倍数，如果超过4字节，都以4字节整数倍为基准对齐。（其中这一条还有个名字叫：“补齐”，补齐的目的就是多个结构变量挨着摆放的时候也满足对齐的要求。）</strong><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;上述的三原则听起来还是比较抽象，那么接下来我们通过一个例子来加深对内存对齐概念的理解，下面是一个结构体，我们动手算出下面结构体一共占用多少内存？假设我们以32位平台并且以4字节对齐方式：</p> <p><strong>[cpp]</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/cyousui/article/details/17655051#\" >view plain</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/cyousui/article/details/17655051#\" >copy</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/133240\" ><img src=\"https://code.csdn.net/assets/CODE_ico.png\" style=\"max-width:500px;\" /></a><a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/133240/fork\" ><img src=\"https://code.csdn.net/assets/ico_fork.svg\" style=\"max-width:500px;\" /></a></p> <ol> <li><p>#pragma pack(4)&nbsp;&nbsp;</p></li> <li><p>typedef&nbsp;struct MemAlign &nbsp;</p></li> <li><p>{&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;char a[18];&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;double b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;char c;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;int d;&nbsp;&nbsp;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;short e;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p></li> <li><p>}MemAlign;&nbsp;&nbsp;</p></li> </ol> 下图为对齐后结构如下： <p><img src=\"http://img.blog.csdn.net/20131229162842125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3lvdXN1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /></p> <p>我们就以这个图来讲解是如何对齐的：<br />第一个成员（char a[18]）：首先，假设我们把它放到内存开始地址为0的位置，由于第一个成员占18个字节，所以第一个成员占用内存地址范围为0～18。<br />第二个成员（double b）：由于double类型占8字节，又因为8字节大于4字节，所以就以4字节对齐为基准。由于第一个成员结束地址为18，那么地址18并不是4的整数倍，我们需要再加2个字节，也就是从地址20开始摆放第二个成员。<br />第三个成员（char c）：由于char类型占1字节，任意地址是1字节的整数倍，所以我们就直接将其摆放到紧接第二个成员之后即可。<br />第四个成员（int d）：由于int类型占4字节，但是地址29并不是4的整数倍，所以我们需要再加3个字节，也就是从地址32开始摆放这个成员。<br />第五个成员（short e）：由于short类型占2字节，地址36正好是2的整数倍，这样我们就可以直接摆放，无需填充字节,紧跟其后即可。<br />&nbsp;&nbsp;&nbsp;&nbsp;这样我们内存对齐就完成了。但是离成功还差那么一步，那是什么呢？对，是对整个结构体补齐，接下来我们就补齐整个结构体。那么，先让我们回顾一下补齐的原则：“以4字节对齐为例，取结构体中最大成员类型倍数，如果超过4字节，都以4字节整数倍为基准对齐。”在这个结构体中最大类型为double类型（占8字节），又由于8字节大于4字&nbsp;节，所以我们还是以4字节补齐为基准，整个结构体结束地址为38，而地址38并不是4的整数倍，所以我们还需要加额外2个字节来填充结构体，如下图红色的就是补齐出来的空间：</p> <p><img src=\"http://img.blog.csdn.net/20131229163039406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3lvdXN1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /></p> <p>到此为止，我们内存对齐与补齐就完毕了！接下来我们用实验来证明真理，程序如下：<br /></p> <p><strong>[cpp]</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/cyousui/article/details/17655051#\" >view plain</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/cyousui/article/details/17655051#\" >copy</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/133240\" ><img src=\"https://code.csdn.net/assets/CODE_ico.png\" style=\"max-width:500px;\" /></a><a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/133240/fork\" ><img src=\"https://code.csdn.net/assets/ico_fork.svg\" style=\"max-width:500px;\" /></a></p> <ol> <li><p>#include &lt;stdio.h&gt;&nbsp;&nbsp;</p></li> <li><p>#include&nbsp;&lt;memory.h&gt;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;</p></li> <li><p>//&nbsp;由于VS2010默认是8字节对齐，我们&nbsp;&nbsp;</p></li> <li><p>//&nbsp;通过预编译来通知编译器我们以4字节对齐&nbsp;&nbsp;</p></li> <li><p>#pragma pack(4)&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;</p></li> <li><p>//&nbsp;用于测试的结构体&nbsp;&nbsp;</p></li> <li><p>typedef&nbsp;struct MemAlign &nbsp;</p></li> <li><p>{&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;char a[18];&nbsp;// 18 bytes&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;double b;&nbsp;&nbsp;&nbsp;// 08 bytes &nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;char c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 01 bytes&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;int d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 04 bytes&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;short e;&nbsp;&nbsp;&nbsp;&nbsp;// 02 bytes&nbsp;&nbsp;</p></li> <li><p>}MemAlign;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;</p></li> <li><p>int main()&nbsp;&nbsp;</p></li> <li><p>{&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;定义一个结构体变量&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; MemAlign m;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;定义个以指向结构体指针&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; MemAlign *p&nbsp;=&nbsp;&amp;m;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;依次对各个成员进行填充，这样我们可以&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;动态观察内存变化情况&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; memset(&nbsp;&amp;m.a, 0x11,&nbsp;sizeof(m.a)&nbsp;);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; memset(&nbsp;&amp;m.b, 0x22,&nbsp;sizeof(m.b)&nbsp;);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; memset(&nbsp;&amp;m.c, 0x33,&nbsp;sizeof(m.c)&nbsp;);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; memset(&nbsp;&amp;m.d, 0x44,&nbsp;sizeof(m.d)&nbsp;);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; memset(&nbsp;&amp;m.e, 0x55,&nbsp;sizeof(m.e)&nbsp;);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;由于有补齐原因，所以我们需要对整个&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;结构体进行填充，补齐对齐剩下的字节&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;以便我们可以观察到变化&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; memset(&nbsp;&amp;m, 0x66,&nbsp;sizeof(m)&nbsp;);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;输出结构体大小&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; printf(&nbsp;&quot;sizeof(MemAlign)&nbsp;=&nbsp;%d&quot;,&nbsp;sizeof(m)&nbsp;);&nbsp;&nbsp;</p></li> <li><p>}&nbsp;&nbsp;</p></li> </ol> <p>程序运行过程中，查看内存如下：<br /><img src=\"http://img.blog.csdn.net/20131229163153765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3lvdXN1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /><br />其中，各种颜色带下划线的代表各个成员变量，蓝色方框的代表为内存对齐时候填补的多余字节，由于这里看不到补齐效果，我们接下来看下图，下图篮框包围的字节就是与上图的交集以外的部分就是补齐所填充的字节。</p> <p><img src=\"http://img.blog.csdn.net/20131229163234187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3lvdXN1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /></p> <p>在最后，我在谈一谈关于补齐的作用，补齐其实就是为了让这个结构体定义的数组变量时候，数组内部，也同样满足内存对齐的要求，为了更好的理解这点，我做了一个跟本例子相对照的图：</p> <p><img src=\"http://img.blog.csdn.net/20131229163325875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3lvdXN1aQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /><br /></p> <p><br /></p> <p><br /></p>  【DSP开发】字节对齐 1455365734235 Text 1dad75de_9f0ae40 【DSP开发】 <p>1.&nbsp;什么是对齐？</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;现代计算机中内存空间都是按照字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序地一个接一个地排放，这就是对齐。</p> <p>2.计算机为什么要对齐？</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取，其他平台可能没有这种情况。但是最常见的是，如果不按照适合其平台的要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，一个int型（假设为 32位）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该int数据，显然在读取效率上下降很多。这也是空间和时间的博弈。在网络程序中，掌握这个概念可是很重要的：如果在不同平台之间(比如在Windows 和Linux之间)传递2进制流(比如结构体)，那么在这两个平台间必须要定义相同的对齐方式，不然莫名其妙地出了一些错，可是很难排查的。</p> <p>3.对齐的实现：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;通常，我们写程序的时候，不需要考虑对齐问题，编译器会替我们选择适合目标平台的对齐策略。当然，我们也可以通知给编译器传递预编译指令而改变对指定数据的对齐方法，比如写入预编译指令#pragma pack(2)，即告诉编译器按两字节对齐。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;但是，正因为我们一般不需要关心这个问题，所以，如果编辑器对数据存放做了对齐，而我们不了解的话，常常会对一些问题感到迷惑。最常见的就是struct数据结构的sizeof结果，比如以下程序：</p> <blockquote> <p>#include&lt;stdio.h&gt;</p> <p>int main(void)</p> <p>{</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct A</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short b;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;结构体类型A在内存中所占内存为：%d字节。\\n&quot;,sizeof(struct A));</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</p> <p>}</p> </blockquote> <p>&nbsp;&nbsp;&nbsp;&nbsp;输出结果为：8字节。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;如果我们将结构体中的变量声明位置稍加改动（并不改变变量本身），请再看以下程序：</p> <blockquote> <p>#include&lt;stdio.h&gt;</p> <p>int main(void)</p> <p>{</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct A</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short b;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;结构体类型A在内存中所占内存为：%d字节。\\n&quot;,sizeof(struct A));</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</p> <p>}</p> </blockquote> <p>&nbsp;&nbsp;&nbsp;&nbsp;输出结果为：12字节。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;问题出来了，他们都是同一个结构体，为什么占用的内存大小不同呢？为此，我们需要对对齐算法有所了解。</p> <p>4.对齐算法：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;由于各个平台和编译器的不同，现以32位，vc++6.0系统为例，来讨论编译器对struct数据结构中的各成员如何进行对齐的。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;首先，我们给出四个概念：</p> <p>1）数据类型自身的对齐值：就是基本数据类型的自身对齐值，比如char类型的自身对齐值为1字节，int类型的自身对齐值为4字节。</p> <p>2）指定对齐值：预编译命令#pragma pack （value）指定的对齐值value。</p> <p>3）结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值，比如以上的struct A的对齐值为4。</p> <p>4）数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小的那个值。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;设结构体如下定义：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct A</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short b;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p> <p>&nbsp;&nbsp;&nbsp; a是char型数据，占用1字节内存；short型数据，占用2字节内存；int型数据，占用4字节内存。因此，结构体A的自身对齐值为4。于是，a和b要组成4个字节，以便与c的4个字节对齐。而a只有1个字节，a与b之间便空了一个字节。我们知道，结构体类型数据是按顺序存储结构一个接一个向后排列的，于是其存储方式为：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=715de2f50100pgs3&amp;url=http://s14.sinaimg.cn/orignal/715de2f5t9c623a3f8d6d\" ><img src=\"http://s14.sinaimg.cn/middle/715de2f5t9c623a3f8d6d&amp;690\" style=\"max-width:500px;\" /></a></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;其中空白方格无数据，是浪费的内存空间，共占用8字节内存。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;实际上，为了更加明显地表示“对齐”，我们可以将以上结构想象为以下的行排列：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=715de2f50100pgs3&amp;url=http://s7.sinaimg.cn/orignal/715de2f5t9c623fd520c6\" ><img src=\"http://s7.sinaimg.cn/middle/715de2f5t9c623fd520c6&amp;690\" style=\"max-width:500px;\" /></a></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;对于另一个结构体定义：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct A</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short b;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;其内存存储方式为：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=715de2f50100pgs3&amp;url=http://s2.sinaimg.cn/orignal/715de2f5t9c6242e16541\" ><img src=\"http://s2.sinaimg.cn/middle/715de2f5t9c6242e16541&amp;690\" style=\"max-width:500px;\" /></a></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;同样把它想象成行排列：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=715de2f50100pgs3&amp;url=http://s14.sinaimg.cn/orignal/715de2f5t9c62475dfa6d\" ><img src=\"http://s14.sinaimg.cn/middle/715de2f5t9c62475dfa6d&amp;690\" style=\"max-width:500px;\" /></a></p> <p><br /><br /></p> <p>&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;可见，浪费的空间更多。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;其实，除了结构体之外，整个程序在给每个变量进行内存分配时都会遵循对齐机制，也都会产生内存空间的浪费。但我们要知道，这种浪费是值得的，因为它换来的是效率的提高。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;以上分析都是建立在程序默认的对齐值基础之上的，我们可以通过添加预定义命令#pragma pack(value)来对对齐值进行自定义，比如#pragma pack(1)，对齐值变为1，此时内存紧凑，不会出现内存浪费，但效率降低了。效率之所以降低，是因为：如果存在更大字节数的变量时（比1大），比如int类型，需要进行多次读周期才能将一个int数据拼凑起来。</p> <p><br /></p>  【DSP开发】数据打包处理技术 1455349111027 Text 1dad75de_9f012dd 【DSP开发】 <p>转载自<a target=\"_blank\" href=\"http://dsalli0927.blog.163.com/blog/static/888076072008715535584/\" >http://dsalli0927.blog.163.com/blog/static/888076072008715535584/</a></p> <p>C6000访问存储器是很费时的，要提高C6000的数据处理率，应该使1个Load/Store指令能够访问多个数据。当程序需要对一连传的短型数据进行操作时，可使用字（整型）一次访问2个短型数据；然后用C6000的相应指令，如同时进行2个16位的加法指令，用_add2()对这些数据进行运算，以减少对内存的访问。类似的，对于C64,如需要对一连串整形数据进行操作时，可以使用双字长访问存储器。这种类型的优化就叫做：数据打包技术。</p> <p>如用字访问代替2个16位短型数据的访问</p> <p>void vecsum4(short *restrict sum, restrict short *in1, restrict short *in2,unsigned N)</p> <p>{</p> <p>&nbsp;&nbsp; int i;</p> <p>&nbsp;&nbsp;&nbsp;#pragma MUST_ITERATE(10);</p> <p>&nbsp;&nbsp; for(i=0;i&lt;N;i++)</p> <p>&nbsp;&nbsp; _amem4(&amp;sum[i])=add2(_amem4_const(&amp;in1[i]）,_amem4_const(&amp;in2[i]));</p> <p>}</p> <p>说明：</p> <p>&nbsp;#pragma MUST_ITERATE(10)说明下面的循环至少要执行10次。这个信息对软件流水至关重要。</p> <p>_amem4.这类intrinsics指定了每次存储器访问的字节数，并说明存储器起始地址是否必须符合边界调整。amem4(&amp;sum[i])告诉编译器：这是一个起始地址在sum、字边界调整的4字节访问。_amem4_const(&amp;in1[i]）增加了const关键字，它表示in1[i]是常数数组，在本程序中数值不变。</p> <p>上例子是假设执行偶数次循环，如果用于奇数次循环，可以采取一些技巧！</p> <p>例如：把数组的长度人为增加，使它仍执行偶数次。如果要求程序满足不同次数循环的要求，或者要求满足数组起始地址可能是短型数据边界等多种情况，较好的办法是在程序内部检测一下传递过来的数据情况，根据不同的数据情况采取不同的程序段：</p> <p>例子：通用的求矢量和的程序</p> <p>void vecsum5(short *restrict sum, const short *restrict in1,short *restrict in2,unsigned int N)</p> <p>{</p> <p>&nbsp; int i;</p> <p>/* test to see if sum ,in2 and in1 are aligned to a word boundary*/</p> <p>if(((int)sum|&nbsp;(int)in2 |(int) in1)&nbsp;&amp;0x02)</p> <p>{</p> <p>&nbsp;#pragma MUST_ITERATE(20);</p> <p> for(i=0;i&lt;N;i++)</p> <p> sum[i]=in1[i]+in2[i];</p> <p>&nbsp;}</p> <p>else</p> <p>{</p> <p>&nbsp;#pragma MUST_ITERATE(10);</p> <p>for(i=0;i&lt;N;i++)</p> <p> _amem4(&amp;sum[i])=add2(_amem4_const(&amp;in1[i]）,_amem4_const(&amp;in2[i]));</p> <p> if(N&amp;0x01)sum[i]=in1[i]+in2[i];</p> <p>}</p> <p>}</p> <p>/////////////////////////////////////////////////////////////////////////</p> <p>The following example shows an example that can benefit from the packed compare and expand intrinsics in action. The Clear Below Threshold kernel scans an image of 8-bit unsigned pixels, and sets all pixels that are below a certain threshold to 0.<br />Clear Below Threshold Kernel<br /><br />void clear_below_thresh(unsigned char *restrict image, int count, unsigned char threshold)</p> <p>&nbsp;{</p> <p>&nbsp;&nbsp;&nbsp; int i;</p> <p>&nbsp;&nbsp;&nbsp; for (i&nbsp;= 0; i &lt; count; i++)</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;{</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (image[i]&nbsp;&lt;= threshold) image[i]&nbsp;= 0;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;}</p> <p>&nbsp;}&nbsp;<br />Vectorization techniques are applied to the code (as described Packed-Data Processing on the C64x), giving the result shown in the following example. The _cmpgtu4() intrinsic compares against the threshold values, and the _xpnd4() intrinsic generates a mask for setting pixels to 0. Note that the new code has the restriction that the input image must be double-word aligned, and must contain a multiple of 8 pixels. These restrictions are reasonable as common image sizes have a multiple of 8 pixels.<br /><br />Clear Below Threshold Kernel, Using _cmpgtu4 and _xpnd4 Intrinsics<br /><br />void clear_below_thresh(unsigned char *restrict image, int count, unsigned char threshold)</p> <p>{</p> <p> int i;</p> <p> unsigned t3_t2_t1_t0;&nbsp;/* Threshold (replicated)&nbsp;*/</p> <p> unsigned p7_p6_p5_p4, p3_p2_p1_p0;&nbsp;/* Pixels */</p> <p> unsigned c7_c6_c5_c4, c3_c2_c1_c0;&nbsp;/* Comparison results */</p> <p> unsigned x7_x6_x5_x4, x3_x2_x1_x0;&nbsp;/* Expanded masks */</p> <p>&nbsp;/* Replicate the threshold value four times in a single word */ unsigned temp = _pack2(threshold, threshold);</p> <p>t3_t2_t1_t0 = _packl4(temp, temp);</p> <p>for (i&nbsp;= 0; i &lt; count; i += 8)</p> <p>{</p> <p>/* Load 8 pixels from input image (one double-word).&nbsp;*/</p> <p>p7_p6_p5_p4 = _hi(_amemd8(&amp;image[i]));</p> <p> p3_p2_p1_p0 = _lo(_amemd8(&amp;image[i]));</p> <p>/* Compare each of the pixels to the threshold.&nbsp;*/</p> <p>c7_c6_c5_c4 = _cmpgtu4(p7_p6_p5_p4, t3_t2_t1_t0);</p> <p>c3_c2_c1_c0 = _cmpgtu4(p3_p2_p1_p0, t3_t2_t1_t0);</p> <p>/* Expand the comparison results to generate a bitmask.&nbsp;*/</p> <p> x7_x6_x5_x4 = _xpnd4(c7_c6_c5_c4);</p> <p>x3_x2_x1_x0 = _xpnd4(c3_c2_c1_c0);</p> <p>/* Apply mask to the pixels. Pixels that were less than or */</p> <p>/* equal to the threshold will be forced to 0 because the */</p> <p>/* corresponding mask bits will be all 0s. The pixels that */</p> <p>/* were greater will not be modified, because their mask */</p> <p>/* bits will be all 1s.&nbsp;*/</p> <p> p7_p6_p5_p4 = p7_p6_p5_p4 &amp; x7_x6_x5_x4; p3_p2_p1_p0 = p3_p2_p1_p0 &amp; x3_x2_x1_x0;</p> <p>/* Store the thresholded pixels back to the image.&nbsp;*/</p> <p>_amemd8(&amp;image[i])&nbsp;= _itod(p7_p6_p5_p4, p3_p2_p1_p0);</p> <p>&nbsp;}</p> <p>&nbsp;}</p> <p><br /></p>  【DSP开发】帮您快速入门 TI 的 Codec Engine 1455348963579 1455348984970 Text 1dad75de_9f012cf 【DSP开发】 <p>目录<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/jhh_move_on/article/details/19635999#\" >(?)</a><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/jhh_move_on/article/details/19635999#\" >[-]</a></p> <ol> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/jhh_move_on/article/details/19635999#t0\" >帮您快速入门 TI 的 Codec Engine</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/jhh_move_on/article/details/19635999#t1\" >1Codec Engine概述</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/jhh_move_on/article/details/19635999#t2\" >2Codec Engine入门第一步从Codec Engine发布说明文档release notes开始</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/jhh_move_on/article/details/19635999#t3\" >3Codec Engine入门第二步了解Codec Engine的运行环境及依赖的软件模块和工具</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/jhh_move_on/article/details/19635999#t4\" >4Codec Engine入门第三步根据自己的角色参考相关的文档和例子进行开发</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/jhh_move_on/article/details/19635999#t5\" >5使用中常碰到的问题</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/jhh_move_on/article/details/19635999#t6\" >6结语</a></p></li> </ol> <p><strong>转载自：</strong></p> <p><strong>http://www.ti.com.cn/general/cn/docs/gencontent.tsp?contentId=61575</strong></p> <p>帮您快速入门 TI 的 Codec Engine<br /></p> <p><br /></p>  【DSP开发】 TMS320C64x+ DSP-----Cache 优化 1455348904168 Text 1dad75de_9f012ca 【DSP开发】 <p>一、cache性能特点</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优异的cache性能很大程度上依赖于cache lines的重复使用，优化的最主要目标也在于此，一般通过恰当的数据和代码内存布置，以及调整CPU的内存访问顺序来达到此目的。由此，应该熟悉cache内存架构，特别是cache内存特点，比如line size, associativity, capacity, replacement scheme,read/write allocation, miss pipelining和write buffer.另外，还需要知道什么条件下CPU STALLS会发生以及产生延时的cycle数。只有清楚了这些，才能清楚如何优化cache。</p> <p>二、优化cache</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1 cache的特点（容量、associativity、linesize）相对于L2 cache来说更具局限性，优化了L1 cache几乎肯定意味着L2 cache也能得到有效使用。通常，仅优化L2 cache效果并不理想。建议将L2 cache用于一般的类似控制流程等大量内存访问无法预测的部分。L1和L2 SRAM应该用于时间性非常重要的信号处理算法。数据能够用EDMA或IDMA直接导入L1 SRAM，或用EDMA导入L2 SRAM。这样，可使L1 cache的mem访问效率获得优化。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;有两种重要方法来减少cache ovehead：<br />1.&nbsp;通过以下方式减少cache miss数量(L1P,L1D,L2 cache):<br />&nbsp;&nbsp;&nbsp; a. cache line reuse最大化<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;访问cached行中的所有mem位置(应该是对多路组相联才有效,直接映射地址是一对一的)。进入cache行中的数据花费了昂贵的stall cycles，应该被使用；<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;cached line中的同一内存位置应该尽可能的重复使用。<br />&nbsp;&nbsp;&nbsp; b.&nbsp;只要一行被使用，将要避免牺牲该行<br />2.&nbsp;利用miss pipelining，减少每次miss的stall cycles数</p> <p>&nbsp;&nbsp;&nbsp; cache优化的最好策略是从上到下的方式，从应用层开始，到程序级，再到算法级别的优化。应用层的优化方法通常易于实现，且对整体效果改善明显，然后再配合一些低层次的优化策略。这也是通常的优化顺序。</p> <p><strong>应用层级应考虑的几点：<br /></strong>&gt;用DMA搬进/出数据，DMA buffer最好分配在L1或L2 SRAM，出于以下考虑。首先，L1/L2 SRAM更靠近CPU，可以尽量减少延迟；其次，出于cache一致性的考虑。<br />&gt;L1 SRAM的使用。C64x+提供L1D 和L1P SRAM，用于存放对cache性能影像大的代码和数据，比如：<br />&nbsp;&nbsp;&nbsp;&nbsp;@&nbsp;至关重要的代码或数据；<br />&nbsp;&nbsp;&nbsp;&nbsp;@&nbsp;许多算法共享的代码或数据；<br />&nbsp;&nbsp;&nbsp;&nbsp;@&nbsp;访问频繁的代码或数据；<br />&nbsp;&nbsp;&nbsp;&nbsp;@&nbsp;代码量大的函数或大的数据结构；<br />&nbsp;&nbsp;&nbsp;&nbsp;@&nbsp;访问无规律，严重影像cache效率的数据结构；<br />&nbsp;&nbsp;&nbsp;&nbsp;@&nbsp;流buffer(例如L2比较小，最好配置成cache)<br />&nbsp;&nbsp;&nbsp;&nbsp;因为L1 SRAM有限，决定哪些代码和数据放入L1 SRAM需要仔细考虑。L1 SRAM 分配大，相应L1 cache就会小，这就会削弱放在L2和外部内存中代码和数据的效率。&nbsp;如果代码和数据能按要求导入L1 SRAM,利用代码和/或数据的重叠，可以将L1 SRAM设小点。IDMA能够非常快的将代码或数据page到L1。如果代码/数据是从外部page进来，则要用EDMA。但是，非常频繁的paging可能会比cache增加更多的overhead。所以，必须在SRAM和cache大小之间寻求一个折中点。<br />&gt;区别signal processing 和 general-purpose processing 代码<br />&nbsp;&nbsp;&nbsp;&nbsp;后者通常并行性不好，执行过程依赖于许多条件，结果大多无法预测，比如滤波模块，数据内存访问大多随机，程序内存访问因分支条件而异，使得优化相当困难。鉴于此，当L2不足以放下整个代码和数据时，建议将其代码和数据放到片外，并允许L2 能cache访问到。这样腾出更多的L2 SRAM空间存放易于优化，结构清晰的前者代码。由于后者代码的无法预测性，L2 cache应该是设的越大越好(32k~256k).&nbsp;前者比较有规律的代码和数据放到L2 SRAM或L1 SRAM更为有利。放到L2，可以允许你根据CPU对数据的访问方式来修改算法，或调整数据结构，以获得更好的cache友好性。放到L1 SRAM，无需任何cache操作，并且除非bank冲突，无需做memory 优化。</p> <p><strong>procedural级的优化：<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;优化目的是减少cache miss，以及miss带来的stall数。前者可通过减少被cache的内存大小并重复使用已经cached lines来获得。尽量避免牺牲行并尽可能写已经分配的行可以提高重用率。利用miss pipelining可以减少stall数。以下根据三种不同类型的读miss来分析优化的方法。<br />&gt;选用合适的数据类型，以减少内存需要<br />&nbsp;&nbsp;&nbsp; 16位可以表示的数不要定义成32位，这不但可以省一半内存消耗，而且减少compulsory miss。这种优化容易修改，无需改动算法，而且小数据类型容易实现汇编的SIMD。在不同系统平台端口间的数据流动，容易出现这种低效的数据类型。<br />&gt;处理链<br />&nbsp;&nbsp;&nbsp;&nbsp;前一算法的输出是后一算法的输入。如果输出、输入不是同一级内存地址，后一算法使用前一算法结果时就存在读miss的消耗。这个时候就要考虑两者空间如何布置。如果超过两个数组映射到L1D的同一个set，则会产生conflict miss(L1D cache是2-way set-associative)，故应该将这些数组连续分配(why???)(详见P55)<br />&gt;避免<strong>L1P conflict miss<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;即使cpu需要的指令全在L1P cache(假定无capacity miss),仍然可能会产生conflict miss。以下解释conflict miss是如何产生的，又如何通过code在内存中的连续存放来消除miss。例如：<br />&nbsp;&nbsp;&nbsp; for(i=0; i&lt;N; i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; function_1();&nbsp;&nbsp; function_2();&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;如果func2在L2中的位置正好与func1有部分处于同一set中，而L2 cache是4-way set-associativity,处于同一set的指令在被L1P cache循环读取后，可能会出现conflict miss(如刚读入func1，然后读入func2,可能会驱逐掉func1在L1P中的部分cache lines).这种类型的miss是完全可以消除掉的，通过将这两个函数的代码分配到不冲突的set中，最直接具体的方法是将这两个函数在内存中连续存放，存放的方法有二：<br />1.&nbsp;使用编译器选项&nbsp;-mo，将各C和线性汇编函数放到各自独立的section,其中汇编函数必须被放到以.sect标示的sections中。然后检查map file，获取各函数的段名，比如上例.text:_function1和.text:function_2。则linker命令文件如下：<br />&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; SECTIONS<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;.cinit &nbsp;&nbsp;&gt; L2SRAM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.GROUP &nbsp;&nbsp;&gt; L2SRAM &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(在CCS3.0及以后，.GROUP标示用于强制指定段的link顺序)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;.text:_function1 .text:function_2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.text<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.stack &nbsp;&nbsp;&gt; L2SRAM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.bss &nbsp;&nbsp;&nbsp;&nbsp;&gt; L2SRAM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp; linker会严格按照GROUP申明的顺序来link各段。上例中，先func1,然后是func2,然后是.text section中的其它函数。但要注意，使用-mo后会导致整个code尺寸变大，因为包含code的任何段都要按32-byte边界对齐。<br />2.&nbsp;为避免-mo只能指定section，而不能单独指定函数的不足，如果仅需要函数连续排放，我们可以在定义函数前，通过#pragma CODE_SECTION来为函数指定sections：<br />&nbsp;&nbsp;&nbsp;&nbsp;#pragma CODE_SECTION(function_1,&quot;.funct1&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;#pragma CODE_SECTION(function_2,&quot;.funct2&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp; void function_1(){...}<br />&nbsp;&nbsp;&nbsp;&nbsp; void function_2(){...}<br />&nbsp;&nbsp;&nbsp;&nbsp;这样，linker命令文件如下：<br />&nbsp;&nbsp;&nbsp;&nbsp;...<br />&nbsp;&nbsp;&nbsp; SECTIONS<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.cinit &gt; L2SRAM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.GROUP &gt; L2SRAM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.funct1.funct2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.text<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.stack &gt; L2SRAM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;结合上例可见，在同一循环里面或在某些特定时间帧里面反复调用的多个函数，需要考虑重排。如果L1P cache不够大，不足以放下所有循环内函数，则循环必须被拆开来，以保证code无驱逐的重用。但这会增大内存消耗，上函数拆分成如下：<br />&nbsp;&nbsp;&nbsp; for (i=0; i&lt;N; i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp; function_1(in[i], tmp[i]);&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//++很显然需要增大tmp[],以保存func1每<br />&nbsp;&nbsp;&nbsp; for (i=0; i&lt;N; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//++次循环的输出结果，作为func2的输入<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp; function_2(tmp[i], out[i]);&nbsp;}</p> <p>&gt;freezing L1P cache<br />&nbsp;&nbsp;&nbsp;&nbsp;调用CSL函数: CACHE_freezeL1p()与CACHE_unfreezeL1p()可以控制L1P cache，阻止其分配新行，freezing后，cache内容就不会因conflict而牺牲，但其他所有如dirty比特、LRU更新、snooping等等cache行为仍然是一样的。肯定会被重用的code，如果因为其他仅执行一次的code而被驱逐掉，比如中断程序等，可以采用这个函数来避免。</p> <p>&gt;避免L1D conflict miss<br />&nbsp;&nbsp;&nbsp; L1P是直接映射型cache，如果cpu访问的地址没有包含在同一cache line内，则会相互evict。然而，L1D是2-way set-associative，对直接映射来说是conflict 的两lines却能够同时保存在cache中，只有当第三个被访问分配的memory地址仍映射到同一set时，早前分配的两个cache lines将根据LRU规则牺牲掉一行。L1D的优化方法与上面L1P类似，区别在于前者是2-way set-associative，而后者是direct-mapped,这意味着对L1D，两个数组能够映射到同一set,并同时保存在L1D。<br />&nbsp;&nbsp;&nbsp;&nbsp;<strong>@定义数组后，通过编译选项-m生成map file可以查看给该数组分配的地址。</strong><br />&nbsp;&nbsp;&nbsp;&nbsp;与L1P类似，如果不连续定义数组，会导致各种miss(具体各数组是如何映射到L1D cache各way各set的，没看明白，P61)，为避免读miss,应在内存中连续分配各数组。注意，因为linker的内存分配规则，在程序中连续定义数组，并不表示他们在内存中的地址也是连续的(比如，const数组会放在.const section而非.data section中)!因此，必须将数组指定到用户定义的段:<br />&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(in1,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(in2,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(w1,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(w2,&nbsp;&quot;.mydata')<br />&nbsp;&nbsp;&nbsp;&nbsp;<strong>#pragma DATA_ALIGN(in1, 32)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//++&nbsp;数组按照cache line边界对齐<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp; short in1 [N];<br />&nbsp;&nbsp;&nbsp;&nbsp; short in2 [N];<br />&nbsp;&nbsp;&nbsp;&nbsp; short w1 [N];<br />&nbsp;&nbsp;&nbsp;&nbsp; short w2 [N];</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>@另注意:为避免memory bank冲突，非常有必要将数组按不同memory bank对齐</strong>，如：<br />&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_MEM_BANK(in1, 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_MEM_BANK(in2, 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_MEM_BANK(w1, 2)<br />&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_MEM_BANK(w2, 2)<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;@<strong>利用miss pipelining可以进一步减少miss stalls</strong>。利用touch loop来为四个数组在L1D cache中预分配空间，因为数组物理连续，故只需调用一次touch程序:<br />&nbsp;&nbsp;&nbsp; touch(in1, 4*N*sizeof(short));<br />&nbsp;&nbsp;&nbsp; r1 = dotprod(in1, w1, N);<br />&nbsp;&nbsp;&nbsp; r2 = dotprod(in2, w2, N);<br />&nbsp;&nbsp;&nbsp; r3 = dotprod(in1, w2, N);<br />&nbsp;&nbsp;&nbsp; r4 = dotprod(in2, w1, N);<br />&nbsp;&nbsp;&nbsp;&nbsp;====&gt;<strong>touch loop的意义和实现</strong>：意义是为了最大限度实现miss piplining。如果连续访问mem，因为一次miss，会搬移一个cacheline，则随后的访问就会hit，miss不能实现overlap。因此，为获得stalls的完全重叠，可以考虑在一个cycle内同时访问两个新的cacheline，即按两个cachelines的间距遍历mem。TI提供的汇编函数“touch”，用于在L1D cache中预先分配长为length的数组buffer，它对每两个连续cache lines 分别并行load一个byte。为避免bank conflict，这两个并行load之间偏移一个word。&nbsp;(c64x采用基于LSB的mem bank结构，L1D分成8个bank,每个bank宽32-bit,共2K，这些bank均为single port输入，每个cycle允许一个访问，与c621x/c671x的单bank多输入口有区别。这样，对同一bank同时进行读和写访问，总是会造成stall，而同时对同一bank进行读或写，只要满足一定条件，就不会产生stall)。</p> <p>&gt;避免L1D thrashing <strong>---具体图示详见two-level--&gt;3-38<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;这种Miss情况下，数据集比cache大，连续分配，但数据不需要reused,发生conflict miss，但无capacity miss发生(因为数据不reused)。&nbsp;对同一set发生两个以上的读miss，这样在该行全部数据被访问前就将该行驱逐掉了，这种情况就是thrashing.假定所有数据在mem中是连续分配的，这样只有当被访问的所有数据集超过L1D cache容量时才会发生thrashing.这种conflict miss是可以完全避免的，通过在mem中连续分配数据集，并嵌入一些多余数组，强制将数据交叉映射到cache sets。比如：<br />&nbsp;&nbsp;&nbsp; int w_dotprod(const short *restrict w, const short *restrict x, const short *restrict h, int N)<br />&nbsp;&nbsp;&nbsp;&nbsp;{ int i, sum = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nassert((int)w % 8 == 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//++如果w[],x[],h[]三个数组在内存中都映射到<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nassert((int)x % 8 == 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//++同一L1D cache set，则L1D thrashing发生。当前读入<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nassert((int)h % 8 == 0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//++的w,x被随后读入的h给替换掉了....<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma MUST_ITERATE(16,,4)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;N; i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum += w[i]&nbsp;* x[i]&nbsp;* h[i];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sum;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;处理办法是在w,x后填充一个cache行大小的数，使h[0]往下偏移一行，映射到下一set：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(w,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(x,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(pad,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(h,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_ALIGN (w, CACHE_L1D_LINESIZE)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short w [N];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x [N];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char pad [CACHE_L1D_LINESIZE];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short h [N];<br />&nbsp;&nbsp;&nbsp;&nbsp;对应linker命令文件如下指定：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SECTIONS<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ GROUP &gt; L2SRAM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;.mydata:w<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.mydata:x<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.mydata:pad<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.mydata:h &nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对应于我们的应用，L1D如果设cache为32k，放在DDR中的重建或插值帧数据应该考虑到以上问题，一帧的重建数据远大于32k，这时必然需要考虑被处理数据在DDR中怎么排放才能避免cache中Line evict。为了能够明确数据在cache的set映射，应该将DDR划分成16k的CE小段，然后数据按小段布置，这样容易做到主观对应也便于操作数据(这估计也是示例中linker划分很多CE external段的原因)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原来的理解是错误的，首先LRU策略理解有误，它只针对行，而非全部cache空间；在编译连接重定位后，不管是数据还是指令，都有了确定的地址和大小，以及在memory中的位置，这样它们到cache的映射set也已经确定下来了，故理论上通过地址排放，我们应该能确定的了解到数据和代码在cache中的具体运行情况，知道了这些，就可以针对性的采取措施以尽量避免miss和stall了。</strong></p> <p>&gt;避免capacity miss<strong>---具体图示见two-level--&gt;3-41</strong><br />&nbsp;&nbsp;&nbsp;&nbsp;这种情况下，数据需要重用reused,但是数据集比cache大，造成capacity和conflict miss。通过分裂数据集，一次处理一个数据子集，可以避免这种miss，这种方法叫做blocking或tiling.&nbsp;下面以例子说明原因和处理方法。点积函数，调用4次，一个参考矢量，四个不同的输入矢量。<br />&nbsp;&nbsp;&nbsp; short in1[N];<br />&nbsp;&nbsp;&nbsp; short in2[N];<br />&nbsp;&nbsp;&nbsp; short in3[N];<br />&nbsp;&nbsp;&nbsp; short in4[N];<br />&nbsp;&nbsp;&nbsp; short w [N];<br />&nbsp;&nbsp;&nbsp; r1 = dotprod(in1, w, N);<br />&nbsp;&nbsp;&nbsp; r2 = dotprod(in2, w, N);<br />&nbsp;&nbsp;&nbsp; r3 = dotprod(in3, w, N);<br />&nbsp;&nbsp;&nbsp; r4 = dotprod(in4, w, N);<br />&nbsp;&nbsp;&nbsp;&nbsp;假定每个数组都是L1D cache容量的两倍，对w来说，除了第一次调用需要compulsory miss外，之后应该保存在cache里面重用是最合理的，但分析可知，当处理到N/4的输入数据时，最先进入cache的w就开始被驱逐了，这样w将会被反复多次读入cache，非常浪费。可以考虑加个循环，每次只处理N/4的数据，保证w在读进cache后，直到用完才驱逐，修改如下：<br />&nbsp;&nbsp;&nbsp; for (i=0; i&lt;4; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = i * N/4;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dotprod(in1+o, w+o, N/4);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dotprod(in2+o, w+o, N/4);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dotprod(in3+o, w+o, N/4);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dotprod(in4+o, w+o, N/4);&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以利用miss pipelining进一步减少read miss stalls.在每次循环开始用touch循环预先在cache分配w[],这样在每次调用点积函数前，需要的输入数组都准备好了：<br />&nbsp;&nbsp;&nbsp; for (i=0; i&lt;4; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = i * N/4;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; touch(w+o, N/4 * sizeof(short));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; touch(in1+o, N/4 * sizeof(short));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dotprod(in1+o, w+o, N/4);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; touch(w+o, N/4 * sizeof(short));&nbsp;&nbsp;&nbsp;//++每次touch in[]前都要touch w[]是为了保证w[]为MRU,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; touch(in2+o, N/4 * sizeof(short));&nbsp;//++以防访问顺序发生改变导致w[]被驱逐掉。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dotprod(in2+o, w+o, N/4);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; touch(w+o, N/4 * sizeof(short));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; touch(in3+o, N/4 * sizeof(short));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dotprod(in3+o, w+o, N/4);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; touch(w+o, N/4 * sizeof(short));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; touch(in4+o, N/4 * sizeof(short));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dotprod(in4+o, w+o, N/4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;另外，本例中为避免bank conflict,数组w[]和in[]应该对齐到不同的memory banks:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(in1,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(in2,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(in3,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(in4,&nbsp;&quot;.mydata&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_SECTION(w ,&nbsp;&quot;.mydata&quot;)</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_ALIGN(w, CACHE_L1D_LINESIZE)&nbsp;//++意味着已#pragma DATA_MEM_BANK(w, 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short w [N];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma DATA_MEM_BANK(in1, 2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//++avoid bank conflicts<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short in1[N];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short in2[N];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short in3[N];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short in4[N];</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子in1~in4的容量为L1D cache的两倍，假如为32k,这样，假定已经从头对齐，按照上面变量的定义顺序，则in1的0~8k将映射到 cache的way0-set0开始，9~16k映射到 cache的way1-set0开始，17~24k映射到 cache的way0-set0开始，25~32k映射到 cache的way1-set0开始，in2的0~8k映射到 cache的way0-set0开始......这样布置后，w刚好从way0-set0开始映射。由此，dotprod(in1,w,N)开始后，in1与w分别进入set0-way0/way1,......到N/4时，超过cache的8k/way容量，9~16k的In1开始进入set0-way0,这是合理可接受的，因为in1的前8k line data已经不再需要了；但同时w的9~16k也开始进入set0-way1，将其前8k的line data替换掉了，这就不合理了，因为后面计算in2的时候还需要用到w的0~8k。这样分析后，可见使用一个简单循环就避免了这个问题。</p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子的启示是：数据排放不变(有时需要定义的数组太大，必须连续的空间，排放时不方便灵活处理)，通过改变程序，从而改变使用数据的顺序，一样可以达到一line data进入cache后，直到用完才释放的cache使用终极目的。</strong></p> <p>&gt;避免write buffer相关的stalls<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WB只有4个入口，且深度有限，如果WB满，而又出现写miss，则CPU就会stall直到有WB有空间为止。同时，read miss会使得write buffer完全停止，因此保证正确的read-after-write顺序非常重要(read miss需要访问的数据很可能仍然在WB中)。通过在L1D cache中分配输出buffer(事先将输出buffer cache进入L1D),可以完全避免WB相关的stalls，这样write操作会在输出buffer中hit，而非由WB写出。事实上，输出buffer是在循环执行过程中逐渐进入L1D的，在此过程中还是会存在read miss的。<br />&nbsp;&nbsp;&nbsp;&nbsp; void vecaddc(const short *restrict x, short c, short *restrict r, int nx)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp; int i;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i&nbsp;= 0 ; i &lt; nx; i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r[i]&nbsp;= x[i]&nbsp;+ c;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short in[4][N];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short out [N];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short ref [N];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short c, r;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i=0; i&lt;4; i++)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vecaddc(in[i], c, out, N);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = dotprod(out, ref, N);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p> <p><br /></p>  【DSP开发】TMS320C64x DSP L1 L2 Cache架构（1）——C64x Cache 1455348833566 Text 1dad75de_9f012c5 【DSP开发】 <p>【前沿】研究生阶段从事于DSP和FPGA技术的相关研究工作，学习并整理了大量的技术资料，包括TI公司的官方文档和网络上的详细笔记，花费了大量的时间和精力总结了前人的工作成果。无奈工作却从事于嵌入式技术开发工作，与通信领域关系不大，它们来源于网络，自己亦觉得应该将它们共享于网络，以便于知识的传承和再生，做出自己应有的贡献。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cache是一种特殊的存储器，它由Cache 存储部件和Cache控制部件组成。<strong>Cache&nbsp;存储部件</strong>一般采用与CPU同类型的半导体存储器件，存取速度比内存快几倍甚至十几倍。而<strong>Cache&nbsp;控制器部件</strong>包括主存地址寄存器、Cache&nbsp;地址寄存器，主存—Cache地址变换部件及替换控制部件等。The&nbsp;<strong>ultimate purpose</strong> of a cache is to <strong>reduce the average memory access time</strong>.&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;《<strong>TMS320C6000 DSP Cache User’s Guide</strong>》This document explains the <strong>fundamentals</strong> of memory caches and describes <strong>how to efficiently utilize</strong> the TMS320C6000 DSP <strong>two-level internal cache-based memory architecture</strong>. It shows <strong>how to maintain coherence</strong> with external memory,&nbsp;<strong>how to use DMA</strong> to reduce memory latencies, and <strong>how to optimize your code</strong> to improve cache efficiency.</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TMS320C64x L1 L2 Cache架构<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://volvet.blogbus.com/logs/8227255.html\" >http://volvet.blogbus.com/logs/8227255.html</a><br /><strong>C64x Cache Architecture<br /></strong>C64x CPU使用2级的Cache架构+外部内存(external memory)，Level 1 Cache 按照功能分为L1 Program Cache和L1 Data Cache。每个L1 Cache的大小为16k Byte，也就是说C64x CPU有16k L1P Cache 和 16k L1D Cache。CPU访问L1Cache可以无需任何延迟。<strong>因为L1 Cache的时钟频率是和C64x CPU同样为600 M</strong>。Level 2 Memory 其实是C64x&nbsp;的片内内存(addressable on chip memory)，大小为1024k，&nbsp;可以设置为L2 Cache或&nbsp;普通内存。L2 Cache主要是<strong>对片外内存做Cache</strong>，L2 普通内存<strong>可以用来做高速访问的内存</strong>。<strong>L2</strong> Memory的<strong>时钟频率是300M</strong>。L1D Cache Miss 访问L2 Cache的时钟延迟是8 cycle ，&nbsp;而访问L1D Cache Miss 访问L2 Memory的时钟延迟是 6 cycle。&nbsp;另外 L2 Cache 是同时作为Program Cache和Data Cache使用的。如果L1和L2 Cache 都Miss，访问外部内存的速度则是非常慢的，因为C64x&nbsp;的<strong>外部存储器时钟是100M-133M</strong>，因此要尽量避免CPU访问外部内存，才是有效提高程序性能的关键。<br />//<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图1 Flat Versus Hierarchical Memory Architecture<br />L1 Cache分为独立的程序缓存&nbsp;(<strong>L1P</strong>)&nbsp;和数据缓存&nbsp;(<strong>L1D</strong>)&nbsp;，其大小各为<strong>16KBytes</strong>，访问速度与DSP内核的运行时钟相匹配，<strong>L2</strong> Cache则采用统一的形式管理，其大小从256KB到1MB不等，访问速度相比L1 cache大大降低。L2 Cache通过<strong>DMA</strong>与外部低速的存储器件进行数据交换。</p> <p><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>地址映像和地址变换：将主存地址映像到/转换成Cache地址，以“块”为单位进行数据交换。<br /><strong>Direct-Mapped Cache</strong>，每个主存块只能映像到唯一一个特定Cache块位置，一般取模mod，Multiple locations may map to a single location in the cache，也称single-way set-associative cache；<br /><strong>N-way Set-Associative Mapping Cache</strong>，组间直接映像，组内全相联映像，multi-way set-associative cach<br /><strong>Fully-associative cache</strong>：any memory address to be stored at any location within the cache<br />写回法（Write-Back）一一Cache写命中时，只修改Cache内容，并做标记为Dirty Bit，而不立即写入主存，只有此行被替换时才写回主存； Cache写失效write miss时，L2多采用写分配法（Write Allocate），主存修改后并将修改行调入Cache（即L2 write miss时，分配L2空间）<br />写直达（Write-through）一一can never be dirty，即Cache从不包含更新的数据<br />替换算法——最近最少使用算法LRU；先进先出FIFO；随机法<br />Cache原理或层次结构的存储系统原理：基于程序访问的局部性原理，即Principle of Locality<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储系统采取分层、分体机制，指令和数据分开，指令总线和数据总线分开三种技术提高数据带宽。</p> <p>Cache系统代表性的包括三种级别：<br />1、第一级cache (L1)位于CPU芯片上并且运算于CPU工作频率；<br />2、第二级cache(L2)也位于芯片上比L1速度慢而体积大；<br />3、第三级cache(L3)位于CPU外部，是速度最慢、体积最大的存储器。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一级别的cahce相应执行的因素决定于Cache距离处理器的距离。下表体现了一个有代表性的Cache各自相应的时间。<br />表1 在一个2ns时钟周期的具有多级cache系统的处理器cache执行时间<br /><br />当运算器需要从存储器中提取数据时，它首先在最高级的cache中寻找然后在次高级的cache中寻找。如果在cache中找到，则称为命中hit；反之，则称为不命中miss。<br />一个cache系统的性能决定于cache申请命中的次数，也称为命中率。对于一个特定的级别的cache来说，一个高的cache命中率意为着更高的性能。而整个cahce系统的性能决定于各级cache的命中率。比如一个cache系统第一级 L1 cache命中率为70%，第二级L2 cache命中率为20%，第三级L3 cache命中率为5%，整个存储器的为5%，因此基于表2这个系统的平均存储器性能为：<br />(0.7 * 4)&nbsp;+&nbsp;(0.2 * 5)&nbsp;+&nbsp;(0.05 * 30)&nbsp;+&nbsp;(0.05 * 220)&nbsp;= 16.30 ns</p> <p>Cache的数据更新——<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为Cache也是主存储器中的一部分备份，因此cache是否能实时反映主存储器的数据显得至关重要。当cache里的数据改变，而主存储器内的数据未能改变时，cache里的数据被称为“脏”数据（使用Write-Back命令）。当数据在主存储中改变，而cache中未能实时改变，cache里的这个数据被称为“延迟”数据。（要使用Invalidate/Write-Back Invalidate命令）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cache控制器采用一系列的技术来维持Cache的一致性，从而保证cache里存储的都是有用的信息而不是延迟数据。“监测”和“写回”操作便是两种保持cache一致性的办法。“监测snoop”指的是用来允许cache在主存储器中是否进行影响cache地址的传输。如果cache探测到有这样的传输发生，它将及时更正自己从而匹配主存储器。这个在主存储器中复制数据的过程称为“写回writeback”操作（？？？）。<br /><br />图3 C64x Cache Memory Architecture<br /><br /><br />图4 C621x/C671x Cache Memory Architecture<br />注：上图中L1D Cache和L2之间的Victim Buffer与L2存储器的数据宽度为128bit，非256bit</p> <p><br />《TMS320C621x/C671x DSP Two-Level Internal Memory Reference Guide》<br /><br />图5 TMS320C621x/C671x Two-Level Internal Memory Block Diagram<br />上图5中：包括Bus Connection总线连接，</p> <p><br /><br />图6 TMS320C621x/C671x DSP Block Diagram</p> <p>表3 TMS320C621x/C671x/C64x Internal Memory Comparison</p> <p><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1P Cache（Direct-Mapped Cache）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1P Cache 是Direct Mapped Cache，大小为16kB。CPU要从内存读取指令的时候，这些指令是直接被放到L1P Cache中的。L1P Cache是只读的，C64x中，L1P Cache的Line Size 是32 bytes(64 bytes for C621x/C671x)， C64x 的指令长度一般为4Bytes，这就是表示在L1P Cache读取指令的时候，其实每次是读取8/16条指令。L1P Cache Miss 还会打乱指令流水，如何减少应用程序运行时的L1P Cache Miss，绝对是DSP 程序设计中的一个重点。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为L1P Cache 是Direct Mapped Cache，L1P Cache和实际内存的数据映射关系就很重要，理解Direct Mapped Cache，对实际函数的书写非常重要，而且跟函数被链接和载入的内存地址有关。比方说Loop中有两个被连续调用的函数，如果一个函数的起始位置是0x80000010，长度为40H，另一个函数起始地址为0x80004010，长度为40H，明显函数1被调用后，函数1的所有指令被加载入L1P Cache，但是函数2被调用的时候，因为Conflict Cache Miss，L1P Cache的内容被清掉后加载入函数2的指令，等再回去调用函数1的时候再次遇到Cache Miss，这是Cache 使用最糟糕的例子。因为L1P Cache的Line Size是32-Byte（64-Byte），因为代码的被使用的单位通常是函数(Function)，因此保证每个Function在Memory中的起始地址是32-Byte（或64-Byte）对齐是有效利用C64x L1P Cache的方式。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Direct Mapped Cache是一种最简单的Cache结构，因此这种结构的弊端也是显而易见的，Cache Conflict Miss会成为比Cache Capacity Miss更严重的存在。因此在L1D Cache，C64x 使用了2-Way Set Associative Cache。<br />//<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C64x的L1P是直接映射cache（direct-mapped），其为Read Allocate，即只在读丢失时才进行cache分配空间处理（对于L1P，很好理解，因为不可能产生改变程序的代码）。<br />表4 L1P Characteristics<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上表可以看出，C64x DSP的一些基本参数。其line size为32字节，而L1P大小为16K字节，故L1P中包含512条32字节的line frame；TMS320C621x/C671x的line size为64字节，而L1P大小为4K字节，故L1P Cache中包含64条64字节的line frame，内存中的地址总是映射到固定的line frame，即multiple lines in memory are mapped to the same set in the cache，而对于direct-mapped cache，a set只有一个line frame。这就如下图所示（该图表示了cache miss 与cache hit的计算方法）：<br /><br />图7 C64x L1P Architecture<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存中的地址0000h到0019h总是映射到0 line frame，而3FE0h到3FFFh总是映射到511 line frame，而由于cache用尽了，所以地址4000h到4019h又必须映射到0 line frame。注意对于C64x来说，这样的L1P中的一条line frame也就正好包含了一个取指包（instrution fetch packet）；对于C671x而言，a line frame包含2个取指包。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图中的Valid bit（有效数据位）是一条line frame的有效态位，V=0表示Cache中相应的line frame无效，即不包含cached data，反之则表示有效。其中L1P没有LRU位！</p> <p>下图为程序地址在Cache控制器内的结构：<br /><br />图8 C64x Memory Address from Cache Controller</p> <p><br />图9 C621x/C671x L1P Address Allocation<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图8所示，当CPU要读某个地址处的指令时，该地址在Cache中被分为3个部分。其中5到13位表示了该地址映射到哪一组set（对于直接映射Cache，set=line frame号），Cache控制器再检查有效位Valid和Tag Comparison（14到31位，因为multiple lines in memory are mapped to the same set in the cache），所作的具体操作见Figure1-6。如果最后结果为0，则read miss。A read miss also means that a line frame will be allocated for the line containing the requested address.&nbsp;由于L1P是读分配（read allocate），这时L1P控制器会从L2或内存中取出该指令包，并放入L1P Cache相应的line frame中，tag被设定，并且V=1表明该set包含有效的数据，同时该指令包也会被送入CPU，此时该过程结束。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，利用Cache最重要的是保证只要一条line frame的内容还有用，就不要取代它，即最大化line的重复使用率Maximize cache line reuse。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决Cache miss问题的一种方案就是建立包含多条line frame的set，即L1D Cache使用的原理2-Way Set Associative Cache。这样内存中多条具有相同Set值的地址下的指令就可以同时存在于Cache中而不会发生冲突，从而使命中率提高。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1D Cache（2-Way Set-Associative Cache）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1D Cache是2-Way Set Associative Cache，大小为16KB（4KB for C671x）。L1D Cache的Line Size 是64 bytes(32 bytes for C621x/C671x)，L1D Cache 是2-Way Set Associative Cache的意思就是同一区块，L1D Cache有两个入口可以访问，相比Direct Mapped Cache，L1D就可以大大减少Cache Conflict Miss发生的机会。同样，L1D Cache Miss 也会打乱指令流水。相对于L1P Cache还有不同的是L1D Cache是可写的，这就有可能会涉及到写延迟，下文再仔细讨论。<br />//<br />C64x的L1D是两路组相联2-way Set-Associative的cache，下表为其基本参数：<br />表5 L1D Characteristics<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2-way set-associative cache的每个set包含两条line frames，一条在way 0，另一条在way 1。内存中的a line实际上还是映射到cache中的one set中，但可以使way0的line frame，也可以使way1的line frame。而直接映射Cache可以看做1-way cache。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上表中可以看出C64x的L1D每条line frame为64字节（32 bytes for C621x/C671x）。并且是Read Allocate，Write-back的，这里对此先不做解释。上表还说明当write miss时，L1D通过4*64-bit（4*32-bit for C671x）的write buffer向下级存储器写入数据。</p> <p><br />图10 C621x/C671x L1D Address Allocation</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图为set-associative cache的结构图，图中说明了其hit和miss的确定方法，这其实和direct mapped cache差不多，先解析该地址对应哪一组set，只是有两次tag比较（确定数据保存在哪一路），一次Valid bit有效位比较，根据LRU位来确定需要的数据保存在那一路，根据Dirty位是否为1决定是否写回。<br /><br />图11 C64x L1D Architecture</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当两路中都不包含所需数据即read miss时，就要从内存中取了，而取到的数据应该放到哪一路呢？这就需要LRU（least-recently-used）位，用来指示哪些路最近最少使用。Cache中每一个set都有一个LRU位，当LRU=0，则数据被映射到way0的line frame中；如果LRU=1，则数据被映射到way1的line frame中。每次访问到某个set中的某路line frame时，如果hit，LRU位的状态都会改变一次；When a way is accessed，the LRU bit always switches to the opposite way，来保证most-recently-used位不被取代掉；而当read miss时，a set中的LRU line frame被分配new line替代当前line，而上述机制由程序访问的局部性决定。注意LRU位只在miss发生时被参考，但是它的状态却在每次line frame被访问时（不论miss或hit）都要作相应调整即更新。由于最近最少使用位LRU只记录不命中操作，但是它的状态每次都会更新，无论对列访问是命中还是不命中，读或者写。<br />前面说到过，L1D是Read Allocate cache，意思是cache中的一条line frame只在read miss发生时才会作相应的重新映射操作；而write miss时，只是将数据通过write buffer写入下一级内存中（L2 SRAM或者外部存储器），不通过L1D Cache，因为L1D不是write allocate，这个write buffer包括4路64-bit（32-bit for C621x /C671x）的通路。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，因为L1D是Write-Back cache，所以当write hit发生时，数据只是写入cache，而不会立即写入对应的下级内存。这样，为了在以后能正确地将修改过的数据写回下级内存，就必须知道cache中的哪条line frame被CPU修改过。所以cache中每条line frame都有一个Dirty bit（D）与其相关。Dirty bit的初始值为0，当CPU修改过其数据，则被置为1。当某一条line frame以为read miss而需要被替代时，则会检测其dirty bit，如果它是一条dirty line（D=1），则其内容会先写回victim buffer，再通过write back命令写回下级内存，然后新的数据存储在line frame；否则（D=0），它的内容会被忽略。这种写回操作也能由程序向cache 控制器发送write back命令来实现。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L2包括L2 Cache和L2 SRAM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Level 2其实就是C64x 中的On Chip Memory。C64x 的On Chip L2 Memory的大小是1024k Bytes，可以被设置成为L2 SRAM 或L2 SRAM和L2 Cache的混合体。L2的Line Size 是128 bytes，可以是 1,2,3,4 Way Set Associative Cache，取决于分配的L2 Cache大小。可以是0K，32K（1-Way），64K (2-Way)，128K&nbsp;(3-Way)&nbsp;或者 256K (4-Way)。L2 Cache 最大会使用256KB（64KB for C671x）的L2 SRAM，这样L2 SRAM最少还可以有1024–256 =768KB可以被程序使用，如何利用L2 SRAM 应该是程序员煞费苦心的地方。<br />//<br />表6 L2 Cache Characteristics<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L1和L2 Cache像这样协同工作：当某个地址在L1中miss，则到L2中查找；L2使用相同的方法检测是否所需地址在L2中。反之，如果L1 hit，则接下来的操作直接在L1中进行，与L2无关。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上表给出了C6000 DSP的L2 Cache 属性，其L2&nbsp;存储空间可以分为可寻址的片上空间（L2 SRAM）和cache（L2 Cache）两部分。与L1 Cache的read-allocate不同，L2 Cache是Read and write allocate。L2 cache只用来cache外部存储地址，而L1 Cache用来cache L2 SRAM和外部存储地址。L2使用Valid bit和tag comparison确定请求的地址是否在L2 cache中；LRU位确定line frame被分配在哪一路way（read miss）；Dirty bit表明line frame在new line取指之前首先写回到external memory（如果该line还包含在L1D中，它要首先写回到L2中，保持cache的一致性Coherence）。<br /><br />图12 C621x/C671x L2 Address Allocation (All L2 Cache Modes)<br />下面以CPU要求读取一个可缓冲的外部存储地址为例，说明L2 Cache工作过程。<br />1、在L1（L1P或L1D）中miss，并且在L2 Cache中miss。这时，外存中相应的line会被调入L2 cache，再由LRU bits决定被放置在哪条line frame。如果该line frame包含Dirty data，则在被新的line取代时，会将其数据写回外存中相应位置。（如果该line frame也在L1D中，则在L2 line写回外存前要先由L1写回L2，这一操作叫保持cache一致性）接着，这一line再被写为L1的形式，并交至L1 cache。L1 cache在将其保存在其cache中，并交由CPU处理。注意，如果L1中放置该line的frame line含有Dirty data，同样要先写回L2 cache。<br />2、如果该地址在L2 Cache 中hit。则相应line直接调入L1中并交给CPU处理。</p> <p>前面说过，L2 Cache是Read and write allocate，这是指当CPU要向外存中写数据时，如果L1和L2 cache miss，则会像读时那样，把对应位置的line从外部存储器中调入到L2 Cache的line frame中，而这时所作的操作也与读时类似，如果含有Dirty data，则应先写回外存。但应注意，这一line是不会出现在L1D中的，因为L1D Cache只是read-allocate，不是write allocate。如果L2写命中，L2 cache line frame直接被CPU的写数据更新。</p> <p>L1P Cache：4KB，64bytes/line size<br />L1D Cache：<br />L2 Memory：包括L2 SRAM（可寻址的片上存储器）和L2 Cache（caching External Memory locations）</p> <p><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——Cache Misses的类型——<br /> Capacity miss容量丢失：<br />解决方法①reduce the amount of data that is operated on at a time，减小操作所需的数据量；②the capacity of the cache can be increased，增加Cache的容量。<br /> Conflict miss冲突丢失：<br />解决方法①change the memory layout；②we can create sets that can hold two or more lines。<br /> Compulsory miss强制（必然）丢失：first-reference miss，这种缺失发生在第一次访问数据时，是不可避免的，除非系统对数据进行了预读取。</p> <p>Cache Miss（read miss，write miss）：<br />Cache Hit（read hit，write hit）：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一种不命中方式，Cache控制器在将数据从存储器放入cache中时都会产生延迟。为了得到更高的性能，每一列中的内容在被取代之前应该尽可能的被重复利用。重复使用某列以此来获得不同的位置能够改善空间位置的访问，而重复使用某列可以改善时间位置的访问。这就是优化cache存储性能的一个最基本的准则。Maximize cache line reuse <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于Cache的存储系统模型：Execution Time =↓Cache Cycle Count/↑CPU Clock Rate<br />Optimizing Cache Performance——熟悉cache memory architecture，特别cache memory的特性如line size, associativity, capacity, replacement scheme, read/write allocation, miss pipelining, and write buffer.&nbsp;<br />Application-Level Optimizations：使用L2 Cache和DMA<br />Procedural-Level Optimizations：Data type减小memory带宽；chaining；避免L1P和L1D冲突丢失；避免L1D颠簸thrashing；避免容量丢失；避免write buffer stall<br />L2 Access Conflict 访问冲突：L2 can only service one request 一次；优先级顺序是L1P read miss；L1D read or write miss；EDMA read or write；Internal cache operations（victim writebacks, line fills, snoops），包括同时访问同一个bank发生访问冲突<br />L2 Bank Conflict 组冲突：Since an L2 access requires 2 cycles to complete, accesses to the same bank on consecutive cycles cause a stall.&nbsp;即连续访问同一个bank发生组冲突<br />L1P的优化思路较为简单，主要的原则就是：尽量以循环、迭代方式实现算法，减小代码量。</p> <p>Cache Flush有两个动作，将cache memory中的内容写回external memory，clean cache memory；Cache Clean动作只有一个，clean the cache memory</p> <p>Execute packet执行包：may contain between 1 and 8 instructions.<br />Fetch packet取指包：A block of 8 instructions；One fetch packet may contain multiple execute packets</p> <p>Miss pipelining（Pipelined Misses）：The process of servicing a single cache miss is pipelined over several cycles；overlap the processing of several misses，</p> <p>Associativity：The number of line frames in each set，or the number of ways<br />Long-distance access：CPU access external noncacheable memory<br />Line：A cache line is the smallest block of data that the cache operates on.&nbsp;被操作的最小单元<br />Set组：A collection of line frames in a cache；A direct-mapped cache contains one line frame per set, and an N-way set-associative cache contains N line frames per set. A fully-associative cache has only one set that contains all of the line frames in the cache.&nbsp;<br />Way：each set in the cache contains multiple line frames；The number of line frames in each set is referred to as the number of ways in the cache<br />Victim Buffer：A special buffer that holds victims until they are written back.<br />Write Buffer：<br />Write merging：combine multiple independent writes into a single, larger write.如用于DMA写和L1D write buffer 或victim buffer can merge multiple writes</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Memory System Coherence<br />1、<strong>Cache Coherence Problem</strong><br />Coherence between CPU and EDMA（外设）or host accesses：If any read of a data item returns the most recently written value of that data item；A coherent memory system ensures that all writes to a given memory location are visible to future reads。<br />例如外设写，CPU读hit，Memory更新而Cache未更新；CPU写hit，外设读，Cache更新而Memory未更新，此时发生Cache和Memory不一致incoherence。<br />Consequently, if a memory location存储单元 is shared, cached, and has been modified, there is a Cache Coherence Problem发生的条件：<br /> Multiple devices (CPUs, peripherals, DMA controllers) share a region of memory for the purpose of data exchange；<br /> This memory region is cacheable by at least one device；<br /> A memory location in this region has been cached；<br /> And this memory location is modified (by any device)</p> <p>2、<strong>Snoop Commands</strong>：低级的存储器检查请求的地址是否cached（valid）在高级的存储器中<br />L1D Snoop Command (C64x devices only)：<br /> Writes back a line from L1D to L2 SRAM/cache<br /> Used for DMA reads of L2 SRAM<br />L1D Snoop-Invalidate Command：<br /> Writes back a line from L1D to L2 SRAM/cache and invalidates it in L1D<br /> Used for DMA writes to L2 SRAM and user-controlled cache operations<br />L1P Invalidate Command：<br /> Invalidates a line in L1P<br /> Used for DMA write of L2 SRAM and user-controlled cache operations</p> <p>注意：DMA is not allowed to access addresses that map to L2 cache.<br />3、<strong>Cache Coherence Protocol</strong>：DMA Accesses to L2 SRAM</p> <p><br />图13 DMA Write to L2 SRAM<br />*）If line is dirty it is first written back to L2 SRAM and merged with the new data written by the DMA.&nbsp;<br />DMA write：snoop命令包括L1D写回-使无效；L1P使无效</p> <p><br />而DMA read：写回<br />*) A snoop command is sent on C64x DSP, the line is written back and kept valid.&nbsp;<br />On C621x/C671x DSP, a snoop–invalidate command is sent which additionaly invalidates the line in L1D.</p> <p><br />图14 DMA Read of L2 SRAM</p> <p><br />4、<strong>解决Cache Incoherence</strong>的方法：1) Clean or flush cache memory；2) Double buffering，即ping-pong buffering；3) Disabling External Memory Caching</p> <p>表7 Coherence Assurances in the Two-Level Memory System</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Double-buffering即ping-pong buffering，have two sets of input and output buffers：one for CPU processing data and one for EDMA transfers-in-progress.&nbsp;&nbsp; 4个Buffer：InBuffA and OutBuffA 以及InBuffB and OutBuffB，保持L1D和L2 SRAM的一致性；<br />双缓冲的例子程序：D:\\CCStudio_v3.3\\Cache Examples\\DSKC6711\\L2_double_buf<br />外部存储器双缓冲的例子程序：D:\\CCStudio_v3.3\\Cache Examples\\DSKC6711\\ext_double_buf</p> <p><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In addition to the coherence operations, it is important that all DMA buffers are aligned at an L2 cache line and are an integral multiple of cache lines large. Cache控制器操作一直whole cache line，Block的大小应该是Cache Line的整数倍，并且边界对齐</p> <p><br />图15 Double Buffering in L2 SRAM<br />注：DMA写L2 SRAM对L1D snoop-invalidate；DMA读L2 SRAM没有snoops，因为它没有在L1D中被cached</p> <p><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C621x/C671x and C64x DSPs automatically maintain cache coherence for accesses by the CPU and EDMA to L2 SRAM through a hardware cache coherence protocol based on snoop commands.&nbsp;以便保持L2 SRAM和L1D的一致性；<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Whenever external memory caching is enabled and the EDMA is used to transfer to/from external memory, it is your responsibility to maintain cache coherence.&nbsp;即手动保持external memory和L2 Cache的一致性，以及保持L2 Cache和L1D的一致性（L2 Cache使能时）<br />DMA写之前写回使无效：CACHE_wbInvL2(InBuffB, BUFSIZE, CACHE_WAIT);<br />DMA读传输之前写回：CACHE_wbL2(OutBuffB, BUFSIZE, CACHE_WAIT);</p> <p>表8 DMA Scenarios With Coherence Operation Required</p> <p>Memory Access Ordering<br />The C6000 DSP cores may initiate up to two parallel memory operations per cycle.&nbsp;<br />表9 Program Order for Memory Operations Issued From a Single Execute Packet<br /><br />原则：Load优先于Store；DA1优先于DA2；L2存储器按L1P、L1D、EDMA的顺序访问</p> <p><br /><br />图17 C621x/C671x Cache Memory Architecture<br />注：L2 memory：256KBytes<br /><br /><br />图18 C64x Cache Memory Architecture</p> <p><br /></p>  【DSP开发】Cache一致性维护的问题 1455348325179 Text 1dad75de_9f012ab <p>大家好！</p> <p>目前我在做C6670,多核访问MSMC区域内的同一个数组。</p> <p>环境如下：CCS v5.3、<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ti.com.cn/product/cn/TMS320C6670\" >TMS320C6670</a>、SYS/BIOS v6.33</p> <p>大致想实现的功能是：申请一个全局数组，load到MSMC区域内，Core0先写这个数组，然后通知Core1去打印这个数组。</p> <p>实现方法是：</p> <p>1.&nbsp;使用了SYS/BIOS v6.33，在起Task之前，手动地设置L2为non-cacheable，L1d为32KB cacheable</p> <p>&nbsp;&nbsp;&nbsp; CACHE_setL1PSize(CACHE_L1_32KCACHE);</p> <p>&nbsp;&nbsp;&nbsp; CACHE_setL1DSize(CACHE_L1_32KCACHE);</p> <p>&nbsp;&nbsp;&nbsp; CACHE_setL2Size(CACHE_0KCACHE);</p> <p>2.&nbsp;定义了全局变量</p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;#define</strong>MSMC_test_len 256</p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;#pragma</strong> DATA_ALIGN &nbsp;&nbsp;(MSMC_test, 64)</p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;#pragma</strong> DATA_SECTION (MSMC_test,&nbsp;&quot;.shareMemotest&quot;);</p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp; unsigned char </strong>MSMC_test[MSMC_test_len];</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于开启了L1d cache，所以使用了</p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma</strong> DATA_ALIGN &nbsp;&nbsp;(MSMC_test, 64)实现与L1d的64 Bytes Cache Line对齐</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并在CMD文件中，将该变量分配到共享存储区</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.shareMemotest&nbsp; load &gt;&gt; MSMCSRAM</p> <p>3.&nbsp;在Core0的代码中，写这个全局数组</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>for</strong>(i=0;i&lt;MSMC_test_len;i++)</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSMC_test[i]&nbsp;= test_cnt;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;然后，对Core0的L1d进行Write-Back再Invalidate</p> <p>&nbsp;&nbsp;&nbsp; CACHE_wbInvL1d ((<strong>void</strong>&nbsp;*) MSMC_test, MSMC_test_len, CACHE_WAIT);</p> <p>4.&nbsp;接着Core0向Core1发送信号</p> <p>5. Core1收到这个信号后，</p> <p>&nbsp;&nbsp;&nbsp; CACHE_invL1d((<strong>void</strong>&nbsp;*) MSMC_test, MSMC_test_len, CACHE_WAIT);</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>for</strong>(i=0;i&lt;MSMC_test_len;i++)</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;{</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System_printf(&quot;%d &quot;,MSMC_test[i]);</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>if</strong>(i%20&nbsp;== 0)</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System_printf(&quot;\\n&quot;);</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;}</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;首先Invalidate Core1的L1d cache，然后打印这个全局数组。</p> <p>出现问题是：每次Core0对长度为256 Bytes的MSMC_test写数据，比如0x02或者0x03等等，然后通知Core1打印，Core1打印出来的是前128 Bytes正确，后面的128 Bytes都是不正确的，显示的是第一次Core0对MSMC_test写的数据。</p> <p>补充调试过程如下</p> <p>1.&nbsp;首先Core0写全局数组MSMC_test[256]，</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.deyisupport.com/cfs-file.ashx/__key/communityserver-discussions-components-files/53/1351.1.JPG\" ><img src=\"http://www.deyisupport.com/resized-image.ashx/__size/550x0/__key/communityserver-discussions-components-files/53/1351.1.JPG\" style=\"max-width:500px;\" /></a></p> <p>此时Core0还没有将L1d中的数据Write-Back到MSMC，Core1也没开始执行invalidate。所以Core1中观察这个全局数组，还是上次的数据</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.deyisupport.com/cfs-file.ashx/__key/communityserver-discussions-components-files/53/2605.1.JPG\" ><img src=\"http://www.deyisupport.com/resized-image.ashx/__size/550x0/__key/communityserver-discussions-components-files/53/2605.1.JPG\" style=\"max-width:500px;\" /></a></p> <p>2.&nbsp;然后Core0执行Wite-back Invalidate，接着通知Core1。</p> <p>3. Core1收到来自Core0的通知以后，首先执行invalidate，此时再观察这个MSMC_test[256]，发现数据更新了。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.deyisupport.com/cfs-file.ashx/__key/communityserver-discussions-components-files/53/5751.1.JPG\" ><img src=\"http://www.deyisupport.com/resized-image.ashx/__size/550x0/__key/communityserver-discussions-components-files/53/5751.1.JPG\" style=\"max-width:500px;\" /></a></p> <p>至此应该说明了Core0写数据到Core0的L1d，并正确的write-back到MSMC上。而Core1 Invalidate其L1d后，此时如果Core1再去访问这个MSMC_test，就会重新去MSMC区域中去取数。</p> <p>4.&nbsp;然后Core1开始打印，每打印一个Byte，都打一个断点观察</p> <p>5.&nbsp;在Core1上开始打印，打印第一个Byte时候，MSMC_test[256]的前64 Bytes变灰色了</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.deyisupport.com/cfs-file.ashx/__key/communityserver-discussions-components-files/53/3157.1.JPG\" ><img src=\"http://www.deyisupport.com/resized-image.ashx/__size/550x0/__key/communityserver-discussions-components-files/53/3157.1.JPG\" style=\"max-width:500px;\" /></a></p> <p>这是因为L1d的cache line长度为64 bytes的原因嘛？</p> <p>6. Core1打印前128 Bytes一切正常，但是打印MSMC_test[256]中的第129个Byte时候，出现了下面的问题</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.deyisupport.com/cfs-file.ashx/__key/communityserver-discussions-components-files/53/8611.1.JPG\" ><img src=\"http://www.deyisupport.com/resized-image.ashx/__size/550x0/__key/communityserver-discussions-components-files/53/8611.1.JPG\" style=\"max-width:500px;\" /></a></p> <p>即从第129个Byte开始的64 Bytes，被置为了上次的数据。</p> <p>因为之前invalidate了L1d，L1d会去MSMC重新取数，cache到L1d的cache line frame。而L1d的cache line是64bytes的，所以会取64bytes的数据。</p> <p>但是打印到第129个Byte时候，重新取64Bytes结果取到了之前的数据。</p> <p>难道是Core0没有正确地将第二次的0x02 write-back到MSMC？？可是在步骤3中，Core1已经能够观察到第二次的数据了！</p> <p>这是为什么啊？</p> <p>补充：</p> <p>1.上面描述的是测试MSMC_test这个全局数组的大小为256 Bytes，但是把这个数组大小设置为1088以上，就不会出现这个问题，一切正常。</p> <p>就是说最上面的post中设置MSMC_test_len为1088，仍然有这个问题。但是只要MSMC_test_len大于1088，就没有这个问题。比如Core0写2048 Bytes的全局数组，Core1去打印，一切正常。</p> <p>很奇怪1088是怎么来的？</p> <p>2.&nbsp;如果把L1d设置为non-cacheable，无论L2是否设置为cacheable，都无需进行write-back、invalidate这些手动一致性维护操作。这是为什么？</p> <p>3. SYS/BIOS默认情况下，对L1d、L1p、L2是怎么配置的？</p> <p>搜了几个帖子，找到了方法：</p> <p>在Core1打印共享buffer之前，不仅要invalidate Core1的L1D，还要invalidate XMC的prefetch buffer，虽然CorePac手册说这样有损性能，但是目前可以。有时间再考虑怎么仔细维护这些一致性的问题。</p> <p>相应的数据写之后要Writeback（cache里面的数据才会回写到内存里）,读之前要invalid（读的时候就会从读内存里的数据，而不是cache里的数据）.你试着这样做下，看下效果。<br /></p>  【编程开发】15款免费IDE 1455332056356 Text 1dad75de_9ef197b 【编程开发】 <p>收录了大量的开源、免费的IDE，精选15个免费IDE，推荐给大家。列表如下：</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/komodo+ide\" >Komodo Edit</a>&nbsp;(Windows, Mac, Linux) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.activestate.com/komodo-edit\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091117_Kp6t.jpg\" style=\"max-width:500px;\" /></a></p> <p>Komodo IDE可以在 Windows、Mac OS X 和 Linux 上运行，并支持通用的开源语言&nbsp;—— Perl、PHP 和 Ruby。代码智能引擎非常可靠。它扫描所有语言安装找到定制扩展，比如 PEAR 模块。在项目方面，它支持与 CVS、Subversion 和 Perforce 的集成，也允许直接向服务器 FTP 传递代码。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/aptana\" >Aptana Studio</a>&nbsp;(Windows, Mac, Linux) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.aptana.org/products/studio3\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091118_RQpc.gif\" style=\"max-width:500px;\" /></a></p> <p>Aptana是一个非常强大、开源的专注于Ajax开发的开发工具。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/code-blocks\" >Code::Blocks</a>&nbsp;(Windows, Mac, Linux) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.codeblocks.org/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091118_JfCd.jpg\" style=\"max-width:500px;\" /></a></p> <p>Code::Blocks (codeblocks)是一个开源、免费、跨平台的c++ IDE。官方网站上称其能满足最苛刻的用户的需求。虽有点夸张，但既然敢这样说，也说明它的功能肯定不差。可扩展插件，有插件向导功能，让你很方便的创建&nbsp;自己的插件。Code::Blocks是用c++编写的（用wxWidgets库），捆绑了MinGW编译器。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/eclipse\" >Eclipse</a>&nbsp;(Windows, Mac, Linux) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eclipse.org/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091118_lSyQ.jpg\" style=\"max-width:500px;\" /></a></p> <p><strong>Eclipse</strong>是著名的跨平台的自由集成开发环境（IDE）。最初主要用来Java语言开发，但是目前亦有人通过插件使其作为其他计算机语言比如C++和Python的开发工具。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/codelite+ide+for+c+cplusplus\" >CodeLite</a>&nbsp;(Windows, Mac, Linux) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://codelite.org/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091119_z5uC.jpg\" style=\"max-width:500px;\" /></a></p> <p>CodeLite IDE &nbsp;是一个强大的开源,跨平台的 C/C++整合开发环境.&nbsp;支持包括 Windows、Linux 和 Mac 系统下运行。</p> <p><strong>亮点：</strong><br />1.&nbsp;代码自动完成功能很强大<br />2.&nbsp;仿VS，很容易上手<br />3.&nbsp;界面更友好<br />4.&nbsp;与Subversion集成<br />5.&nbsp;与wxFormBuilder集成<br />6.&nbsp;函数跳转功能强大</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/visualstudio\" >Visual Studio Express</a>&nbsp;(Windows) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.microsoft.com/express/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091120_fp6K.jpg\" style=\"max-width:500px;\" /></a></p> <p>VS的轻型版本，功能也很强大。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/netbeans\" >NetBeans </a>(Windows, Mac, Linux) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://netbeans.org/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091120_KsNV.jpg\" style=\"max-width:500px;\" /></a></p> <p><strong>NetBeans</strong>是Sun公司的开源软件开发集成环境，是一个开放框架，可扩展的开发平台，可以用于Java，C/C++，PHP等语言的开发，本身是一个开发平台，可以通过扩展插件来扩展功能。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/xcode\" >Xcode</a>&nbsp;(Mac) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://developer.apple.com/technologies/tools/xcode.html\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091121_ITUX.jpg\" style=\"max-width:500px;\" /></a></p> <p><strong>Xcode</strong>是苹果公司向开发人员提供的集成开发环境<strong>（非开源）</strong>，用于开发Mac OS X的应用程序。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/mochacode\" >MochaCode</a>&nbsp;(Mac) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://syntori.com/mochacode/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091121_V4Kx.jpg\" style=\"max-width:500px;\" /></a></p> <p>MochaCode 是一个 Mac 平台下的 Java 和&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/cocoa\" >Cocoa</a>&nbsp;混合程序开发工具。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/geany\" >Geany</a>&nbsp;(Windows, Mac, Linux) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.geany.org/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091121_lH1B.gif\" style=\"max-width:500px;\" /></a></p> <p>Geany 是一个小型的 C 代码编辑器，使用 GTK2 开发的开发环境。包括语法高亮、代码自动完成、调用提示以及支持其他类型语言的文件包括: C, Java, PHP, HTML, DocBook, Perl, LateX, and Bash), and symbol lists.</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/pspad\" >PSPad</a>&nbsp;(Windows) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.pspad.com/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091122_Dt7y.gif\" style=\"max-width:500px;\" /></a></p> <p>PSPad 是一个Windows平台上免费的适合程序员使用的编辑器。它可以让你保持上一次编辑状态，这样在你下次打开编辑器的时候可以直接显示原来的文件。此外它还支持通过FTP进行远程编辑，支持多文件的比较等。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/anjuta\" >Anjuta DevStudio</a>&nbsp;(Linux) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://projects.gnome.org/anjuta/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091122_hMXS.jpg\" style=\"max-width:500px;\" /></a></p> <p>Anjuta是一个C/C++ IDE，它最大的特色是灵活，同时打开多个文件，内嵌代码级的调试器(调用gdb)，应用程序向导（Application widzards）可以方便的帮助你创建GNOME程序而不需要你自己写一些与你兴趣无关的代码。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/kdevelop\" >KDevelop</a>&nbsp;(Windows, Mac, Linux) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.kdevelop.org/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091122_mdqa.gif\" style=\"max-width:500px;\" /></a></p> <p>KDevelop-Project诞生于1998年，其目的是为KDE提供一个易用的集成开发环境(Integrated Development Environment)。此后，KDevelop IDE采用GPL进行发布，&nbsp;它支持很多程序设计语言，比如C, C++, Fortran, Java, Pascal, Perl, PHP, Python，以及Ruby等。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/notepadplusplus\" >Notepad++</a>&nbsp;(Windows) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://notepad-plus-plus.org/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091123_YIgR.gif\" style=\"max-width:500px;\" /></a></p> <p><strong>Notepad++</strong>&nbsp;是在微软视窗环境下的一个免费的代码编辑器。</p> <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/p/context\" >ConTEXT</a>&nbsp;(Windows) <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.contexteditor.org/\" ><img src=\"http://static.oschina.net/uploads/img/201103/23091123_7UiJ.jpg\" style=\"max-width:500px;\" /></a></p> <p>与Notepad++类似，ConTEXT是个高级文本编辑器。功能包括多语言界面、语法高亮，你可存储代码模板、比较文件等等。</p> <p>相关链接</p> <ul> <li><p><br /></p></li> </ul> <p>想通过手机客户端（支持 Android、iPhone 和 Windows Phone）访问开源中国：<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/app\" >请点这里</a></p> <p>本站文章除注明转载外，均为本站原创或编译<br />欢迎任何形式的转载，但请务必注明出处，尊重他人劳动共创开源社区<br />转载请注明：文章转载自：<strong>开源中国社区</strong>&nbsp;[<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.oschina.net/\" >http://www.oschina.net</a>]</p> <p><br /></p>  【编程开发】原子操作~自增 1455331833495 Text 1dad75de_9ef1972 【编程开发】 <p>InterLockedIncrement and InterLockedDecrement</p> <p>实现数的原子性加减。什么是原子性的加减呢？</p> <p>举个例子：如果一个变量 Long value =0;</p> <p>首先说一下正常情况下的加减操作：value+=1；</p> <p>1：系统从Value的空间取出值，并动态生成一个空间来存储取出来的值；</p> <p>2：将取出来的值和1作加法，并且将和放回Value的空间覆盖掉原值。加法结束。</p> <p>如果此时有两个Thread&nbsp;，分别记作threadA，threadB。</p> <p>1：threadA将Value从存储空间取出，为0；</p> <p>2：threadB将Value从存储空间取出，为0；</p> <p>3：threadA将取出来的值和1作加法，并且将和放回Value的空间覆盖掉原值。加法结束，Value=1。</p> <p>4：threadB将取出来的值和1作加法，并且将和放回Value的空间覆盖掉原值。加法结束，Value=1。</p> <p>最后Value&nbsp;=1&nbsp;，而正确应该是2；这就是问题的所在，InterLockedIncrement&nbsp;能够保证在一个线程访问变量时其它线程不能访问。同理InterLockedDecrement。</p> <p>LONG&nbsp;&nbsp; InterlockedDecrement(&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPLONG &nbsp; lpAddend &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp; variable &nbsp; address &nbsp;&nbsp;<br />);&nbsp;&nbsp;&nbsp;<br />属于互锁函数，用在同一进程内，需要对共享的一个变量，做减法的时候，&nbsp;&nbsp;&nbsp;<br />防止其他线程访问这个变量，是实现线程同步的一种办法（互锁函数）&nbsp;<br />&nbsp;&nbsp;&nbsp;<br />首先要理解多线程同步，共享资源（同时访问全局变量的问题），否则就难以理解。&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />result &nbsp;&nbsp;=&nbsp;&nbsp; InterlockedDecrement（&amp;SomeInt）&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />如果不考虑多线程其实就是&nbsp;&nbsp; result &nbsp;&nbsp;=&nbsp;&nbsp; SomeInt &nbsp;&nbsp;–&nbsp;&nbsp; 1;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />但是考虑到多线程问题就复杂了一些。就是说如果想要得到我预期的结果并不容易。&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />result &nbsp;&nbsp;=&nbsp;&nbsp; SomeInt &nbsp;&nbsp;–&nbsp;&nbsp; 1；&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />举例说:&nbsp;&nbsp;&nbsp;<br />SomeInt如果==1;&nbsp;&nbsp;&nbsp;<br />预期的结果result当然==0;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />但是,如果SomeInt是一个全程共享的全局变量情况就不一样了。&nbsp;&nbsp;&nbsp;<br />C语言的&quot;result &nbsp;&nbsp;=&nbsp;&nbsp; SomeInt &nbsp;&nbsp;–&nbsp;&nbsp; 1；&quot;&nbsp;&nbsp;&nbsp;<br />在实际的执行过程中，有好几条指令，在指令执行过程中，其它线程可能改变SomeInt值，使真正的结果与你预期的不一致。&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />所以InterlockedDecrement(&amp;SomeInt)的执行过程是这样的&nbsp;&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __禁止其他线程访问&nbsp;&nbsp;&nbsp;(&amp;SomeInt)&nbsp;&nbsp;&nbsp;这个地址&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SomeInt &nbsp;&nbsp;–;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; move &nbsp; EAX,&nbsp;&nbsp; someInt;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;设定返回值,C++函数的返回值&nbsp;&nbsp;&nbsp;都放在EAX中,&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __开放其他线程访问&nbsp;&nbsp;&nbsp;(&amp;SomeInt)&nbsp;&nbsp;&nbsp;这个地址&nbsp;&nbsp;&nbsp;<br />}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />但是实际上只需要几条指令加前缀就可以完成，以上说明是放大的。&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />你也许会说，这有必要吗?&nbsp;&nbsp;&nbsp;一般来说，发生错误的概率不大，但是防范总是必要的&nbsp;<br />如果不考虑多线程&nbsp;&nbsp;&nbsp;<br />result &nbsp;&nbsp;=&nbsp;&nbsp; InterlockedDecrement(&amp;SomeInt);&nbsp;&nbsp;&nbsp;<br />就是result &nbsp;&nbsp;=&nbsp;&nbsp; SomeInt &nbsp;&nbsp;–&nbsp;&nbsp; 1;&nbsp;&nbsp;&nbsp;<br />如果SomeInt==1,result一定==0;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />但是，在多线程中如果SomeInt是线程间共享的全局变量，情况就不那么简单了。&nbsp;&nbsp;&nbsp;<br />result &nbsp;&nbsp;=&nbsp;&nbsp; SomeInt &nbsp;&nbsp;–&nbsp;&nbsp; 1;&nbsp;&nbsp;&nbsp;<br />在CPU中，要执行好几条指令。在指令中间有可能SomeInt被线程修改。那实际的结果就不是你预期的结果了。&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />InterlockedDecrement(&amp;SomeInt)&nbsp;&nbsp;&nbsp;<br />放大的过程，如下:&nbsp;&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __禁止其他线程访问&nbsp;&nbsp;&nbsp;&amp;SomeInt &nbsp;&nbsp;地址；&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SomeInt &nbsp;&nbsp;–;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/////其他线程不会在这里修改SomeInt值。&nbsp;&nbsp;&nbsp;!!!!!!&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov &nbsp; EAX,&nbsp;&nbsp; SomeInt;&nbsp;&nbsp;&nbsp;//C++&nbsp;&nbsp;&nbsp;函数返回值&nbsp;&nbsp;&nbsp;总放在EAX中。&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __开放其他线程访问&nbsp;&nbsp;&nbsp;&amp;SomeInt &nbsp;&nbsp;地址；&nbsp;&nbsp;&nbsp;<br />}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />实际的CPU执行过程只有几条加前缀的指令(586指令)&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />你会说，有必要吗?&nbsp;&nbsp;&nbsp;出错的概率不大，但是错误总是需要防范的。当然可以用其他多线程机制实现，但是都没有这样简洁，所以Interlocked…函数有必要提供。</p> <p><br /></p>  【DSP开发】OpenEM简介及OpenEM的大矩阵乘法实现 1454425228350 Text 1dad75de_9d822b1 【DSP开发】 <p>摘要de31d33【中国自动化网社区】d7673f【http://sns.ca800.com】9ba7258</p> <p>OpenEM 的全称是 Open Event Machine。是 TI 针对嵌入式应用开发的 multicore runtime system library。OpenEM 可以在多核上有效的调度，分发任务。它把任务调度给负载轻的核，进而实现动态的负载平衡。OpenEM&nbsp;是基于 TI Keystone 系列芯片的 multicore Navigator 构建的，具有开销小，效率高的特点。本文首先对 OpenEM 的原理做了简单的介绍。然后结合一个大矩阵乘的演示用例详细介绍了 OpenEM 的使用。最后通过量化分析这个演示用例的执行cycle数，总结了 OpenEM 的效率和局限。希望本文能成为学习 OpenEM 的读者的一个有用的参考。d006【中国自动化网社区】a6de22【http://sns.ca800.com】ec723e</p> <p>&nbsp;d006【中国自动化网社区】a6de22【http://sns.ca800.com】ec723e</p> <p>1、OpenEM&nbsp;简介8143d【中国自动化网社区】68727e【http://sns.ca800.com】9f</p> <p>&nbsp;8143d【中国自动化网社区】68727e【http://sns.ca800.com】9f</p> <p>OpenEM&nbsp;的全称是 Open Event Machine。它是 TI 开发的可应用于 Keystone 多核 DSP的multicore runtime system library。OpenEM 的目的是在多核上有效的调度，分发任务，实现动态的负载平衡。基于 OpenEM，用户可以很容易的把原来的单核应用移植到 Keystone 多核芯片。需要注意的是 OpenEM 目前只能把任务调度分发到同一个 DSP 的多个核上，不能跨 DSP调度分发。 OpenEM不依赖于 BIOS。它可以在芯片上裸跑，代码精简，效率高。而且，OpenEM不同于业界已经有 OpenMP 和 OpenCL 等开放式的 multi-core runtime systems。它是针对嵌入式系统的设计，更能满足嵌入式设计的实时性要求。TI 的 keystone 架构多核芯片中有 Multicore Navigator。它由 Queue Manager(简称为 QMSS)和一系列 Packet DMA engine 构成。OpenEM就是基于这套硬件系统构建的。例如，OpenEM&nbsp;的 scheduler 是运行在 QMSS 的 PDSP(QMSS内部的 RISC 处理器)上的。OpenEM的 preload 功能是通过 QMSS 的 packet DMA 实现的。熟悉QMSS&nbsp;的编程对学习 OpenEM 很有帮助。OpenEM&nbsp;是 MCSDK 的一个组件。它还在不断的发展改进中。本文对 OpenEM 的介绍以及演示用例都是基于 BIOS MCSDK 2.01.02 的 OpenEM 1.0.0.2。8143d【中国自动化网社区】68727e【http://sns.ca800.com】9f</p> <p>&nbsp;a8【中国自动化网社区】ef1a9a【http://sns.ca800.com】bc</p> <p>1.1 OpenEM&nbsp;的软件对象a8【中国自动化网社区】ef1a9a【http://sns.ca800.com】bc</p> <p>下面通过列表和图示介绍了 OpenEM的主要软件对象。表 1 是 OpenEM 的主要软件对象的列表。a8【中国自动化网社区】ef1a9a【http://sns.ca800.com】bc</p> <p><br />a8【中国自动化网社区】ef1a9a【http://sns.ca800.com】bc</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956569BUeu.jpg\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Receive function 用来处理接收到的event数据的用户函数，由应用实现f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>需要注意的是，本文介绍的 OpenEM 的运行模式是：Scheduler&nbsp;运行在 PDSP，Dispatcher是“run to completion ”模式。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_13879565693vww.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>图 1 是一个软件对象关系图，显示出了表 1 中列举的软件对象。定义了 2 个 queue group，5个queue 和 3 个 execution object。Queue group1 的 core mask 对应核 0 和 1。所以来自 queue1，2，3，4 的 event 只能在核 0 和核 1 上执行，因为这些 queue 属于 queue group1。Queue group2 的 core mask 对应核 2 和 3。所以来自 queue5 的 event 只能在核 2 和核 3 上执行，因为queue5&nbsp;属于 queue group2。execution object 1 和 queue 1,2,3 映射关联。execution object 2和queue 4 映射关联。execution object 3 和 queue 5 映射关联。图中的蓝线表示了 event 的行径，红线表示&nbsp;command&nbsp;的行径。图中的 SD queue 是 hardware queue，它不是一个软件对象而是OpenEM内部的组件。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>1.2 OpenEM 的两个重要概念f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>OpenEM中有两个容易混淆的重要概念：prefetch&nbsp;和 preload。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>• Prefetch 是指每个 DSP 核向 scheduler 发命令，告诉 scheduler“本核已经空闲了，可以分配新的工作给本核了”。只有收到一个核的 prefetch 命令，scheduler&nbsp;才会调度新的 event 给这个核。如果 DSP 核不发出 prefetch 命令，它就不会被分派任务。这是 OpenEM 的 scheduler的基本调度原则。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>• Preload 和 event 的属性有关。通常，event&nbsp;的数据是位于 DDR 的。如果 DSP 核直接访问DDR&nbsp;效率会比较低。所以，OpenEM&nbsp;可以把 event 的数据通过 QMSS 的 packet DMA 搬到DSP&nbsp;核的 local L2。这个搬移的过程就是 preload。每个 event 的数据是否做 preload 是可配的。每个 event 在创建的时候都可以指定一个 preload 属性。Event&nbsp;的 preload 属性可以是：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>– Preload disable,&nbsp;即不做预搬移f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>– Preload up to sizeA，即做预搬移，但是最多只搬 sizeA bytesf5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>– Preload up to sizeB，即做预搬移，但是最多只搬 sizeB bytesf5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>– Preload up to sizeC，即做预搬移，但是最多只搬 sizeC bytesf5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>–&nbsp;其中 SizeA，SizeB 和 SizeC 是常数，在 OpenEM 初始化的时候可以配置。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>1.&nbsp;3 OpenEM 的常用 API cycle 数f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>OpenEM的附带开销是应用最关注特性之一。所以我们实测了 OpenEM 常用 API 的 cycle数如表2。需要注意的是：由于 OpenEM会负责 cache 一致性的维护，而有些 API 的处理过程中含有cache&nbsp;一致性的维护操作。所以这些 API 的调用 cycle 数很大程度上取决于它对多大的数据缓冲区做了 cache 一致性的维护。本文测试这些 cycle 的场景使用的数据缓冲区的大小是是 4096 words(32bit)。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956570x4vL.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2、基于 OpenEM 的大矩阵乘实现f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>大矩阵相乘的目的是计算 X*Y = Z &nbsp;&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>矩阵 X 是(100&nbsp;&times; 2048 )的浮点实数矩阵。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>矩阵 Y 是(2048&nbsp;&times; 2048 )的浮点实数矩阵。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>矩阵 Z 是(100&nbsp;&times; 2048 )的浮点实数矩阵。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>由于矩阵 Y 的数据量很大，所以在多核 DSP 上可以把它拆分成多个子块，交给多个 DSP 核并行计算。如图 2 所示。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387958042fXxU.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.1 基于 OpenEM 的大矩阵乘方案设计f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.1.1 Memory 使用f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>Shannon DSP (6678)的内存系统包括片内的 LL2(local L2)和 SL2(shared L2)。加上片外的DDR。LL2 的 size 是 512 Kbytes，每个核有一份 LL2。 SL2 的 size 是 4Mbytes，8 个核共享 SL2。DDR size 和硬件板卡设计有关，一般在 1G bytes 以上。 C66x 核对 LL2 的访问效率最高，对 SL2 的访问效率稍差，对 DDR 的访问效率最低。基于多种存储区间的不同特性，我们对数据存储位置按如下规划(参见图 3)：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>–&nbsp;矩阵 X 的 size 是 800 Kbytes，存储是 shared L2f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>–&nbsp;矩阵 Y 的 size 是 16 Mbytes，存储是 DDRf5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>–&nbsp;矩阵 Z 的 size 是 800 Kbytes，存储是 shared L2f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>虽然矩阵 Y 存储在 DDR，但是我们启用了 OpenEM 的 preload 功能。Preload&nbsp;就是通过 QMSS的 packet DMA 把待处理的 event 数据(通常位于 DDR)搬到被调度 core 的 LL2。所以 DSP 核运行的时候不直接从 DDR 取数。这保证了 DSP 核的数据访问效率。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956570o4uC.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.1.2 处理流程f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>OpenEM中要有一个 DSP 核作为主核，其他核就是从核，主核要完成的工作较多。本文的演示用例中，核 0 是主核，核 1～7 是从核。主从核的分工差异如图 4：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;<img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956571n9B9.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>1.&nbsp;初始化 QMSS 和 free pool。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2. OpenEM 的 global 初始化和 local 初始化。global&nbsp;初始化是主核执行。local&nbsp;初始化是每个核各自执行。Local&nbsp;初始化要等 global 初始化完成才能开始。所以，中间需要加一个barrier。Barrier&nbsp;可以理解成一个同步点，所有 DSP 核在这个点完成一次同步再继续向下执行。本演示用例的Barrier&nbsp;是通过共享内存的软件信号量实现的。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>3.&nbsp;主核构造生产者/消费者场景并产生待处理的 event。生产者在 OpenEM 中不是一个软件对象。我们可以把产生 event 并发送到 queue 的函数认为是生产者。消费者就是 execution object，沟通生产者和消费者的管道就是 queue。构造生产者/消费者场景就是创建execution object 和queue&nbsp;并且把它们关联起来。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>4.&nbsp;主核和从核进入 event 处理的过程。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>5.&nbsp;主核检测到所有 event 都处理完成后为每个 DSP 核（包括它自己）产一个 exit job。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>6.&nbsp;主核和从核处理 exit job。从核直接调用 exit(0)退出。主核先做结果验证然后调用 exit(0)退出。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>本文演示用例实现的几个特点是：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>• OpenEM 的 free pool 是由用户初始化的。在初始化 free pool 的时候 event 描述符不指向数据缓冲区。等分配了一个 event 的时候再在这个 event 对应的描述符上挂数据缓冲区。这样可以避免不必要的数据拷贝(从 global buffer 拷贝到 event buffer)。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>•&nbsp;主核通过查询 free pool 中的 event 个数是否恢复回初始值来判断是否所有“矩阵乘 event”都处理。因为：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>– Free pool 在初始化以后有 N 个 free event，f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>–&nbsp;从中分配了若干个 event 后，free event 就减少了相应的个数，f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>–&nbsp;每个 core 每处理完一个 event 就把这个 event 回收到 free pool，free pool 的 event 个数就加一。当 free pool 的 event 个数恢复回 N，就说明所有 event 都处理完了。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.2&nbsp;基于 OpenEM 的大矩阵乘实现f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>在初始化 OpenEM之前首先要做 multicore Navigator 的初始化。包括：PDSP firmware 的download， Link RAM 的初始化， Memory region 的初始化还有 free pool (也就是 free descriptorqueue)的初始化。这不属于本文介绍的范畴，本文直接介绍 OpenEM的初始化。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.2.1 OpenEM 的 Global 初始化f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>OpenEM的 global 初始化通过调用 API 函数 ti_em_init_global()完成的。这个 API 的入参是下面所示的结构体。其中所列的参数是本文的演示用例使用的配置参数。本文针对每个参数的作用做了注释。了解了参数了含义，就能了解 OpenEM 的 global 初始化的大致做了些什么。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956571359P.png\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>注释：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>1. OpenEM要使用 hardware queue 资源。hw_queue_base_idx&nbsp;用来指定&nbsp;OpenEM&nbsp;从哪个hardware queue 开始可用。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2. OpenEM 的少量操作需要多 DSP 核访问共享的数据结构。是通过 hardware semaphore实现多核lock/unclock 的。所以通过 hw_sem_idx 告诉 OpenEM该使用哪一个 hardware semaphore。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>3.&nbsp;指定 preload 使用的 QMSS packet DMA 的通道的起始索引。QMSS packet DMA 有 32个 RX/TX channel。在 OpenEM 中，每个 DSP core 要占用一个 TX/RX channel。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>4.&nbsp;指定 preload 使用的 QMSS Tx queues 的起始索引。要和 dma_idx 对应起来。QMSS&nbsp;有32&nbsp;个 TX queue，索引是 800～831。对应 QMSS packet DMA 的 TX channel 0～31。所以，如果前面配置的 dma_idx 是 0，那么这里配置的 dma_queue_base_idx 应该是 800。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>5.&nbsp;指定 OpenEM local free pool 对应的 free queue index。Local free pool 是和 preload 相关的。local free pool 在物理上是一个 free descriptor queue。里面存储着 2 个 host 描述符。每个描述符对应一个 local L2 buffer。如果发生 preload，packet DMA 就从 free descriptor queue pop 描述符，然后把数据传到描述符指向的 local L2 buffer。每个 DSP 核有一个 local free pool。例如，在我们的演示用例中 core0～7 对应的 free descriptor queue 索引是 2050～2057。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>6.&nbsp;指定 OpenEM global free pool 的个数。每个 global free pool 包括 4 个初始化参数，例如{ globalFreePoolFdqIdx, TI_EM_COH_MODE_ON,TI_EM_BUF_MODE_GLOBAL_TIGHT,0}。参数 1是这个 global free pool 对应的 free queue index。接下来几项是这个 pool 中的 buffer 的属性。Global free pool 是用来从中分配 free event 的。调用 em_alloc()的入参之一就是 free pool index。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>7.&nbsp;配置 preload 门限，参见本文 1.2 节的叙述。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.2.2&nbsp;创建生产者/消费者场景f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>前面介绍过，在 OpenEM 中，消费者就是 execution object，沟通生产者和消费者的管道就是queue。本小节介绍怎样创建 execution object 和 queue 以及怎样把它们关联起来。&nbsp;关于怎样产生event，本文在下一小节描述。OpenEM&nbsp;有下列 API 供应用调用：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>•&nbsp;调用 em_eo_create()可以创建 execution objectf5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>•&nbsp;调用 em_queue_create()可以创建 queuef5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>•&nbsp;调用 em_eo_add_queue()可以把 queue 和 execution object 映射起来f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>本演示用例通过参数配置表列出 execution object, queue group object 和 queue object 的参数，然后通过解析函数解析配置表再调用&nbsp;OpenEM的 API，这样各个软件对象的参数在配置表中一目了然，代码的可读性较好。图 5 是本演示用例的映射关系。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956571NIr7.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956571RQRi.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>需要注意的是 coremask 总共有 64 个比特，但是目前 6678 最多也只有 8 个 DSP 核。所以大量mask&nbsp;比特是用不到的，目前。核 0～7 对应的 mask 比特是位于 byte[4]的 bit0：7f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;<img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956571ZxRt.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>需要注意的是 queue 到 execution object 的映射是通过 receiver 函数关联起来，如红色高亮显示部分。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>初始化job的伪代码如下：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;<img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956571858h.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.2.3 产生 eventf5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>本文的演示用例把 matrix Y 切分成了 128 个 2048*16 的子块，每个 event 对应一个子块。Event被发送给 execution object 以后，receive&nbsp;函数计算 Matrix X 乘与 matrix Y block，即 100*2048&times;2048*16 的矩阵乘，产生 100*16 个输出。event&nbsp;的产生包括下面几个简单步骤：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>•&nbsp;调用 em_alloc 函数，从 public pool 获取 free 的 event 描述符并且 enable preloading。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>•&nbsp;把待处理的数据缓冲区挂到描述符上，也就是把描述符的 buffer 指针指向这个数据缓冲区。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>•&nbsp;在描述符的 software info 域填上 job index。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>•&nbsp;调用 em_send，把 event 发送到对应的 queue，也就是 proc queue。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>下面是产生 event 的代码：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_13879567370K00.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>需要注意的是 Event 产生的时候，它被哪一个 execution object 处理还没有确定。因为 execution object 只是和 queue 关联的。当把 event 发送到一个 queue 的时候，负责处理 event 的 execution object 就确定了。所以在调用 em_send()发送 event 到 queue 的时候参数之一就是要发送到的queue&nbsp;的 handler。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.2.4 运行和 exitf5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>如前所述，“矩阵乘 event”是通过 proc queue 发给 scheduler 的，所以它被 proc queue 映射到mat_mpy calc 这个 execution object 上。Dispatcher&nbsp;收到这个 event 后就调用“mat_mpy calc”对应的 receiver 函数计算矩阵相乘。因为 proc queue 所属的 queue group 是映射到所有 DSP 核的，所以 128 个“矩阵乘 event”是在所有核上并行处理的。每个核处理完 event 后就把它释放回global free pool。这样这个 event 又成为一个 free 的 event。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>如 2.2.3 节所述，主核可以通过查询 global free pool 的描述符个数是否恢复来判断是否所有“矩阵乘 event”已经处理完。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>当所有“矩阵乘 event”处理完后，主核再产生 8 个“exit event”发送到 exit queue。理论上scheduler 可以把 exit job 调度给任意一个核，而不会保证每个核一个 exit job。所以 exit job 中的处理比较特殊。exit job 的 receiver 函数直接执行系统调用 exit(0)。这样就不会返回到 Dispatcher，也不会再发出 prefetch command。而另一方面，scheduler 是在收到 DSP 核的 prefetch command 以后才把 event 调度给这个核的。这个机制保证了每个核收到且仅收到一个“exit event”。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>在 exit job 的 receiver 函数中，主核执行的分支稍有差异。主核需要先做完结果的校验再执行系统调用 exit(0)。所以在板上运行是会观察到其他核很快(小于 1s)就从 run 状态转换到 abort 状态，而主核保持 run 了很长时间(大约 50s)才进入 abort 状态。原因是：在主核上执行结果验证工作时产生校验结果的函数计算耗时比较长。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>下面是 exit job 的 receiver 函数的代码主干：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_13879567375sZX.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.3 基于 OpenEM 的大矩阵乘性能测试结果f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.3.1&nbsp;算法代码和 cycle 数的理论极限f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>设 r1 是 X 矩阵的行数，c1&nbsp;是 X 矩阵的列数，c2&nbsp;是 Y 矩阵的列数。在我们的演示用例中 r1 =100, c1 = 2048, c2 = 2048。如前所述，Receiver 函数要计算 100*2048 &times; 2048*16 的矩阵乘，对应下面的伪代码：f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956737cg9j.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>循环内核是 4 个 cycle。&nbsp;如果只考虑循环内核消耗的 cycle 数，计算 100*2048 &times; 2048*16 的矩阵乘需要的 cycle 数是 100/2*16/2*2048/4*4 = 819,200 cycle。整个 X*Y=Z 包括计算 128 个这样的矩阵乘。所以总的 cycle 数是 819,200*128 = 104,857,600 cycles。在 1Ghz 的 C66 核上这相当于104.8ms。但是我们的上述理论计算没有考虑循环的前后缀消耗的 cycle 数，也没有考虑 cache miss stall 的等待时间。在 6678EVM 板的单个 DSP 核上实测，计算 X*Y=Z 消耗的实际时间是190,574,214 cycles。相当于 190ms。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>2.3.2 基于 OpenEM 的性能测试结果f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>基于 OpenEM的演示用例实现过程中，DSP 代码中嵌入了少量测试代码收集运行的 cycle 信息。每个核把自己处理每个 event 的起始和结束时间记录在内存(我们通过一个全局 timer 来保证所有DSP&nbsp;核记录的时间戳在时间轴上是同步的)。这些时间戳用 CCS 存到主机做后处理分析。通过分析，我们可以得到 8 个 DSP 核并行处理消耗的时间。还可以分析每个 DSP 核的忙/闲区间。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>测试结果是，从第一个 event 开始处理到最后一个 event 处理完，总时间是 31,433,438 cycle，也就是 31.4ms。也就是说，通过 OpenEM把单 DSP 核的工作负载平衡到 8 个 DSP 核上能达到的DSP&nbsp;核利用率是 190,574,214/(31,433,438*8)= 76%。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>通过对时间戳的处理我们得到下面的运行图，“-”表示 receiver 函数处理 event 的区间，本文称之为有效时间。“#”表示 receiver 之外的区间（也就是代码在 dispatcher 中执行的区间），本文称之为调度开销。每个“-”和“#”刻度表示 100,000 CPU cycle。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p><img src=\"http://sns.ca800.com/attachment/201312/25/46239_1387956738OtQz.jpg\" style=\"max-width:500px;\" />f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>从上面的执行图看，调度开销不小，占了大约 15～20%的时间。但是这只是表面的现象。实际上，调度开销的大部分时间里，Dispatcher 是在查询 hardware queue，等待新的 event。这是因为preload 没能及时完成导致的。因为同时给 8 个核做 preload 需要很大的数据搬移的流量。根据以往的测试结果。使用 QMSS 的 packet DMA 从 DDR3 输入数据到 local L2 的流量大约是 4G bytes 每秒。那么 preload 8 个 event 总的数据量是 4byte * 2048 rows * 16 columns * 8 core = 1M bytes，需要的时间是 1/4 ms。因为每个“-”和“#”刻度表示 100,000 CPU cycle，运行图中红线长度就代表 preload 8 个 event 的时间，它非常接近 250,000 cycle。理论计算和实际值基本吻合，所以我们认为调度延迟是 packet DMA 的传输流量不足导致的。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>我们也测试了不使用 pre-load 的场景。观测到 scheduler 调度一个 event 的延迟大约是 1200个C66 CPU cycle。但是 DSP 核处理一个 event 的耗时增大到原来的 10 倍。所以，pre-load&nbsp;虽然会导致 QMSS packet DMA 流量不足成为凸显的瓶颈，但是从总体效率来看还是非常必要的。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>细心的读者可能会发现 76%&nbsp;+ 20%&nbsp;= 96%，并不是 100%。我们分析时间戳发现，8 个 DSP 核同时运行的场景下，每个核处理一个 100*2048 &times; 2048*16 的矩阵乘的时间比只有一个 DSP 核运行的场景下的时间稍长。原因是：&nbsp;我们的演示用例中 X 矩阵和 Z 矩阵是存储在 shared L2的， 8 个核同时运行就会同时读写这两个 buffer，导致产生 shared L2 的 bank 冲突。&nbsp;所以性能下降了。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>3、总结f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>OpenEM具有使用简单，功能实用，执行高效的特点。能在 KeyStone 多核 DSP 上实现动态的负载平衡。它一方面提供了强大的功能，另一方面也给应用留出了很大的灵活性。例如，通过让应用初始化 free pool 方便了 buffer 的管理。OpenEM&nbsp;的现有功能已经能够支持基本的应用。随着版本更新功能还将不断完善。f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>&nbsp;f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>Referencef5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>f5【中国自动化网社区】05928d【http://sns.ca800.com】3f8c423</p> <p>Ref[1]&nbsp;&nbsp; ti.openem.white.paper.pdf 位于 OpenEM 安装目录f5【中国自动</p> <p><br /></p>  【编程开发】GPU通用计算调研 1454400318924 Text 1dad75de_9d65faf 【编程开发】 <p><strong>摘要：</strong>NVIDIA公司在1999年发布GeForce256时首先提出GPU（图形处理器）的概念，随后大量复杂的应用需求促使整个产业蓬勃发展至今。GPU在这十多年的演变过程中，我们看到GPU从最初帮助CPU分担几何吞吐量，到Shader（着色器）单元初具规模，然后出现Shader单元可编程性，到今天GPU通用计算领域蓬勃发展这一清晰轨迹。本报告首先根据搜集到的资料记录GPU通用计算的发展过程中硬件和软件的演变，然后介绍并简要比较现在比较流行的GPU通用计算编程模型，最后对GPU通用计算在不同领域的成功应用进行概述。</p> <p><strong>关键词</strong>：GPU&nbsp;&nbsp;GPU通用计算&nbsp;&nbsp;可编程单元&nbsp;&nbsp;编程模型&nbsp;&nbsp;GPGPU应用</p> <p>&nbsp;</p> <p><strong>1</strong><strong>、</strong><strong>GPU</strong><strong>通用计算的背景和动机</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPU英文全称Graphic Processing Unit，中文翻译为“图形处理器”。GPU从诞生之日起就以超越摩尔定律的速度发展，运算能力不断提升。业界很多研究者注意到GPU进行计算的潜力，于2003年SIGGRAPH大会上提出了GPGPU（<strong>General-purpose computing on graphics processing units</strong>）的概念。GPU逐渐从由若干专用的固定功能单元（Fixed Function Unit）组成的专用并行处理器向以通用计算资源为主，固定功能单元为辅的架构转变。</p> <p>&nbsp;</p> <p><strong>1.1&nbsp;&nbsp;&nbsp;</strong><strong>为什么要用GPU</strong><strong>进行计算</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPU在处理能力和存储器带宽上相对于CPU有明显优势，在成本和功耗上也不需要付出太大代价。由于图形渲染的高度并行性，使得GPU可以通过增加并行处理单元和存储器控制单元的方式提高处理能力和存储器带宽。GPU设计者将更多的晶体管用作执行单元，而不是像CPU那样用作复杂的控制单元和缓存并以此来提高少量执行单元的执行效率[1]。图1&nbsp;对CPU与GPU中的逻辑架构进行了对比。</p> <p><img src=\"http://pic002.cnblogs.com/images/2011/316473/2011071823004069.jpg\" style=\"max-width:500px;\" /><br /></p> <p><strong>图1</strong>&nbsp;CPU和GPU逻辑架构对比</p> <p>CPU的整数计算、分支、逻辑判断和浮点运算分别由不同的运算单元执行，此外还有一个浮点加速器。因此，CPU面对不同类型的计算任务会有不同的性能表现。而GPU是由同一个运算单元执行整数和浮点计算，因此，GPU的整型计算能力与其浮点能力相似。目前，主流GPU都采用了统一架构单元，凭借强大的可编程流处理器阵容，GPU在单精度浮点运算方面将CPU远远甩在身后[1]。最顶级的英特尔Core i7 965处理器，在默认情况下，它的浮点计算能力只有NVIDIA GeForce GTX 280的1/13，与AMD Radeon HD 4870相比差距就更大。</p> <p><img src=\"http://pic002.cnblogs.com/images/2011/316473/2011071823010042.gif\" style=\"max-width:500px;\" /><br /></p> <p><strong>图</strong><strong>2</strong> CPU 和 GPU 的每秒浮点运算次数和存储器带宽</p> <p>GPU运算相对于CPU还有一项巨大的优势，那就是其内存子系统，也就是GPU上的显存[1]。当前桌面级顶级产品3通道DDR3-1333的峰值是32GB/S，实测中由于诸多因素带宽在20 GB/S上下浮动。AMD HD 4870 512MB使用了带宽超高的GDDR5显存，内存总线数据传输率为3.6T/s或者说107GB/s的总线带宽。NVIDIA GTX280使用了高频率GDDR3显存，但是其显存控制器支持的位宽达到了512bit，搭载16颗0.8ns GDDR3显存，带宽高达惊人的142GB/s。而主流GPU普遍拥有40-60 GB/s显存带宽。存储器的超高带宽让巨大的浮点运算能力得以稳定吞吐，也为数据密集型任务的高效运行提供了保障。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有，从GTX200和HD 4870系列GPU开始，AMD和NVIDIA两大厂商都开始提供对双精度运算的支持，这正是不少应用领域的科学计算都需要的。NVIDIA公司最新的Fermi架构更是将全局ECC（Error Checking and Correcting）、可读写缓存、分支预测等技术引入到GPU的设计中，明确了将GPU作为通用计算核心的方向。</p> <p>GPU通用计算被越来越多的采用，除了GPU本身架构的优越性，市场需求也是重要的原因。比如很多企业或科研单位无法布置昂贵的的计算机集群，而大部分普通用户PC上装配的GPU使用率很低，提高GPU利用率的有效途径就是将软件的部分计算任务分配到GPU上，从而实现高性能、低功耗的最终目标。</p> <p><strong>1.2 </strong><strong>什么适合GPU</strong><strong>进行计算</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管GPU计算已经开始崭露头角，但GPU并不能完全替代X86解决方案，很多操作系统、软件以及部分代码现在还不能运行在GPU上，所谓的GPU+CPU异构超级计算机也并不是完全基于GPU进行计算。一般而言适合GPU运算的应用有如下特征[2]：</p> <p>•&nbsp;运算密集。</p> <p>•&nbsp;高度并行。</p> <p>•&nbsp;控制简单。</p> <p>•&nbsp;分多个阶段执行。</p> <p>符合这些条件或者是可以改写成类似特征的应用程序，就能够在GPU上获取较高的性能。</p> <p>&nbsp;</p> <p><strong>2</strong><strong>、</strong><strong>GPU</strong><strong>通用计算的前世今生</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPU通用计算其实是从GPU渲染管线发展来的。GPU渲染管线的主要任务是完成3D模型到图像的渲染工作。常用的图形学API（DirectD/OpenGL）编程模型中渲染过程被分成几个可以并行处理的阶段，分别由GPU中渲染管线的不同单元进行处理。在GPU渲染管线的不同阶段，需要处理的对象分别是顶点(Vertex)、几何图元（primitive）、片元（fragment）、像素（pixel）。图形渲染过程具有内在的并行性：顶点之间、图元之间、片元之间的数据相关性很弱，对它们的计算可以独立并行进行，这使得通过并行处理提高吞吐量成为可能[3]。这儿不对GPU渲染管线进行详细介绍，而是着重于介绍GPU可编程器件和编程模型的发展历程。</p> <p>&nbsp;</p> <p><strong>2.1&nbsp;GPU</strong><strong>可编程器件的发展</strong></p> <p>1999年8月，<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.pconline.com.cn/so/s17738/\" >NVIDIA</a>正式发表了具有跨世纪意义的产品NV10——GeForce 256。GeForce256是业界第一款<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.pconline.com.cn/so/s15117/\" >256bit</a>的GPU，也是全球第一个集成T&amp;L（Transforming&amp;Lighting几何光照转换）、动态光影、三角形设置/剪辑和四像素渲染等3D加速功能的图形引擎。通过T&amp;L技术，显卡不再是简单像素填充机以及多边形生成器，它还将参与图形的几何计算从而将<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.pconline.com.cn/cpu/\" >CPU</a>从繁重的3D管道几何运算中解放出来。可以说，T&amp;L技术是显卡进化到GPU的标志。</p> <p>从某种意义上说，GeForce 256开创了一个全新的3D图形时代，再到后来GeForce 3开始引入可编程特性，能将图形硬件的流水线作为流处理器来解释，基于GPU的通用计算也开始出现。GeForce3被用于实现矩阵乘法运算和求解数学上的扩散方程，这是GPU通用计算的早期应用。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;研究人员发现，要实现更加复杂多变的图形效果，不能仅仅依赖三角形生成和硬件T&amp;L实现的固定光影转换，而要加强顶点和像素运算能力。Shader（着色器）就是在这样的背景下提出的。Pixel Shader（顶点着色器）和Vertex Shader（像素着色器）的硬件逻辑支持可编程的像素和顶点，虽然当时可编程性很弱，硬件限制太多，顶点部分出现可编程性，像素部分可编程性有限，但这的确是硬件T&amp;L之后PC图形技术的又一重大飞跃。3D娱乐的视觉体验也因此向接近真实迈进了一大步。可编程管线的引入，也为GPU发展翻开了新的篇章，GPU开始向SIMD（Single Instruction Multiple Data，单指令多数据流）处理器方向发展，凭借强大的并行处理性能，使得GPU开始用有了部分流式处理器特征。</p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>随后到来的DirectX[1] 9.0时代，让Shader单元具备了更强的可编程性。2002年底微软发布的DirectX 9.0中，Pixel Shader单元的渲染精度已达到浮点精度，传统的硬件T&amp;L单元也被取消。全新的Vertex Shader编程将比以前复杂得多，新的Vertex Shader标准增加了流程控制，更多的常量，每个程序的着色指令增加到了1024条。</p> <p>Shader Model 2.0时代突破了以前限制PC图形图像质量在数学上的精度障碍，它的每条渲染流水线都升级为128位浮点颜色，让游戏程序设计师们更容易更轻松的创造出更漂亮的效果，让程序员编程更容易。而从通用性方面理解，支持浮点运算让GPU已经具备了通用计算的基础，这一点是至关重要的。</p> <p>图形流水线中可编程单元的行为由Shader单元定义，着色器的性能由DirectX中规定的Shader Model来区分，并可以由高级的Shading语言（例如NV的Cg，OpenGL的GLSL，Microsoft的HLSL）编写。Shader源码被译为字节码，然后在运行时由驱动程序将其转化为基于特定GPU的二进制程序，具备可移植性好等优势。传统的图形渲染流线中有两种不同的可编程着色器，分别是顶点着色单元（Vertex Shader，VS）和像素着色单元（Pixel Shader，PS）。</p> <p>在Shader Model 4.0之前，VS和PS两种着色器的架构既有相同之处，又有一些不同。两者处理的都是四元组数据（顶点着色器处理用于表示坐标的w、x、y、z，但像素着色器处理用于表示颜色的a、r、g、b），顶点渲染需要比较高的计算精度；而像素渲染则可以使用较低的精度，从而可以增加在单位面积上的计算单元数量。传统的分离架构中，两种着色器的比例往往是固定的。在GPU核心设计完成时，各种着色器的数量便确定下来，比如著名的“黄金比例”——顶点着色器与像素着色器的数量比例为1：3。但不同的游戏对顶点资源和像素资源的计算能力要求是不同的。如果场景中有大量的小三角形，则顶点着色器必须满负荷工作，而像素着色器则会被闲置；如果场景中有少量的大三角形，又会发生相反的情况。因此，固定比例的设计无法完全发挥GPU中所有计算单元的性能。</p> <p>Shader Model 4.0统一了两种着色器，顶点和像素着色器的规格要求完全相同，都支持32位浮点数。这是GPU发展的一个分水岭。过去只能处理顶点和只能处理像素的专门处理单元被统一之后，更加适应通用计算的需求，应用程序调用着色器运算能力的效率也更高。</p> <p>DirectX 11提出的Shader Model 5.0版本继续强化了通用计算的地位，微软提出的全新API—Direct Compute将把GPU通用计算推向新的巅峰。同时Shader Model 5.0是完全针对流处理器而设定的，所有类型的着色器，如：像素、顶点、几何、计算、Hull和Domaim（位于Tessellator前后）都将从新指令集中获益[4]。</p> <p>着色器的可编程性也随着架构的发展不断提高，下表给出每代模型的大概特点[1]。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>表</strong><strong>1</strong>&nbsp;&nbsp;Shader Model版本</p> <p>&nbsp;</p> <p><strong>2.2 </strong><strong>AMD</strong><strong>与</strong><strong>NVIDIA</strong><strong>最新</strong><strong>GPU</strong><strong>架构比较</strong></p> <p>在图形计算领域，NVIDIA和ATI/AMD把持着民用市场的绝大部分份额和大部分专用市场。为了抢占更大的市场，两家公司不断曾经改进自家GPU的架构以实现更逼真的3D效果，现在他们同样代表了GPU通用计算的方向，这儿对两家公司最新的GPU架构进行简单的分析和比较。</p> <p>AMD的最新GPU架构是RV870，又被命名为Cypress，采用了第二代“TeraScale 2”核心架构。RV870包括流处理器在内的所有核心规格都比上一代架构RV770翻了一倍，也就是“双核心”设计，几乎是并排放置两颗RV770核心，另外在装配引擎内部设计有两个Rasterizer（光栅器）和Hierarchial-Z（多级Z缓冲模块），以满足双倍核心规格的胃口。RV870的晶体管数量的达到了21亿个，流处理器也从RV770时代的800个扩充到了1600个，每个流处理器单元的“1大4小”结构包括一个全功能SP单元和4个能执行乘加运算的SP[5]。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NVIDIA的最新GPU架构是GF100，又被命名为Fermi，这是NVIDIA为了抢占GPU通用计算性能制高点和完整支持DirectX 11而设计的架构。GF100拥有三层分级架构：4个GPC（Graphics Processing Clusters，图形处理图团簇）、16个SM（Streaming Multiprocessors，流阵列多处理器）、512个CUDA核心。每个GPC包括4个SM，每个SM包括32个CUDA核心。一个完整的的GF100还有6个内存控制器（Memory Controller）。GF100核心，除具备前一代架构GT200的L1纹理缓存之外，还拥有真正意义的可读写L1缓存和L2缓存。GF100的晶体管数量达到了30亿个，可以认为GF100是一颗4核心（GPC）处理器，因为GPC几乎是一颗全能的处理器[6]。</p> <p>两种架构最明显的区别就是流处理器结构。RV870选择延续上一代非统一执行架构GPU产品的SIMD结构，用庞大的规模效应压制对手，偏向于ILP（Instruction-Level Parallelism，指令并行度）方向，而GF100则使用了G80以来创新的MIMD（Multiple Instruction Multiple Data）架构，更偏重于TLP（Thread-Level Parallelism，线程并行度）方向。在单指令多数据流（SIMD）的结构中，单一控制部件向每条流水线分派指令，同样的指令被所有处理部件同时执行。另一种控制结构多指令多数据流（MIMD）中，每条流水线都能够独立于其他流水线执行不同的程序。MIMD能比较有效率地执行分支程序，而SIMD体系结构运行条件语句时会造成很低的资源利用率。TLP要求强大的仲裁机制，丰富的共享cache和寄存器资源以及充足的发射端，这些都是极占晶体管的部件，幸好Fermi架构在增大缓存和分支论断上迈出了坚实的一步。</p> <p><img src=\"http://pic002.cnblogs.com/images/2011/316473/2011071823014376.jpg\" style=\"max-width:500px;\" /></p> <p><strong>图</strong><strong>3 </strong>NVIDIA和AMD使用了两种不同的流处理器架构</p> <p>两种架构的另一个不同在于它们的缓存配置，虽然在在RV870与GF100上，我们都看到了一级缓存与二级缓存的设计。AMD RV870提供了32KB的LDS（Local Data Store），作用类似于NVIDIA传统的shared memory，但是目前的资料来看这个LDS并不具备配置为硬件cache的能力。GF100同时提供了shared memory 和 cache，并允许程序员选择对它们的划分。GF100的每个 SM 都有 64KB 可配置为 48KB shared memory + 16KB L1 cache 或者 16KB shared memory + 48KB L1 cache的高速片上RAM。AMD的RV870提供了 64KB Global Data Shared，本质上是一个可读写的cache，可用于各个SIMD Core之间的数据交换。GF100提供了768KB的一体化L2 cache，这个L2 cache为所有的Load/Store以及纹理请求提供高速缓存，对所有的SM来说L2 cache上的数据都是连贯一致的，从L2 cache读取到的数据就是最新的数据。RV870的L2 cache则不能提供GF100中 L2 Cache共享内核间数据的特性。</p> <p>还有一个不同是两家厂商选择了不同的最小线程执行粒度。粒度越细，能够调用并行度来进行指令延迟掩盖的机会越大，性能衰减越小。细化粒度偏向TLP方向，对GPU的线程仲裁机制要求很大，最终会导致硬件开销过大。GPU通用计算中最小的执行单位是线程（Thread），多个线程会被打包成一个线程束，NVIDIA称线程束为Warp，AMD称之为Frontwave。Frontwave包含64个线程，NVIDIA的线程管理粒度更小，每个Warp包含32个线程。RV870每凑够64个线程，仲裁器就会动作一次，把一个Frontwave发送给空闲的一个SIMD Core。NVIDIA的GF100比较特殊，还存在Half-Warp，也就是说每16个线程就可以发送给SM一次。Half-Warp由线程中的前16个线程或者后16个线程组成。</p> <p>还要提到的是GF100架构首次在GPU中引入全局ECC（Error Checking and Correcting内存错误检查和修复）。在使用GPU做大数据量的处理和高性能计算的时候，ECC有大量的需求，尤其在医疗图像处理和大型集群中，ECC是非常有用的特性。</p> <p>总体来说，两家厂商的差异在于：AMD堆砌了更大规模的运算器单元，NVIDIA则更注重如何利用有限的运算器资源。AMD将更多的晶体管消耗在大量的SIMD Core单元上，NVIDIA则将更多的晶体管消耗在仲裁机制、丰富的共享缓存资源和寄存器资源以及充足的发射端方面。AMD的GPU偏向于ILP结构，NVIDIA偏向于TLP结构。TLP（线程并行度）考验线程能力和并行能力，ILP（指令并行度）则考验指令处理。</p> <p>&nbsp;</p> <p><strong>2.3 GPU</strong><strong>通用计算编程模型</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPU通用计算通常采用CPU+GPU异构模式，由CPU负责执行复杂逻辑处理和事务处理等不适合数据并行的计算，由GPU负责计算密集型的大规模数据并行计算。这种利用GPU强大处理能力和高带宽弥补CPU性能不足的计算方式在发掘计算机潜在性能，在成本和性价比方面有显著的优势。在2007年NVIDIA推出CUDA（Compute Unified Device Architecture，统一计算设备架构）之前，GPU通用计算受硬件可编程性和开发方式的制约，开发难度较大。2007年以后，CUDA不断发展的同时，其他的GPU通用计算标准也被相继提出，如由Apple提出Khronos Group最终发布的OpenCL，AMD推出的Stream SDK，Microsoft则在其最新的Windows7系统中集成了DirectCopmute以支持利用GPU进行通用计算。</p> <p><strong>2.3.1 </strong><strong>传统GPU</strong><strong>通用计算开发</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最早的GPGPU开发直接使用图形学API编程。这种开发方式要求程序员将数据打包成纹理，将计算任务映射为对纹理的渲染过程，用汇编或者高级着色语言（如GLSL，Cg，HLSL）编写shader程序，然后通过图形学API（Direct3D、OpenGL）执行。2003年斯坦福大学的Ian Buck等人对ANSI C进行扩展，开发了基于NVIDIA Cg的Brook源到源编译器。Brook可以将类似C的brook C语言通过brcc编译器编译为Cg代码，隐藏了利用图形学API实现的细节，大大简化了开发过程。但早期的Brook编译效率很低，并且只能使用像素着色器（Pixel Shader）进行运算。受GPU架构限制，Brook也缺乏有效的数据通信机制。AMD在其GPGPU通用计算产品Stream中采用Brook的改进版本Brook+作为高级开发语言。Brook+的编译器工作方式与Brook不同，提高了效率[7]。</p> <p><strong>2.3.2 CUDA –C/C++</strong><strong>及其SDK</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2007年6月，NVIDIA推出了CUDA技术。CUDA是一种将GPU作为数据并行计算设备的软硬件体系，硬件上NVIDIA GeForce 8系列以后的GPU（包括GeForce、ION、Quadro、Tesla系列）已经采用支持CUDA的架构，软件开发包上CUDA也已经发展到CUDA Toolkit 3.2（截止到2010年11月），并且支持Windows、Linux、MacOS三种主流操作系统。CUDA采用比较容易掌握的类C语言进行开发，而且正在开发适用于CUDA架构的用于科学计算的Fortran版本。无论是CUDA C-语言或是OpenCL，指令最终都会被驱动程序转换成PTX（Parallel Thread Execution，并行线程执行，CUDA架构中的指令集，类似于汇编语言）代码，交由显示核心计算[8]。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CUDA编程模型将CPU作为主机（Host），GPU作为协处理器（co-processor）或者设备（Device）。在一个系统中可以存在一个主机和若干个设备。CPU、GPU各自拥有相互独立的存储地址空间：主机端内存和设备端显存。CUDA对内存的操作与一般的C程序基本相同，但是增加了一种新的pinned memory；操作显存则需要调用CUDA API存储器管理函数。一旦确定了程序中的并行部分，就可以考虑把这部分计算工作交给GPU。运行在GPU上的CUDA并行计算函数称为kernel（内核函数）。一个完整的CUDA程序是由一系列的设备端kernel函数并行步骤和主机端的串行处理步骤共同组成的。这些处理步骤会按照程序中相应语句的顺序依次执行，满足顺序一致性。</p> <p><img src=\"http://pic002.cnblogs.com/images/2011/316473/2011071823015742.gif\" style=\"max-width:500px;\" /><br /></p> <p><strong>图4</strong>&nbsp;异构编程模型</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CUDA SDK提供的API分为CUDA runtime API（运行时API）和CUDA driver API（驱动程序API）。CUDA runtime API在CUDA driver API的基础上进行了封装，隐藏了一些实现细节，编程更加方便。CUDA runtime API函数前都有CUDA前缀。CUDA driver API是一种基于句柄的底层接口，可以加载二进制或汇编形式的kernel模块，指定参数并启动运算。CUDA driver API编程复杂，但有时能通过直接操作硬件的执行实现一些更加复杂的功能或者获得更高的性能。由于它使用的设备端代码是二进制或者汇编代码，因此可以在各种语言中调用。CUDA driver API所有函数的前缀为cu。另外CUDA SDK也提供了CUFFT（CUDA Fast Fourier Transform，基于CUDA的快速傅立叶变换）、CUBLAS（CUDA Basic Linear Algebra Subprograms，基于CUDA的基本矩阵与向量运算库）和CUDPP（CUDA Data Parallel Primitives，基于CUDA的常用并行操作函数）等函数库，提供了简单高效的常用函数供开发者直接使用。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从CUDA Toolkit3.0开始支持NVIDIA最新的Fermi架构，最大程度上利用Fermi架构在通用计算方面的优势。CUDA 3.0也开始支持C++的继承和模板机制提高编程灵活性，同时CUDA C/C++内核现在以标准ELF格式进行编译，开始支持硬件调试，还增加了一个新的Direct3D、OpenGL统一协作API，支持OpenGL纹理和Direct3D 11标准，支持所有的OpenCL特征。</p> <p>&nbsp;</p> <p><strong>2.3.3 OpenCL</strong></p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>OpenCL&nbsp;(Open&nbsp;Computing Language，开放计算语言)&nbsp;是一个为异构平台编写程序的框架，此异构平台可由CPU、GPU或其他类型的处理器组成。OpenCL由用于编写kernels&nbsp;（在OpenCL设备上运行的函数）的语言（基于C99）和一组用于定义并控制平台的API组成。OpenCL提供了基于任务分区和数据分区的并行计算机制。</p> <p>OpenCL最初由Apple公司开发，Apple拥有其商标权，并在与AMD，IBM，Intel和NVIDIA技术团队的合作之下初步完善。随后，Apple将这一草案提交至Khronos Group。2008年6月16日，Khronos的通用计算工作小组成立。5个月后的2008年11月18日，该工作组完成了OpenCL 1.0规范的技术细节。该技术规范在由Khronos成员进行审查之后，于2008年12月8日公开发表。2010年6月14日，OpenCL 1.1 发布[9]。</p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>OpenCL也是基于C的一个程式语言，分为Platform Layer、Runtime、Compiler三个部分：<strong>Platform Layer</strong>用来管理计算装置，提供启始化装置的界面，并用来建立compute contexts和work-queues。<strong>Runtime</strong>用来管理资源，并执行程序的kernel。<strong>Compiler</strong>则是ISO C99的子集合，并加上了OpenCL特殊的语法。在OpenCL的执行模型中，有所谓的Compute Kernel和Compute Program。 Compute Kernel基本上类似于CUDA定义的kernel，是最基本的的计算单元；而Compute Program则是Compute Kernel和内建函数的集合，类似一个动态函数库。很大程度上OpenCL与CUDA Driver API比较相像。</p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>自从2008年12月NVIDIA在SIGGRAPH Asia大会上在笔记本电脑上展示全球首款OpenCL GPU演示以来，AMD、NVIDIA、Apple、RapidMind、Gallium3D、ZiiLABS、IBM、Intel先后发布他们自己的OpenCL规范实现（当一台机器上存在不同厂家的支持OpenCL的设备时，这样也给开发应用程序带来不统一的一些麻烦）。除了AMD和NVIDIA，其他厂商如S3、VIA等也纷纷发布他们支持OpenCL的硬件产品[10]。</p> <p>&nbsp;</p> <p><strong>2.3.4 DirectCopmute</strong></p> <p>Directcompute是一种由Microsoft开发和推广的用于GPU通用计算的应用程序接口，集成在Microsoft DirectX内，允许Windows Vista或Windows 7平台上运行的程序利用GPU进行通用计算。虽然DirectCompute最初在DirectX 11 API中得以实现，但支持DX10的GPU可以利用此API的一个子集进行通用计算（DirectX 10内集成Directcompute 4.0，DirectX 10.1内集成Directcompute 4.1），支持DirectX11的GPU则可以使用完整的DirectCompute功能（DirectX 11内集成Directcompute 5.0）。Directcompute和OpenCL都是开放标准，得到NVIDIA CUDA架构和ATI Stream技术的支持。</p> <p>Windows 7增加了视频即时拖放转换功能，可以将电脑中的视频直接转换到移动媒体播放器上，如果电脑中的GPU支持Directcompute，那么这一转换过程就将由GPU完成。其转换速度将达到CPU的5-6倍。Internet Explorer 9加入了对Directcompute技术的支持，可以调用GPU对网页中的大计算量元素做加速计算，另外Excel2010、Powerpoint2010均提供Directcompute技术支持[11]。</p> <p>&nbsp;</p> <p><strong>2.3.5 Stream SDK</strong></p> <p>AMD的流计算模型其实也包含了流处理器架构和相应的软件包。AMD在2007年12月发布运行在Windows XP系统下的Steam SDK v1.0,&nbsp;此SDK采用了Brook+作为开发语言，Brook+是AMD对斯坦福大学开发的Brook语言（基于ANSI C）的改进版本。Stream SDK为开发者提供对系统和平台开放的标准以方便合作者开发第三方工具。软件包包含了如下组件：支持Brook+的编译器，支持流处理器的设备驱动CAL（Compute Abstraction Layer），程序库ACML(AMD Core Math Library)以及内核函数分析器。</p> <p><img src=\"http://pic002.cnblogs.com/images/2011/316473/2011071823022585.jpg\" style=\"max-width:500px;\" /><br /></p> <p><strong>图</strong><strong>5 </strong>AMD流计算软件系统之间的关系</p> <p>在Stream编程模型中，在流处理器上执行的程序称为kernel（内核函数），每个运行在SIMD引擎的流处理器上的kernel实例称为thread（线程），线程映射到物理上的运行区域称为执行域。流处理器调度线程阵列到线程处理器上执行，直到所有线程完成后才能运行下一个内核函数。</p> <p>Brook+是流计算的上层语言，抽象了硬件细节，开发者编写能够运行在流处理器上的内核函数，只需指定输入输出和执行域，无需知道流处理器硬件的实现。Brook+语言中两个关键特性是：Stream和Kernel。Stream是能够并行执行的相同类型元素的集合；Kernel是能够在执行域上并行执行的函数。Brook+软件包包含brcc和brt。brcc是一个源语言对源语言的编译器，能够将Brook+程序翻译成设备相关的IL（Intermediate Language），这些代码被后续链接、执行。brt是一个可以执行内核函数的运行时库，这些库函数有些运行在CPU上，有些运行在流处理器上。运行在流处理器上的核函数库又称为CAL（Compute Abstraction Layer）。CAL是一个用C编写的设备驱动库，允许开发者在保证前端一致性的同时对流处理器核心从底层进行优化。CAL提供了设备管理、资源管理、内核加载和执行、多设备支持、与3D 图形API交互等功能。同时，Stream SDK也提供了常用数学函数库ACML（AMD Core Math Library）供开发者快速获得高性能的计算。ACML包括基本完整的线性代数子例程、FFT运算例程、随机数产生例程和超越函数例程[12]。</p> <p>面对NVIDIA在GPU通用计算上的不断创新，AMD也不甘示弱，不断改进自己的Stream SDK。截止到2010年11月，AMD发布了Stream SDK v2.2，能够在WindowsXP SP3、Windows 7和部分Linux发行版上运行，开始支持OpenCL 1.1规范和双精度浮点数操作。</p> <p>&nbsp;&nbsp;</p> <p><strong>3</strong><strong>、</strong><strong>GPU</strong><strong>通用计算的应用领域</strong></p> <p>从SIGGRAPH 2003大会首先提出GPU通用计算概念，到NVIDIA公司2007年推出CUDA平台，GPU通用计算依靠其强大的计算能力和很高的存储带宽在很多领域取得了成功。越来越多的信号告诉我们，GPU通用计算是一片正在被打开的潜力巨大的市场[13]。</p> <p>GPGPU项目研究中的先行者是英国剑桥大学的BionicFx课题组。早在2004年9月，剑桥大学的BionicFx课题组便宣布在NVIDIA的GeForce FX 5900产品中实现了专业的实时音频处理功能，并且准备进行商业化的运作，对其产品进行销售，给音乐创作者带来实惠。在随后的一段时间，GPGPU进入了深入研究阶段，但是由于编程语言架构和编程环境都难以通用，该领域的发展能力受到广泛质疑。就在人们认为GPGPU的研究即将偃旗息鼓的时候，ATI在2006年8月惊人地宣布即将联手斯坦福大学在其Folding@Home项目中提供对ATI Radeon X1900的支持。在显卡加入Folding@Home项目后，科研进展速度被成倍提升，人们第一次感受到了GPU的运算威力。</p> <p>毫无疑问，在GPGPU研究上，ATI跨出了极具意义的一步。同时将GPGPU的应用领域和普及程度推向高潮。随后NVIDIA凭借GeForce 8800GTX这款业界首个DirectX 10 GPU，在GPU通用计算方面实现了大步跨越，特别是CUDA概念的提出（该工具集的核心是一个C语言编译器），在新的通用计算领域后来居上。</p> <p>下面对GPU通用计算在各个领域的成功应用做一个概述。</p> <p><img src=\"http://pic002.cnblogs.com/images/2011/316473/2011071823024166.jpg\" style=\"max-width:500px;\" /><br /></p> <p><strong>图</strong><strong>6</strong>&nbsp;不同项目使用CUDA后获得的加速比</p> <p><strong>3.1 </strong><strong>常见软件</strong></p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>最新版本的MATLAB 2010b中Parallel Computing Toolbox与MATLAB Distributed Computing Server的最新版本可利用NVIDIA的CUDA并行计算架构在NVIDIA计算能力1.3以上的GPU上处理数据，执行GPU加速的MATLAB运算，将用户自己的CUDA Kernel函数集成到MATLAB应用程序当中。另外，通过在台式机上使用Parallel Computing Toolbox以及在计算集群上使用MATLAB Distributed Computing Server来运行多个MATLAB worker程序，从而可在多颗NVIDIA GPU上进行计算[14]。AccelerEyes公司开发的Jacket插件也能够使MATLAB利用GPU进行加速计算。Jacket不仅提供了GPU API（应用程序接口），而且还集成了GPU MEX功能。在一定程度说，Jacket是一个完全对用户透明的系统，能够自动的进行内存分配和自动优化。Jacket使用了一个叫“on-the- fly”的编译系统，使MATLAB交互式格式的程序能够在GPU上运行。目前，Jacket只是基于NVIDIA的CUDA技术，但能够运行在各主流操作系统上[15]。</p> <p>Photoshop虽然已经支持多核心处理器，但在某些时候的速度仍然让人抓狂，比如打开一个超大文件，或者应用一个效果复杂的滤镜。从Photoshop CS4开始，Adobe将GPU通用计算技术引入到自家的产品中来。GPU可提供对图像旋转、缩放和放大平移这些常规浏览功能的加速，还能够实现2D/3D合成，高质量抗锯齿，HDR高动态范围贴图，色彩转换等。而在Photoshop CS5中，更多的算法和滤镜也开始支持GPU加速。另外，Adobe的其他产品如Adobe After Effects CS4、Adobe Premiere Pro CS4也开始使用GPU进行加速。这些软件借助的也是NVIDIA的CUDA技术[16]。</p> <p>下一代主流操作系统 Windows 7 的核心组成部分包括了支持GPU通用计算的Directcompute API，为视频处理、动态模拟等应用进行加速。Windows 7借助Directcompute增加了对由GPU支持的高清播放的in-the-box支持，可以流畅观看，同时CPU占用率很低。Internet Explorer 9加入了对Directcompute技术的支持，可以调用GPU对网页中的大计算量元素做加速计算；Excel2010、Powerpoint2010也开始提供对Directcompute技术的支持。</p> <p><strong>&nbsp;</strong></p> <p><strong>3.2 </strong><strong>高性能计算</strong></p> <p>超级计算机一般指在性能上居于世界领先地位的计算机，通常有成千上万个处理器以及专门设计的内存和I/O系统。它们采用的架构与通常的个人计算机有很大区别，使用的技术也随着时代和具体应用不断变动。GPU通用计算提出以后，不断有超级计算机开始安装GPU以提高性能。2010年9月，全球超级计算机领军企业Cray公司正式宣布，该公司将为Cray XE6系列产品开发基于NVIDIA Tesla20系列GPU的刀片服务器。2010年11月揭晓的世界上最快的超级计算机top500列表中，最快的5个系统中有3个使用了NVIDIA的Tesla型号GPU产品，其中中国国防科技大学研发的“天河一号”荣膺榜首，最快运算速度达到2.507 petaflops。2009年10月29日完成的“天河一号”一期系统有3072颗Intel Quad Core Xeon E5540 2.53GHz和3072颗Intel Quad Core Xeon E5450 3.0GHz以及2560块AMD Radeon HD 4870 X2，峰值性能为每秒1206万亿次（top500中排名第5）。2010年10月，升级优化后的“天河一号”，配备了14336颗Xeon X5670处理器（32nm工艺，六核12线程，2.93GHz主频），7168块基于NVIDIA Fermi架构的Tesla M2050计算卡（主频1.15GHz，双精度浮点性能515Gflops、单精度浮点性能1.03Tflops）以及2048颗国防科技大学研制的飞腾处理器（八核64线程，主频1GHz），峰值性能每秒 4700万亿次、持续性能每秒2507万亿次（LINPACK实测值）。</p> <p>计算机集群（简称集群）是一种通过松散集成的计算机软件和硬件连接起来高度紧密地完成计算工作的系统，采用将计算任务分配到集群的不同计算节点而提高计算能力，主要应用在科学计算领域。比较流行的集群采用Linux操作系统和其它一些免费软件来完成并行运算。</p> <p>2006年10月，全球最大的分布式计算项目——Folding@home中提供对ATI Radeon X1900的支持后，任何一台个人电脑都可以下载客户端参与，科研进展速度被成倍提升。该项目可精确地模拟蛋白质折叠和错误折叠的过程，以便能更好地了解多种疾病的起因和发展。在目前的大约10万台参与该项目的计算机中，仅有的11370颗支持CUDA的GPU提供总计算能力的一半，而运行Windows的CPU共计208268颗，却只能提供该项目总能力的约6%的计算[1]。</p> <p>早在2007年，AMAX，Supermicro等公司就已经开始探索和研究GPU用于服务器和集群。时至今日，AMAX已成为集<a target=\"_blank\" rel=\"nofollow\" href=\"http://detail.zol.com.cn/cpu_index/subcate28_list_1.html\" >CPU</a>+GPU塔式<a target=\"_blank\" rel=\"nofollow\" href=\"http://detail.zol.com.cn/server_index/subcate31_list_1.html\" >服务器</a>、<a target=\"_blank\" rel=\"nofollow\" href=\"http://detail.zol.com.cn/cabinet_index/subcate467_list_1.html\" >机柜</a>式服务器、CPU+GPU集群等几十种系列产品的生产和销售为一体的一站式GPU解决方案供应商，可以满足不同领域科研群体的计算需求。AMAX GPU集群相对于传统CPU集群产品，可以以十分之一的价格，二十分之一的功耗，获得20-150倍的计算性能提高和60%的空间节余。AMAX采用NVIDIA支持大规模并行计算的CUDA架构GPU，支持IEEE 754单精度和双精度浮点计算，支持CUDA编程环境、多种编程语言和API，包括C、C +&nbsp;+、OpenCL、DirectCompute或Fortran，支持ECC、NVIDIA Parallel DataCache 技术，以及NVIDIA GigaThread引擎技术，支持异步传输和系统监控功能[17]。目前众多科研机构和公司（如哈佛大学、中国科学院、剑桥大学、英国航空公司等等）都已经架设了基于NVIDIA Tesla（支持CUDA）系列GPU的通用计算机集群。2010年7月，AMD也宣称其合作伙伴，荷兰公司ClusterVision，已经开始利用其新一代的Opteron处理器（12核心CPU）和FireStream图形计算加速卡组建服务器集群。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;云计算指服务的交付和使用模式，通过网络以按需、易扩展的方式获得所需的服务。&nbsp;“云”是一些可以自我维护和管理的虚拟计算资源，通常为一些大型<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.pcpop.com/Server/00000_1.html\" >服务器</a>集群，包括计算<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.pcpop.com/Server/00000_1.html\" >服务器</a>、存储<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.pcpop.com/Server/00000_1.html\" >服务器</a>、宽带资源等等。此前的种种云计算，都是通过网络传输<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.pcpop.com/CPU/00000_1.html\" >CPU</a>的运算能力，为客户端返回计算结果或者文件；而GPU云计算则偏重于图形渲染运算或大规模并行计算。2009年10月，NVIDIA联合Mental Images公司推出基于GPU的云计算平台RealityServer，利用Tesla RS硬件和<a target=\"_blank\" rel=\"nofollow\" href=\"http://server.zdnet.com.cn/files/list-0-0-236027-1-1.htm\" >RealityServer</a> 3.0软件，为PC、笔记本、上网本、智能手机提供逼真的交互式3D图形渲染服务。2010年11月，Amazon与NVIDIA宣布推出基于亚马逊集群GPU计算实例(Amazon Cluster GPU Instances)的EC2（弹性计算云）服务[18]，亚马逊GPU集群实例提供了22GB的存储容量，33.5 个EC2计算单元，并且利用亚马逊 EC2集群网络为高性能计算和数据集中处理提供了很高的吞吐量和低延迟。每一个GPU实例都配有两个NVIDIA Tesla(R) M2050 GPU，提供了甚至超过每秒100万兆次的双精度浮点计算的超高的性能。通过GPU实例的数百个内核并行处理能力，许多工作负载可以被大大加速。</p> <p>&nbsp;</p> <p><strong>3.3 </strong><strong>信号与图像处理</strong></p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>很多信号与图像处理算法的计算密度非常高，随着GPU通用计算的快速发展，越来越多的算法实现了在GPU上运行，获得令人满意的加速。在NVIDIA推出CUDA技术之前，尽管开发不方便，不少研究者利用图形API和各种Shader语言（HLSL、GLSL、Cg等）实现了一些图像分割、CT图像重建、快速傅立叶变换、图像以及音视频编解码等算法。AMD的Brook+尤其是CUDA技术的推出极大地方便了在GPU上开发信号与图像处理并行算法。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AMD的Stream SDK和NVIDIA 的CUDA SDK发布时就包含了各自经优化后的基本线性代数例程（BLAS）和快速傅立叶变换库（FFT）。2008年Georgia Tech的Andrew Kerr等开发了基于CUDA平台的VSIPL（Vector Signal Image Processing Library）[19]，支持向量和矩阵运算，快速FIR（Finite Impulse Response，有限冲击响应）滤波，矩阵的QR分解等；2009年6月，NVIDIA又发布了专注于图像和视频处理的库NPP（NVIDIA Performing Primitives），对一些统计函数、JPEG编解码、滤波函数、边缘检测算法进行了封装[20]；2010年8月，TunaCode宣布对NPP库进行扩展，推出了CUVI Lib（CUDA for Vision and Imaging Lib），增加了NPP中不包含的一些高级计算机视觉和图像处理算法，如光流法、离散小波变换、Hough变换、颜色空间转换等[21]。另外，2010年9月，Graz大学的研究人员发布了专用于图像边缘分割的GPU4Vision库，用GPU实现图像分割算法的加速[22]。NVIDIA主导的OpenVIDIA项目在2010年6月发布了CUDA VisionWorkbench v 1.3.1.0，里面使用OpenGL，Cg，CUDA-C等语言，而且支持OpenCL和DirectCompute的例子会于近期添加，该项目实现了立体视觉、光流法、特征跟踪的一些算法[23]。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在特征提取领域，瑞典的Marten Bjorkman和美国北卡罗来纳大学的Wu等实现了基于CUDA的SIFT（Lowe's Scale Invariant Feature Transform，尺度不变特征）的提取[24]；北卡罗来纳州立大学的Christopher Zach等则在GPU上实现KLT算法用于视频中的特征跟踪。在机器学习领域，斯坦福大学的Rajat Raina等在GPU上实现了大规模深度无监督算法DBNs（Deep Belief Networks）和稀疏编码（Sparse Coding）算法；谷歌上的开源项目multisvm则基于CUDA实现了SVM（Support Vector Machine，支持向量机）的多分类器，实验表明加速效果明显[25]。</p> <p>另外值得一提的是，医学成像是最早利用 GPU计算加快性能的应用之一，GPU通用计算在这一领域的应用日趋成熟，当前许多医学成像领域的算法已在GPU上实现。Digisens和Acceleware AxRecon已经分别开发出能够利用GPU进行计算的用于X线CT和电子断层摄影术的3D成像软件和在无损图像质量的情况下可实时重建图像的软件。Techniscan的开发人员在其新一代全乳房超声波成像系统中将其专有的逆向散射算法在CUDA平台上实现，获得很高的加速比。东京大学Takeyoshi Dohi教授与他的同事则在其实时医疗成像的裸眼立体成像系统中使用GPU加速体绘制过程和后期文件格式转换。另外，比利时安特卫普大学，通用电气医疗集团，西门子医疗，东芝中风研究中心和纽约州立大学水牛城分校的都针对GPU加速CT重建进行了各自的研究，不仅如此，西门子医疗用GPU实现了加速MRI中的GRAPPA自动校准，完成MR重建，快速MRI网格化，随机扩散张量磁共振图像（DT-MRI）连通绘图等算法。其他的一些研究者则把医学成像中非常重要的二维与三维图像中器官分割（如Level Set算法），不同来源图像的配准，重建体积图像的渲染等也移植到GPU上进行计算。</p> <p>&nbsp;</p> <p><strong>3.4 </strong><strong>数据库与数据挖掘</strong></p> <p>面对当前海量增加的数据，搜索数据库并找到有用信息已经成为一个巨大的计算难题。学术界以及微软、Oracle、SAP等公司的研究人员正在研究利用GPU的强大计算能力来找到一款可扩展的解决方案。</p> <p>加利福尼亚大学的Santa Cruz等（现任职于Oracle）比较早地提出把GPU强大的运算能力应用于数据库技术。2009年Oracle的Blas, Tim Kaldewey 在IEEE Spectrum上著文分析为什么图形处理器将彻底改变数据库处理（Why graphics processors will transform database processing），在另一篇文章中他们探索了利用GPU实现并行的搜索算法[27]，如并行二分搜索和P-ary搜索；更多的研究者如深圳先进技术研究院和香港中文大学的S. Chen，P. A. Heng，加州伯克利大学的Nadathur Satish[28]，微软研究院的Naga K. Govindaraju等[29]，瑞典的Erik Sintorn等[30]则研究了在GPU上实现高效率的并行排序算法。香港科技大学的Bingsheng He等研究了使用GPU进行查询协同处理[31]。</p> <p>在数据挖掘领域，HP实验室的Wu，Zhang，Hsu等研究了使用GPU对商业智能分析进行加速[32]。福尼吉亚理工大学的Sean P. Ponce在其硕士论文中应用算法转换于临时数据挖掘，使其数据并行化，更适合在GPU上实现加速[33]。北卡罗来纳州立大学的Y. Zhang和美国橡树岭国家实验室的X. Cui联合研究了利用CUDA加速文本挖掘，开发了优化的文本搜索算法[34]。马里兰大学的Schatz，Trapnel等开发的Cmatch和MUMmerGPU[35][36]，在GPU上实现了高效的的后缀树算法，能够对一系列查询字符串及其子串进行并行搜索，从而进行快速准确的字符串匹配。香港科技大学的Fang和微软亚洲研究院的He等开发了一个小工具GPUMiner，实现了K-均值聚类算法和先验频率模式挖掘算法，用CPU对控制数据I/O和CPU与GPU之间的数据传输，用CPU和GPU联合实现并行算法并提供可视化界面[26]。</p> <p>另有一些研究者正在研究将Map-Reduce架构扩展到GPU上实现。香港科技大学的Bingsheng He 和Wenbin Fang在单GPU上开发的Mars，目前已经包含字符串匹配，矩阵乘法，倒序索引，字词统计，网页访问排名，网页访问计数，相似性评估和K均值等8项应用，能够在32与64位的linux平台下运行[37]。德克萨斯大学的Alok Mooley等也在分布式的GPU网络上实现了功能类似的系统DisMaRC[38]。加州伯克利大学的Bryan Catanzaro等则在基于CUDA实现的Map-Reduce框架下实现了SVM（Support Vector Machine，支持向量机）的训练和分类。</p> <p>&nbsp;</p> <p><strong>4</strong><strong>、总结和展望</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPU拥有超高的计算密度和显存带宽，CPU+GPU混合架构凭借其高性能、低功耗等优势在许多领域有优异的表现。巨大的运算能力让人们对GPU充满期待，似乎在一夜之间，GPU用于通用计算（General Purpose GPU）及其相关方面的问题成为一个十分热门的话题。视频编解码应用、矩阵运算及仿真、医疗行业应用、生命科学研究等需要大量重复的数据集运算和密集的内存存取，纷纷利用GPU实现了比CPU强悍得多的计算能力[39]。</p> <p>展望未来GPU发展，以下几个问题是必须解决的。首先是分支预测能力，GPU需要拥有更好的分支能力，才能运行更多复杂程序，更好的利用cache来掩盖分支的延迟；然后是更大的缓存和Shared memory（AMD称之为LDS ，Local Data Share），这种共享寄存器负责共享数据和临时挂起线程，容量越大，线程跳转和分支能力就越强；线程粒度同样重要，粒度越细能够调用并行度来进行指令延迟掩盖的机会越大，性能衰减越小，而细化粒度对GPU的线程仲裁机制要求很大。</p> <p>GPU发展到今天，已经突破了无数技术屏障，最初因图形处理而诞生的硬件发展成为今天大规模并行计算领域的明星。我们完全可以相信GPU的架构还会不断优化，并被越来越多的大型计算所采用。</p> <p>&nbsp;</p> <p><strong>参考文献：</strong></p> <p>[1]&nbsp;张舒,褚艳丽等著, GPU高性能计算之CUDA,&nbsp;中国水利水电出版社, 2009</p> <p>[2] John D. Owens, Mike Houston,et al,GPU Computing, Proceedings of the IEEE, Vol. 96, No. 5, May 2008</p> <p>[3] GPGPU website,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://gpgpu.org/\" >http://gpgpu.org/</a></p> <p>[4] 10年GPU通用计算回顾,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/172/1721480.html\" >http://vga.zol.com.cn/172/1721480.html</a></p> <p>[5] Programming Guide:ATI Stream Computing,</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://developer.amd.com/gpu/ATIStreamSDK/assets/ATI_Stream_SDK_CAL_Programming_Guide_v2.0%5B1%5D.pdf\" >http://developer.amd.com/gpu/ATIStreamSDK/assets/ATI_Stream_SDK_CAL_Programming_Guide_v2.0%5B1%5D.pdf</a></p> <p>[6]&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.nvidia.com/content/PDF/fermi_white_papers/NVIDIA_Fermi_Compute_Architecture_Whitepaper.pdf\" >Fermi Compute Architecture White Paper</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.nvidia.com/content/PDF/fermi_white_papers/NVIDIA_Fermi_Compute_Architecture_Whitepaper.pdf\" >http://www.nvidia.com/content/PDF/fermi_white_papers/NVIDIA_Fermi_Compute_Architecture_Whitepaper.pdf</a></p> <p>[7] John D. Owens1, David Luebke, et al, A Survey of General-Purpose Computation on Graphics Hardware, COMPUTER GRAPHICS forum, Volume 26 (2007), number 1 pp. 80–113</p> <p>[8] NVIDIA CUDA Programming Guide</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://developer.download.nvidia.com/compute/cuda/2_0/docs/NVIDIA_CUDA_Programming_Guide_2.0.pdf\" >http://developer.download.nvidia.com/compute/cuda/2_0/docs/NVIDIA_CUDA_Programming_Guide_2.0.pdf</a></p> <p>[9] OpenCL Website,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.khronos.org/opencl/\" >http://www.khronos.org/opencl/</a></p> <p>[10]&nbsp;维基百科OpenCL Website,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://en.wikipedia.org/wiki/OpenCL\" >http://en.wikipedia.org/wiki/OpenCL</a></p> <p>[11]&nbsp;百度百科DirectCompute Website,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/3245449.html?fromTaglist\" >http://baike.baidu.com/view/3245449.html?fromTaglist</a></p> <p>[12]&nbsp;Technical Overview:ATI Stream Computing,</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://developer.amd.com/gpu_assets/Stream_Computing_Overview.pdf\" >http://developer.amd.com/gpu_assets/Stream_Computing_Overview.pdf</a></p> <p>[13]&nbsp;维基百科GPGPU Website,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://en.wikipedia.org/wiki/GPGPU\" >http://en.wikipedia.org/wiki/GPGPU</a></p> <p>[14] Matlab Parallel Computing,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.mathworks.com/products/parallel-computing/\" >http://www.mathworks.com/products/parallel-computing/</a></p> <p>[15] Jacket Website,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.accelereyes.com/\" >http://www.accelereyes.com/</a></p> <p>[16]&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.nvidia.com/object/builtforadobepros.html\" >http://www.nvidia.com/object/builtforadobepros.html</a></p> <p>[17]&nbsp;AMAX GPU集群开创高性能计算新纪元,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://server.zol.com.cn/189/1891144.html\" >http://server.zol.com.cn/189/1891144.html</a></p> <p>[18]&nbsp;Announcing Cluster GPU Instances for Amazon EC2,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://aws.amazon.com/ec2/\" >http://aws.amazon.com/ec2/</a></p> <p>[19] GPU VSIPL: High-Performance VSIPL Implementation for GPUs</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://gpu-vsipl.gtri.gatech.edu/\" >http://gpu-vsipl.gtri.gatech.edu/</a></p> <p>[20] NVIDIA Performance Primitives (NPP) Library</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://developer.nvidia.com/object/npp_home.html\" >http://developer.nvidia.com/object/npp_home.html</a></p> <p>[21] CUDA Vision and Imaging Library,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cuvilib.com/\" >http://www.cuvilib.com/</a></p> <p>[22] GPU4Vision,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://gpu4vision.icg.tugraz.at/\" >http://gpu4vision.icg.tugraz.at/</a></p> <p>[23] OpenVIDIA: Parallel GPU Computer Vision</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://openvidia.sourceforge.net/index.php/OpenVIDIA\" >http://openvidia.sourceforge.net/index.php/OpenVIDIA</a></p> <p>[24] SiftGPU: A GPU Implementation of Scale Invariant Feature Transform (SIFT)</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cs.unc.edu/~ccwu/siftgpu/\" >http://www.cs.unc.edu/~ccwu/siftgpu/</a></p> <p>[25] Multisvm Website,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://code.google.com/p/multisvm/\" >http://code.google.com/p/multisvm/</a></p> <p>[26] GPUMiner Website,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://code.google.com/p/gpuminer/\" >http://code.google.com/p/gpuminer/</a></p> <p>[27] Parallel Search On Video Cards</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.usenix.org/event/hotpar09/tech/full_papers/kaldeway/kaldeway.pdf\" >http://www.usenix.org/event/hotpar09/tech/full_papers/kaldeway/kaldeway.pdf</a></p> <p>[28] Nadathur Satis, et al, Designing Efﬁcient Sorting Algorithms for Manycore GPUs, 23rd IEEE International Parallel and Distributed Processing Symposium, May 2009</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://mgarland.org/files/papers/gpusort-ipdps09.pdf\" >http://mgarland.org/files/papers/gpusort-ipdps09.pdf</a></p> <p>[29]&nbsp;Naga K. Govindaraju, et al, GPUTeraSort:High Performance Graphics Coprocessor Sorting for Large Database Management, Microsoft Technical Report 2005</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://research.microsoft.com/pubs/64572/tr-2005-183.pdf\" >http://research.microsoft.com/pubs/64572/tr-2005-183.pdf</a></p> <p>[30] Erik Sintorn, et al, Fast Parallel GPU-Sorting Using a Hybrid Algorithm,</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cse.chalmers.se/~uffe/hybridsort.pdf\" >http://www.cse.chalmers.se/~uffe/hybridsort.pdf</a></p> <p>[31] GPUQP: Query Co-Processing Using Graphics Processors,&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cse.ust.hk/gpuqp/\" >http://www.cse.ust.hk/gpuqp/</a></p> <p>[32] Ren Wu, et al, GPU-Accelerated Large Scale Analytics, HP Laboratories</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.hpl.hp.com/techreports/2009/HPL-2009-38.pdf\" >http://www.hpl.hp.com/techreports/2009/HPL-2009-38.pdf</a></p> <p>[33] Sean P. Ponce, Towards Algorithm Transformation for Temporal Data Mining on GPU, Master Thesis of Sean P. Ponce, Virginia Polytechnic Institute and State University</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://scholar.lib.vt.edu/theses/available/etd-08062009-133358/unrestricted/ponce-thesis.pdf\" >http://scholar.lib.vt.edu/theses/available/etd-08062009-133358/unrestricted/ponce-thesis.pdf</a></p> <p>[34] Yongpeng Zhang, Frank Mueller, et al, GPU-Accelerated Text Mining, EPHAM’09</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://moss.csc.ncsu.edu/~mueller/ftp/pub/mueller/papers/epham09.pdf\" >http://moss.csc.ncsu.edu/~mueller/ftp/pub/mueller/papers/epham09.pdf</a></p>[35] Cmatch: Fast Exact String Matching on the GPU, <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cbcb.umd.edu/software/cmatch/\" >http://www.cbcb.umd.edu/software/cmatch/</a> <p>[36]&nbsp;MUMmerGPU: High-throughput sequence alignment using Graphics Processing Units</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://sourceforge.net/apps/mediawiki/mummergpu/index.php?title=MUMmerGPU\" >http://sourceforge.net/apps/mediawiki/mummergpu/index.php?title=MUMmerGPU</a></p> <p>[37] Mars: A MapReduce Framework on Graphics Processors</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cse.ust.hk/gpuqp/Mars.html\" >http://www.cse.ust.hk/gpuqp/Mars.html</a></p> <p>[38] DisMaRC: A Distributed Map Reduce framework on CUDA</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cs.utexas.edu/~karthikm/dismarc.pdf\" >http://www.cs.utexas.edu/~karthikm/dismarc.pdf</a></p> <p>[39] NVIDIA行业软件解决方案，<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.nvidia.cn/object/vertical_solutions_cn.html\" >http://www.nvidia.cn/object/vertical_solutions_cn.html</a></p> <p><br /></p> <p>[1]&nbsp;DirectX并不是一个单纯的图形API，它是由微软公司开发的用途广泛的API，它包含有Direct Graphics(Direct 3D+Direct Draw)、Direct Input、Direct Play、Direct Sound、Direct Show、Direct Setup、Direct Media Objects等多个组件，它提供了一整套的多媒体接口方案。只是其在3D图形方面的优秀表现，让它的其它几个组件几乎被人们忽略。</p> <p><br /></p>  超越图形界限 AMD并行计算技术全面解析 1454398788449 Text 1dad75de_9d65f70 【科普杂谈】 <p>本文导航</p> <ul> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1927855\" >第1页：全文导读与内容简介</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929440\" >第2页：前言：通过GPU见证行业变革</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929441\" >第3页：第一章：GPU工作原理与并行计算</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929442\" >第4页：21世纪视觉需求与GPU变化</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929443\" >第5页：从山峰渲染了解GPU图形流水线</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929444\" >第6页：CPU与GPU的设计方向决定运算能力</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929445\" >第7页：GPU并行编程为何加速发展</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929446\" >第8页：GPU并行计算已成未来趋势</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929447\" >第9页：初识高性能并行计算</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929448\" >第10页：高性能并行计算发展历程</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929449\" >第11页：高性能并行计算单元分类</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929450\" >第12页：初识基于GPU系统的云计算</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929451\" >第13页：第二章：GPU结构与ATI产品发展</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929452\" >第14页：统一着色器架构释放GPU运算能力</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929453\" >第15页：传统GPU发展与着色器管线</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929454\" >第16页：传统SIMD结构流处理器指令细节</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929455\" >第17页：MIMD结构流处理器指令细节</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929456\" >第18页：R600时代对SIMD架构补充与优化</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929457\" >第19页：两种结构流处理器优劣对比</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929458\" >第20页：R300以来的芯片架构及其影响</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929459\" >第21页：ATI第一代统一渲染架构Xenos</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929460\" >第22页：统一渲染GPU R600临危受命</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929461\" >第23页：AMD对GPU架构的不断改进和优化</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929462\" >第24页：未来ATI图形芯片架构预测</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929463\" >第25页：第三章：GPU通用计算发展与细节</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929464\" >第26页：多核并行计算困惑与发展</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929465\" >第27页：基于AMD CPU+GPU异构计算平台</a></p></li> </ul> <ul> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929466\" >第28页：着色器模型变化历程与总结</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929467\" >第29页：Shader计算能力快速发展</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929468\" >第30页：揭秘GPU高性能计算关键</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929469\" >第31页：CPU与GPU的区别和发展方向</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929470\" >第32页：如何将GPU功能单元映射为通用单元</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929471\" >第33页：分支对GPU结构体系的挑战</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929472\" >第34页：GPU与CPU将如何演绎融合与吞并</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929473\" >第35页：第四章：GPU内部计算实现细节</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929474\" >第36页：GPU主要计算单元分布和职能</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929475\" >第37页：GPU内部通用计算代码运算过程</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929476\" >第38页：认识GPU浮点计算精度</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929477\" >第39页：整数运算能力与未来融合架构</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929478\" >第40页：GPU存储体系特点与变化</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929479\" >第41页：ATI GPU吞吐特性对比与分析</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929480\" >第42页：ATI GPU OPEN CL综合性能分析</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929481\" >第43页：先进混合架构之Larrabee展望</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929482\" >第44页：概念型融合架构之Fusion APU展望</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929483\" >第45页：GPU进化架构之Fermi分析</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929484\" >第46页：第五章：ATI GPU通用计算实例</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929485\" >第47页：ATI Stream技术发展与现状</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929486\" >第48页：OPEN CL接口技术与异构运算</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929487\" >第49页：Havok引擎与CPU+GPU异构运算</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929488\" >第50页：BOINC平台充沛的ATI GPU加速项目</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929489\" >第51页：最具影响力的Folding@home项目</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929490\" >第52页：GPU架构对于其他实例的适应性</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://vga.zol.com.cn/192/1927855_all.html#p1929491\" >第53页：全文总结与未来架构展望</a></p></li> </ul> <p><br /></p>  【DSP开发】TI高性能DSP6678 1454378958951 Text 1dad75de_9d55a41 【DSP开发】 <p>如何在提高运算速度的同时降低功耗，是很多工程师面临的难题，就像我们希望花山寨机的钱买来iphone一样，这也是一个难题，但是这个难题在目前还没有解决方法，但是前面的难题，<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/TI\" >TI</a>刚刚推出的<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/DSP\" >DSP</a>产品<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/TMS320C6678\" >TMS320C6678</a>就能够解决HPC开发工程师的难题。</p>本文引用地址： <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/article/126306.htm\" >http://www.eepw.com.cn/article/126306.htm</a> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/TMS320C6678\" >TMS320C6678</a>采用KeyStone多核架构，是目前业界最高性能的量产多核<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/DSP\" >DSP</a>，具有8个1.25GHz<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/DSP\" >DSP</a>内核，可在10W功耗下实现160GFLOP的性能，其性能是任何已推出多核DSP的5倍，为开发人员带来了业界性能最高、功耗最低的DSP。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/TI\" >TI</a>的多核DSP能够在提高性能的同时能够将功耗降下来呢？德州仪器半导体技术（上海）有限公司通用DSP业务发展经理郑小龙先生表示，主要是因为采用了<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/TI\" >TI</a>的SmartReflex技术。SmartReflex技术是由一系列智能和自适应硬件和软件组成的，可以根据设备活动、操作模式和温度来动态控制电压、频率和功率，<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/TMS320C6678\" >TMS320C6678</a>通过SmartReflex技术可以动态降低DSP内核电压。据郑先生介绍，DSP内核电压稍微降低，比如从1V降低到0.9V，就能够带来很可观的功耗降低。此为TMS320C6678高性能和低功耗兼具的秘诀。<br /><br /><img src=\"http://editerupload.eepw.com.cn/201111/5a043154610c4755a07509398a542849.png\" style=\"max-width:500px;\" /><br /><br /><strong>德州仪器半导体技术（上海）有限公司通用DSP业务发展经理郑小龙<br /><br /><img src=\"http://editerupload.eepw.com.cn/201111/f283db49c465f0887b6de47771791180.png\" style=\"max-width:500px;\" /><br /><br />图一&nbsp;&nbsp;高性能与低功耗秘诀在于SmartReflex</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了简化工程师开发并且帮助他们进一步发挥C66x多核DSP的全部性能优势，TI提供一系列高稳健多核软件、工具以及低成本评估板（EVM），设计人员可采用TMDSEVM6678L启动C6678多核DSP的开发。该EVM包含免费多核软件开发套件（MCSDK）、Code Composer Studio集成型开发环境（IDE）以及应用/演示代码套件，可帮助编程人员快速启动新平台开发。<br /><br /><img src=\"http://editerupload.eepw.com.cn/201111/d4f5065b79d24af98a3f47b2ee6142a0.png\" style=\"max-width:500px;\" /><br /><br /><strong>图二&nbsp;&nbsp;强大的开发工具助力HPC开发更简单</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TMS320C6678采用40纳米CMOS工艺，能够满足很多DSP目标应用的小型化需求。郑先生表示，目前来看新兴宽带和医疗影像是C66x市场份额最大的，但是测试与自动化和高性能计算会是接下来几年内增长最为迅速的份额。C6678瞄准的就是高性能计算市场，云计算已经成为当下发展的热点，未来对于云端小型化和低功耗的要求会越来越高，C6678会担起重任。<br /><br /><img src=\"http://editerupload.eepw.com.cn/201111/d0dc18af8a55426bb867209898d7ae33.png\" style=\"max-width:500px;\" /><br /><br /><strong>图三&nbsp;&nbsp; C66x广阔的目标市场</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当被问及DSP最多能够发展到多少个核的时候，郑先生说，“起码32个核是能够预见的”，至于能够发展到多少个核，估计得要看未来市场的需求了。即将于明年提供样片的TCI6609多内核DSP将为开发人员带来4倍于C6678的性能，可在32W功耗下实现512GFLOP的性能，这两款产品的发布，会使DSP成为HPC的理想解决方案。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C6678的价格大概在100多美金，还是比较实惠的。</p> <p><br /></p>  【DSP开发】RTSC以及XDCtools介绍与应用 1454243331193 Text 1dad75de_9d106cb 【DSP开发】 <p>RTSC以及XDCtools介绍与应用</p> <p>2014年09月05日&nbsp;⁄&nbsp;综合&nbsp;⁄&nbsp;共 3641字⁄&nbsp;字号&nbsp;<a target=\"_blank\" rel=\"nofollow\" >小</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" >中</a>&nbsp;<a target=\"_blank\" rel=\"nofollow\" >大</a>&nbsp;⁄&nbsp;评论关闭</p> <p>﻿﻿</p> <p>RTSC(RTSC, pronounced &quot;rit-see&quot;)是一个基于C的编程模型，用于开发创建或实施嵌入式平台实时软件组件。XDCtools包含使用RTSC的工具和运行时组件。</p> <p>网站：<a target=\"_blank\" rel=\"nofollow\" href=\"http://rtsc.eclipse.org/docs-tip/Main_Page\" ><span style=\"text-decoration:underline;\" >http://rtsc.eclipse.org/docs-tip/Main_Page</span></a></p> <p>XDC(eXpress DSP Components)是一个为嵌入式实时系统提供可重用组件（称作：包）的标准。</p> <p>XDC includes tools and standards forAPI development, static configuration, and packaging.</p> <p>RTSC用户被分成&quot;consumers&quot;<br />and &quot;producers.&quot;&nbsp;Consumers<br />integrate target content packages—DSP algorithms,device drivers, TCP/IP stacks, real-time OSes, and so on—into their ownapplications. Producers create the packages used by consumers.</p> <p><img src=\"http://img.blog.csdn.net/20140416135423734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvODExMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" style=\"max-width:500px;\" /></p>Command line： <p>XDCtools仅有两个核心命令：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://rtsc.eclipse.org/docs-tip/Command_-_xdc\" ><span style=\"text-decoration:underline;\" >xdc</span></a>&nbsp;-<br />which is used to produce packages, and</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://rtsc.eclipse.org/docs-tip/Command_-_xs\" ><span style=\"text-decoration:underline;\" >xs</span></a>&nbsp;-<br />which is used to run commands delivered in packages.</p>Use： <p>可以使用如下命令打开CDOC参考帮助文档</p> <p>xs xdc.tools.cdoc.sg</p> <p>另外提供一些其他的实用库</p> <p>Each of the commands shown in the tablebelow is run using the xs utility above.</p> <p>&nbsp;</p> <p>Command - xdc.tools.cdoc&nbsp;&nbsp;&nbsp;Package documentation tool</p> <p>Command - xdc.tools.cdoc.sg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interactive package documentation<br />tool（交互式包文档工具）</p> <p>Command - xdc.tools.check&nbsp;Repository compatibility check tool（库兼容性检测）</p> <p>Command - xdc.tools.closure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closure tool</p> <p>Command - xdc.tools.configuro&nbsp;&nbsp;Target content configuration<br />tool（目标配置工具）</p> <p>Command - xdc.tools.path&nbsp;&nbsp;&nbsp;Package path display tool</p> <p>Command - xdc.tools.path.sg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interactive Package Path browser<br />tool</p> <p>Command - xdc.tools.repoman&nbsp;&nbsp;&nbsp;&nbsp;Repository management tool</p> <p>Command - xdc.tools.repoman.sg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interactive repository<br />management tool</p> <p>&nbsp;</p> <p>所有使用RTSC包的<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.xuebuyuan.com/\" >程序</a>都需要一个configuration文件，这个文件声明被使用的包，并被xdc.tools.configuro读取，来生成静态C数据结构，这是连接成程序所必须的。</p> <p>Configuration文件采用JavaScript语法，关于更多可参考</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://rtsc.eclipse.org/docs-tip/The_XDCscript_Language\" ><span style=\"text-decoration:underline;\" >http://rtsc.eclipse.org/docs-tip/The_XDCscript_Language</span></a></p> <p>配置脚本（configuration scripts，.cfg的文件）列出程序所需组件，RTSC配置框架使用这些脚本生成构建程序所必须的文件，如下图：</p> <p>&nbsp;<img src=\"http://img.blog.csdn.net/20140416135447953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvODExMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" style=\"max-width:500px;\" /></p>示例： <p>一个“hello world”<br />c程序</p> <p>hello.c <br />&nbsp;</p> <p><a target=\"_blank\" rel=\"nofollow\" ><strong>#include</strong></a>&lt;xdc/std.h&gt;</p> <p><strong>#include</strong>&lt;xdc/runtime/System.h&gt;</p> <p>&nbsp;</p> <p><strong>int</strong> main()&nbsp;{</p> <p>&nbsp;&nbsp;&nbsp;System_printf(&quot;Hello World!\\n&quot;);</p> <p>&nbsp;&nbsp;&nbsp;<strong>return</strong><br />(0);</p> <p>}</p> <p>第一个#include是所有使用RTSC的C程序必须的，定义基本类型</p> <p>第二个#include使C<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.xuebuyuan.com/\" >代码</a>可以使用&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://rtsc.eclipse.org/cdoc-tip/index.html#xdc/runtime/System.html\" ><span style=\"text-decoration:underline;\" >xdc.runtime.System</span></a>&nbsp;module提供的<a target=\"_blank\" rel=\"nofollow\" href=\"http://rtsc.eclipse.org/cdoc-tip/index.html#xdc/runtime/System.html#printf\" ><span style=\"text-decoration:underline;\" >System_printf()</span></a>&nbsp;function。</p> <p>配置文件如下</p> <p>hello.cfg <br /><strong>var</strong> System =<strong>xdc.useModule</strong>(&quot;<a target=\"_blank\" rel=\"nofollow\" >xdc.runtime.System</a>&quot;);</p> <p>注意：如果没有使用xdc.runtime.System包里的函数的话，包含此包会引起连接错误。</p> <p>在编译之前你还要制定目标和平台</p> <ul> <li><p>A&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://rtsc.eclipse.org/docs-tip/Glossary#Target\" ><span style=\"text-decoration:underline;\" >target</span></a>&nbsp;identifies<br />a specific compiler and anISA and runtime model supported by the compiler. For example, the TI C6000compiler for the C64+ ISA running in big endian mode.</p></li> <li><p>A&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://rtsc.eclipse.org/docs-tip/Glossary#Platform\" ><span style=\"text-decoration:underline;\" >platform</span></a>&nbsp;identifies<br />the hardware executionenvironment as seen by your application. For example, a DM6446 EVM with 64 MBof DDR2 external memory.</p><p>下图展示了xdc命令的格式</p><p><img src=\"http://img.blog.csdn.net/20140416135553656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvODExMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" style=\"max-width:500px;\" /></p></li> </ul>xs xdc.tools.configuro -t ti.targets.C64 -p ti.platforms.evmDM642 –c&nbsp;/home/DVRRDK_03.00.00.00/ti_tools/xdc/xdctools_3_23_03_53/ hello.cfg <p>上述命令将会产生2个输出文件：hello/compiler.opt、hello/linker.cmd。<strong>hello/linker.cmd还有其他文件</strong></p> <ul> <li><p>this linker command file names all libraries that must be passed to thelinker to link your application</p></li> <li><p><strong>hello/compiler.opt</strong></p></li> <li><p>this text file contains compiler options required to build C source thatreference values defined byhello.cfg</p></li> </ul> <p>由于编译和链接过程依赖于所使用的工具链，下面介绍如何在C/C++编译和链接的过程中使用comlier.opt和linker.cmd。</p> <p>gmake all&quot; and to build and run the application type&quot;gmake test&quot;. When you run &quot;gmake<br />test&quot;, the last linedisplayed is the output of the application:</p> <p>The following example makefile illustrates how tointegrate RTSC configuration with the TI Code Gen Tools compiler and<br />linker.The makefile runs&nbsp;configuro&nbsp;and<br />uses the&nbsp;compiler.opt&nbsp;and&nbsp;linker.cmd&nbsp;files<br />generated by&nbsp;configuro&nbsp;as<br />part of the compile and link steps.</p>CGTOOLS = C:/CCStudio_v3.3/C6000/cgtoolsCC =&nbsp;$(CGTOOLS)/bin/cl6xLNK&nbsp;=&nbsp;$(CGTOOLS)/bin/lnk6xRTS&nbsp;=&nbsp;$(CGTOOLS)/lib/rts6400.libCONFIG&nbsp;= helloXDCTARGET = ti.targets.C64XDCPLATFORM = ti.platforms.sim6xxx:TMS320C6416&nbsp;.PRECIOUS:&nbsp;%/compiler.opt %/linker.cmd&nbsp;%/compiler.opt:&nbsp;%/linker.cmd&nbsp;;%/linker.cmd&nbsp;:&nbsp;%.cfg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xs xdc.tools.configuro -c&nbsp;$(CGTOOLS)&nbsp;-t&nbsp;$(XDCTARGET)&nbsp;-p&nbsp;$(XDCPLATFORM)&nbsp;$&lt;&nbsp;%.obj&nbsp;:&nbsp;%.c&nbsp;$(CONFIG)/compiler.opt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(CC)&nbsp;-@$(CONFIG)/compiler.opt&nbsp;-c&nbsp;$&lt;&nbsp;hello.out&nbsp;: hello.obj $(CONFIG)/linker.cmd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(LNK)&nbsp;-o hello.out -c hello.obj $(CONFIG)/linker.cmd&nbsp;$(RTS)&nbsp;test: hello.out&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@$(CGTOOLS)/bin/load6x $&lt; <p>&nbsp;</p> <p><br /></p>  【DSP开发】CCSv5工程命令行创建，编译和导入方法 1454242292134 Text 1dad75de_9d10693 【DSP开发】 <p>Code Composer Studio提供了几个命令行工具，用户可以使用这些工具创建工程，编译工程，导入工程文件到本地工作空间。使用这些工具，用户可以在不启动CCS图形界面的情况下对工程进行操作，简化工程文件的版本维护，方便自动化测试等。<br /><br />创建工程的格式：<br />eclipsec –noSplash&nbsp;-data&nbsp;&lt;workspace_path&gt;&nbsp;-application com.ti.ccstudio.apps.projectCreate -ccs.name&nbsp;-ccs.device&nbsp;[-options]&nbsp;<br /><br />编译工程的格式：<br />eclipsec –noSplash&nbsp;-data&nbsp;&lt;workspace_path&gt;&nbsp;-application com.ti.ccstudio.apps.projectBuild (-ccs.projects&nbsp;|&nbsp;-ccs.workspace)&nbsp;[-options]<br /><br />如果需要获得帮助信息：<br />eclipsec –noSplash&nbsp;-data&nbsp;&lt;workspace_path&gt;&nbsp;-application com.ti.ccstudio.apps.projectBuild -ccs.help<br /><br />清理工程：<br />eclipsec –noSplash&nbsp;&nbsp;-data&nbsp;&quot;C:\\myWorkspace&quot;&nbsp;-application com.ti.ccstudio.apps.projectBuild -ccs.projects newProject -ccs.clean<br /><br />重新编译工程：<br />eclipsec –noSplash&nbsp;-data&nbsp;&quot;C:\\myWorkspace&quot;&nbsp;-application com.ti.ccstudio.apps.projectBuild -ccs.projects newProject -ccs.configuration Debug<br /><br />重新编译某个工作空间的所有活动工程：<br />eclipsec –noSplash&nbsp;-data&nbsp;&quot;C:\\myWorkspace&quot;&nbsp;-application com.ti.ccstudio.apps.projectBuild -ccs.workspace<br /><br />导入工程：<br />eclipsec –noSplash&nbsp;-data&nbsp;&lt;workspace_path&gt;&nbsp;-application com.ti.ccstudio.apps.projectImport -ccs.location&nbsp;[-options]<br /><br /><br />参数解释：<br />-noSplash 设置eclipse启动时不启动splash window<br />-data “workspace”&nbsp;是用户指定的工作空间的路径<br />-application 指定使用的工具应用。工程创建使用com.ti.ccstudio.apps.projectCreate，编译工程使用com.ti.ccstudio.apps.projectBuild，导入工程使用com.ti.ccstudio.apps.projectImport。<br />三个工具应用有一些公用命令参数和各自的参数，帮助信息可以通过参数-ccs.help得到。option中的参数都可以通过-ccs.args &lt;file&gt;通过加载文件的方式来载入。<br />-ccs.name &lt;name&gt;&nbsp;创建的工程名<br />-ccs.location &lt;dir&gt;&nbsp;创建工程的路径，如果工程不是在workspace中创立<br />-ccs.outputType (executable&nbsp;| staticLibrary)&nbsp;编译目的是库还是执行文件，缺省配置是执行文件<br />-ccs.device &lt;id&gt;&nbsp;工程对应的芯片ID，例如C66x是com.ti.ccstudio.deviceModel.C6000.GenericC66xxDevice。如果提供的ID不正确，eclipse会打印出所安装软件支持的芯片ID。<br />-ccs.endianness &lt;name&gt;&nbsp;(big&nbsp;| little)&nbsp;工程的大小端配置<br />-ccs.cgtVersion &lt;version&gt;&nbsp;使用的编译器版本，默认是最新版本。所使用的工具版本必须在ccstudio可以搜索的范围内。如果工具都是正常安装，应该不会有什么问题。<br />-ccs.outputFormat (COFF&nbsp;| ELF)&nbsp;输出的格式，COFF或者是ELF<br />-ccs.cmd &lt;file&gt;&nbsp;指定工程使用的linker cmd文件<br />-ccs.rts &lt;file&gt;&nbsp;指定runtime library的设置<br />-ccs.configurations &lt;name1&gt;[&nbsp;&lt;name2&gt;]*&nbsp;可以在工程中设置不同的配置选项，例如debug或者是release<br />-ccs.references &lt;name1&gt;[&nbsp;&lt;name2&gt;]*&nbsp;可设置工程相关定义<br />-ccs.artifactName &lt;name&gt;&nbsp;指定编译输出的文件名称(optional)<br />-ccs.artifactExtension &lt;ext&gt;&nbsp;指定编译输出文件的扩展名(optional)<br />-ccs.listBuildOptions 打印支持的buildOptions，这些option可以通过后面的setCompilerOptions，setLinkOptions，setAssemblerOptions来配置。应该包括了所有cl6x支持的编译选项<br />-ccs.setCompilerOptions &quot;&lt;options&gt;&quot;&nbsp;[@prepend]&nbsp;[@configurations&nbsp;&lt;name1&gt;[&nbsp;&lt;name2&gt;]*]<br />-ccs.setLinkerOptions &quot;&lt;options&gt;&quot;&nbsp;[@prepend]&nbsp;[@configurations&nbsp;&lt;name1&gt;[&nbsp;&lt;name2&gt;]*]<br />设置编译，链接选项。选项用双引号括起来，如果options里包含双引号，在双引号前加\\。@prepend可以让包含的选项在排在已有选项的前面。@configurations可以对于不同的前面定义的configurations设置不同的编译选项。下面的例子中Release configuration中不包含调试信息，使用o3优化，Debug configuration编译选项包含调试信息，使用o0优化选项。<br />-ccs.setPreBuildStep &quot;&lt;command&gt;&quot;&nbsp;[@configurations&nbsp;&lt;name1&gt;[&nbsp;&lt;name2&gt;]*]<br />-ccs.setPostBuildStep &quot;&lt;command&gt;&quot;&nbsp;[@configurations&nbsp;&lt;name1&gt;[&nbsp;&lt;name2&gt;]*]<br />设置编译预/后处理，根据不同的configuration可以有不同的预/后处理步骤。<br />-ccs.copyFile &lt;file&gt;&nbsp;[@dir&nbsp;&lt;dir&gt;]&nbsp;[@configurations&nbsp;[&lt;name&gt;&nbsp;]*]<br />把指定的文件拷贝到工作空间中。不同的配置可以拷贝不同的文件。可以通过@dir来指定拷贝文件的目的目录地址。<br />-ccs.linkFile &lt;file&gt;&nbsp;[@dir&nbsp;&lt;dir&gt;]&nbsp;[@configurations&nbsp;[&lt;name&gt;&nbsp;]*]<br />命令格式和copyFile一致，但是不直接拷贝文件，只是把文件链接到工程文件中<br />-ccs.definePathVariable &lt;name&gt;&nbsp;&lt;value&gt;&nbsp;[@scope&nbsp;(global|project)]<br />用来定义工程或者是全局的路径变量。可以自定义路径变量，但不能是已有的缺省变量，例如CG_TOOLS_DIR。<br />-ccs.defineBuildVariable &lt;name&gt;&nbsp;&lt;value&gt;&nbsp;[@type&nbsp;(string|dir|file)]&nbsp;[@scope&nbsp;(global|project|configuration)]&nbsp;[@configurations&nbsp;[&lt;name&gt;&nbsp;]*]<br />定义编译变量<br />-ccs.autoGenerateMakefiles (true|false)<br />是否生成make文件。缺省是true<br />-ccs.buildLocation &lt;path&gt;<br />指定编译路径，只有在autoGenerateMakefiles是false时有效。<br />-ccs.buildCommand &lt;path&gt;<br />设置编译命令路径，缺省使用CCS提供的gmake工具。<br />-ccs.buildCommandFlags &quot;&lt;flags&gt;&quot;<br />设置编译命令的flag，例如gmake -k&nbsp;-j等，可以用来使能多核编译，或者分布式编译。<br />-ccs.buildTarget &lt;name&gt;<br />设置编译目标名<br />-ccs.cleanTarget &lt;name&gt;<br />设置make clean的目标名<br />-ccs.overwrite (full&nbsp;| keep)<br />如果工作空间已经有一个同名的工程文件，是否保留该工程。是有full，则覆盖已有的工程文件<br />DSP/BIOSv5.x support:<br />-rtsc.biosVersion &lt;version&gt;&nbsp;设置使用的BIOS版本。<br />RTSC support:<br />-rtsc.enableRtsc 使能RTSC<br />-rtsc.xdcVersion &lt;version&gt;&nbsp;设置xdc版本。缺省使用最新的版本。<br />-rtsc.target &lt;id&gt;&nbsp;设置RTSC目标名<br />-rtsc.platform &lt;id&gt;&nbsp;设置RTSC使用的平台名。<br />-rtsc.buildProfile &lt;profile&gt;&nbsp;使用的RTSC配置文件<br />-rtsc.configurationOnly 只生成一个RTSC配置工程<br /><br />参考地址：<br />http://processors.wiki.ti.com/index.php/Projects_-_Command_Line_Build/Create<br />http://www.deyisupport.com/question_answer/dsp_arm/c6000_multicore/f/53/t/10178.aspx<br /></p>  【DSP开发】TMS320C6678编程开发 1454208083645 Text 1dad75de_9d003ca 【DSP开发】 <p>一．&nbsp;这么学DSP比较有效<br />在开始C6678的架构讲解之前，我想拉出一点篇幅，给大家谈一下，根据我个人的理解，怎么样才能比较快的学好DSP。</p> <p><br />（1）学习DSP，首先要与学MCU区分开，毕竟这是两个完全不同的架构，而且DSP与MCU的设计思路完全不一样。MCU是为通用的控制而设计，DSP则是专为高速应用而设计；</p> <p><br />（2）从硬件的角度来考虑，要玩转DSP，首先需要仔细阅读其数据手册和用户指南。数据手册中，重点阅读DSP的技术指标，最关键的是对芯片的电源需求做详细的了解，其中对核电压的需求一定要认真了解，这是DSP稳定运行的基本条件；做硬件设计的人，电源设计是最基本的，不仅要考虑电源的电压，更重要的是要考虑电源的抗跌落性能、动态性能。尤其在DSP使用场合，高速电路对电源的要求尤其苛刻，尤其是对于上电时序需要特别注意&nbsp;；<br /><br />（3）在对DSP芯片的电源需求做了深入的了解后，下一步就是要仔细阅读如何启动DSP，前面说了，DSP与MCU不一样，但是有一点又是非常相似的，就是DSP跟MCU一样，需要明确的设置好启动的选项。因为DSP是独立的高速信号应用，DSP的控制程序和算法都是独立的存储在独立的存储空间。所以如何根据产品的需求进行启动的配置，这是非常重要的；<br /><br />（4）在了解了DSP的启动选项后，还有一个需要密切关注的，就是对于晶体或者TCXO等等的选择，这一点为什么要提出来，本人是做无线通信的，做基站或者终端，都必须根据网络的需要，确定你需要的系统基准时钟的技术指标，如果你选择的晶体或者TCXO等等指标落后于你的网络系统的需要，那么在使用和测试的过程中，将会出现失步的问题。无线通信最严重的通信故障就是失步。尤其是我们国家推行的TD-SCDMA以及TDD-LTE都对网络的同步提出了极为苛刻的要求，在做DSP设计时，尤其需要对DSP的输入时钟根据系统的性能需要，做特别的处理&nbsp;；<br /><br />（5）对于高速DSP，比如我们接下来要讲的8核高速DSP TMS320C6678而言，一个至关重要的硬件设计，就是存储器的设计。尤其是随着性能的提高，都已经从DDR2升级到DDR3了，为了追求极速的性能，一定要考虑存储器的拓扑结构；<br /><br />（6）进行DSP的产品实际设计前，建议优先采用DSP芯片厂家推荐的开发板或者评估板，做一些技术的准备，从这些开发板的设计资料中，体会设计中需要关注的地方。尤其是8核的TMS320C6678的设计，更加需要关注。这里我提醒大家，做TMS320C6678的设计，最好不要完全按照自己以前的经验进行，一定要按照参考设计进行；<br /><br />（7）作为DSP软件工程师来说，比硬件工程师就要幸福多了。DSP的软件，与目前主流的MCU差不多，同样也要细分为驱动程序，LINUX，算法以及应用开发等等。对于LINUX的应用和驱动的开发，这里就不说了。重点给大家提示驱动开发需要注意的问题，在LINUX或者ANDROID开发中，有很多的驱动软件，但是DSP的驱动软件开发，需要下的功夫要多得多。除了大家都关心的驱动通用技术，更重要的是鲁棒性；<br /><br />二．多核DSP的架构<br /><br />TMS320C6678是KeyStone架构的8核DSP处理器，每个CorePac核的频率最高为1.25 GHz，提供强大的定点和浮点运算能力，同时芯片内部集成了Multicore Navigator、RapidIO、千兆以太网和EDMA等外设，由于芯片处理能力强，外设功能丰富，而且片内集成了大量的硬件加速器，例如Packet Accelerator、Multicore Navigator等，可以广泛地应用在通信、雷达、声纳、火控、电子对抗等领域。从目前的情况看，由于C6678的以上优异的特性，基于TMS320C6678的硬件和软件平台，在未来的5~10年内，将是信号处理平台主流。<br /><img src=\"http://img03.store.sogou.com/net/a/04/link?appid=100520031&amp;w=710&amp;url=http://mmbiz.qpic.cn/mmbiz/4uXLf4TOmvahYpIjmLCTDN5I3qzyScgVxcpZjXs3gSb9n22ibTDJ8wbG8rUlQwbk1r6vm98GnNzlhnfnM7BxawQ/0?wx_fmt=png\" style=\"max-width:500px;\" /><br />TMS320C6678有8个C66x核，典型速度是1GHz，每个核配置为：<br />32KB Level 1 Data SRAM，它和DSP 核运行在相同的速度上，可以被用作普通的数据存储器或数据cache；<br />32KB Level 1 Program SRAM,&nbsp;它和DSP 核运行在相同的速度上，可以被用作普通的程序存储器或程序cache；<br />512KB LL2 SRAM,&nbsp;它的运行速度是DSP 核的一半，可以被用作普通存储器或cache，既可以存放数据也可以存放程序；<br />所有DSP核共享4MB SL2 SRAM,&nbsp;它的运行速度是DSP 核的一半，既可以存放数据也可以存放程序。一个64-bit 1333MTS DDR3 SDRAM接口可以支持8GB外部扩展存储器。<br />C6678 集成一个64-bit 1333MTS DDR3 SDRAM 接口，可以支持8GB&nbsp;外部扩展存储器，既可以存放数据也可以存放程序。它的总线宽度也可以被配置成32 bits 或16 bits。<br /><br />存储器访问性能对 DSP 上软件运行的效率是非常关键的。在 C6678 DSP 上，所有的主模块，包括多个DSP&nbsp;核和多个DMA&nbsp;都可以访问所有的存储器。<br /><br />每个DSP 核每个时钟周期都可以执行最多128 bits 的load&nbsp;或store&nbsp;操作。在1GHz&nbsp;的时钟频率下，DSP&nbsp;核访问 L1D SRAM 的带宽可以达到 16GB/S。当访问二级(L2)存储器或外部存储器时，访问性能主要取决于访问的方式和cache。<br /><br />每个 DSP 核有一个内部 DMA (IDMA)，在 1GHz 的时钟频率下，它能支持高达 8GB/秒的传输。但IDMA 只能访问L1&nbsp;和LL2&nbsp;以及配置寄存器，它不能访问外部存储器。DSP&nbsp;的内部总线交换网络，TeraNet，提供了C66x&nbsp;核&nbsp;(包括其本地存储器)，外部存储器， EDMA 控制器，和片上外设之间的互联。总共有 10 个 EDMA 传输控制器可以被配置起来同时执行任意存储器之间的数据传输。芯片内部有两个主要的TeraNet模块，一个用 128 bit 总线连接每个端点，速度是DSP&nbsp;核频率的1/3，理论上，在1GHz&nbsp;的器件上每个端口支持 5.333GB/秒的带宽；另一个TeraNet内部总线交换网络用 256 bit 总线连接每个端点，速度是DSP&nbsp;核频率的1/2，理论上，在1GHz&nbsp;的器件上每个端口支持16GB/秒的带宽。<br /><br />在看了上面的介绍后，有三个基本的问题，给大家思考：<br />（1）如果是拷贝数据，我们应该用DSP核还是DMA？<br />（2）一个频繁访问存储器的函数会消耗多少时钟周期？<br />（3）当多个主模块共享存储器时，对某个模块的性能到底有多大的影响？<br /><br />下面的一些测试数据是在EVM上的结果，在这里引用用来作性能评估参考&nbsp;，详细的文档在TI技术支持中文网站（<a target=\"_blank\" rel=\"nofollow\" >www.deyisupport.com</a>)下载：<br /><a target=\"_blank\" rel=\"nofollow\" >http://www.deyisupport.com/quest ... e/f/53/t/21924.aspx</a><br /><br />（1）1GHz C6678 上C66x&nbsp;核，IDMA&nbsp;和EDMA&nbsp;的理论带宽<br /><img src=\"http://img03.store.sogou.com/net/a/04/link?appid=100520031&amp;w=710&amp;url=http://mmbiz.qpic.cn/mmbiz/4uXLf4TOmvahYpIjmLCTDN5I3qzyScgVuqp39wE19WIIutmjKYj9CbNC6SeaETDUppVv7Sic7gKoPtWqfA8S22w/0?wx_fmt=png\" style=\"max-width:500px;\" /><br /><br />（2）1GHz C6678 上各种存储器端口的理论带宽<br /><img src=\"http://img03.store.sogou.com/net/a/04/link?appid=100520031&amp;w=710&amp;url=http://mmbiz.qpic.cn/mmbiz/4uXLf4TOmvahYpIjmLCTDN5I3qzyScgVmWSRygyQHHOwKf8GvhUiaGwjHxNMX1YWrzmERMpoKiaYZQGe8aSXJfOQ/0?wx_fmt=png\" style=\"max-width:500px;\" /><br /><br />（3）DSP 核，EDMA&nbsp;和IDMA&nbsp;数据拷贝的吞吐量比较<br /><img src=\"http://img03.store.sogou.com/net/a/04/link?appid=100520031&amp;w=710&amp;url=http://mmbiz.qpic.cn/mmbiz/4uXLf4TOmvahYpIjmLCTDN5I3qzyScgVkmqaqZRYG0b5GVMQn2HKSDdZWt3HRKjib86V8v1mZMexvefGMgzoWhA/0?wx_fmt=png\" style=\"max-width:500px;\" /><br /><img src=\"http://img03.store.sogou.com/net/a/04/link?appid=100520031&amp;w=710&amp;url=http://mmbiz.qpic.cn/mmbiz/4uXLf4TOmvahYpIjmLCTDN5I3qzyScgV7bVnoctolOkBWluUiaULPIsaU2aN9v94XqYUzuwNWa4p384bLcsl6Fg/0?wx_fmt=png\" style=\"max-width:500px;\" /><br /><br />从以上测试结果可以得出，DSP核与内部存储器之间数据交换的效率非常高，可是与外部存储器的交换则显得不那么激动人心；IDMA非常适用于DSP核本地存储器&nbsp;(L1D，L1P，LL2)内连续数据块的传输，但不能访问共享存储器&nbsp;(SL2, DDR)；所以外部存储器的大块数据访问则应尽量使用EDMA。<br />Cache 配置显著地影响DSP&nbsp;核的访问性能，预取缓冲器能提高读访问的效率，但对EDMA&nbsp;和IDMA没有影响。测试结果是在cache和预取缓冲器在测试前被清空。<br /><br />对DSP 核，SL2&nbsp;可以通过从0x0C000000&nbsp;开始的缺省地址空间被访问，通常这个地址空间被设置为cacheable&nbsp;而且prefetchable。SL2&nbsp;可以通过XMC&nbsp;(eXtended Memory Controller)被重映射到其它存储器空间，通常重映射空间被用作non-cacheable, nonprefetchable访问（当然它也可以被设置为cacheable 而且prefetchable）。通过缺省地址空间访问比通过重映射空间访问稍微快一点。<br /><br />前面列出的EDMA 吞吐量数据是在EDMA CC0 (Channel Controller 0) TC0 (Transfer Controller 0)上测得的，EDMA CC1 和EDMA CC2 的吞吐量比EDMA CC0 低一些。</p> <p><br /></p>  【DSP开发】TMS320C668存储器访问性能 1454207851117 1454207903982 Text 1dad75de_9d003b5 【DSP开发】 <p>摘要 TMS320C6678 有8&nbsp;个C66x&nbsp;核，典型速度是1GHz，每个核有 32KBL1D SRAM，32KB L1P SRAM和 512KB LL2 SRAM；所有 DSP 核共享 4MB SL2 SRAM。一个 64-bit 1333MTS DDR3 SDRAM 接口可以支持8GB&nbsp;外部扩展存储器。<br /><br />存储器访问性能对 DSP 上运行的软件是非常关键的。在 C6678&nbsp; DSP 上，所有的主模块，包括多个DSP&nbsp;核和多个DMA&nbsp;都可以访问所有的存储器。<br /><br />每个DSP 核每个时钟周期都可以执行最多128 bits 的load&nbsp;或store&nbsp;操作。在1GHz&nbsp;&nbsp;的时钟频率下，DSP&nbsp;核访问L1D SRAM 的带宽可以达到16GB/S。<br /><br />DSP 的内部总线交换网络，TeraNet，提供了C66x&nbsp;&nbsp;核(包括其本地存储器)，外部存储器， EDMA 控制器，和片上外设之间的互连总共有 10 个 EDMA 传输控制器可以被配置起来同时执行任意存储器之间的数据传输。<br /><br />本文为设计人员提供存储器访问性能评估的基本信息；提供各种操作条件下的性能测试数据；还探讨了影响存储器访问性能的一些因素。<br /><br />1.&nbsp;&nbsp;存储器系统简介<br /><br />TMS320C6678 有8&nbsp;个C66x&nbsp;核，每个核有:&nbsp;<br /><br />32KB L1D (Level 1 Data) SRAM，它和DSP 核运行在相同的速度上，可以被用作普通的数据存储器或数据cache。<br /><br />32KB L1P (Level 1 Program) SRAM，它和DSP 核运行在相同的速度上，可以被用作普通的程序存储器或程序cache。<br /><br />512KB LL2 (Local Level 2) SRAM，它的运行速度是DSP 核的一半，可以被用作普通存储器或cache，既可以存放数据也可以存放程序。<br /><br />所有DSP 核共享4MB SL2 (Shared Level 2) SRAM，它的运行速度是DSP 核的一半，既可以存放数据也可以存放程序。<br /><br />TMS320C6678 集成一个64-bit 1333MTS DDR3 SDRAM 接口，可以支持8GB&nbsp;外部扩展存储器，既可以存放数据也可以存放程序。它的总线宽度也可以被配置成32 bits 或16 bits。<br /><br />存储器访问性能对 DSP 上软件运行的效率是非常关键的。在 C6678 DSP 上，所有的主模块，包括多个DSP&nbsp;核和多个DMA&nbsp;都可以访问所有的存储器。<br /><br />每个DSP 核每个时钟周期都可以执行最多128 bits 的load&nbsp;或store&nbsp;操作。在1GHz&nbsp;&nbsp;的时钟频率下，DSP&nbsp;核访问 L1D SRAM 的带宽可以达到 16GB/S。当访问二级(L2)存储器或外部存储器时，访问性能主要取决于访问的方式和cache。<br /><br />每个 DSP 核有一个内部 DMA (IDMA)，在 1GHz &nbsp;的时钟频率下，它能支持高达 8GB/秒的传输。但IDMA 只能访问L1&nbsp;和LL2&nbsp;以及配置寄存器，它不能访问外部存储器。<br /><br />DSP 的内部总线交换网络，TeraNet，提供了C66x&nbsp;核&nbsp;(包括其本地存储器)，外部存储器， EDMA 控制器，和片上外设之间的互联。总共有 10 个 EDMA 传输控制器可以被配置起来同时执行任意存储器之间的数据传输。芯片内部有两个主要的TeraNet模块，一个用 128 bit 总线连接每个端点，速度是DSP&nbsp;核频率的1/3，理论上，在1GHz&nbsp;的器件上每个端口支持&nbsp; 5.333GB/秒的带宽；另一个TeraNet内部总线交换网络用 256&nbsp; bit 总线连接每个端点，速度是DSP&nbsp;核频率的1/2，理论上，在1GHz&nbsp;的器件上每个端口支持16GB/秒的带宽。<br /><br />总共有10 个EDMA&nbsp;传输控制器可以被配置起来同时执行任意存储器之间的数据传输。它们中的两个连接到256-bit, 1/2 DSP 核速度的TeraNet内部总线交换网络；另外8&nbsp;个连接到128-bit, 1/3 DSP 核速度的TeraNet内部总线交换网络。<br /><br />图1 展示了TMS320C6678&nbsp;的存储器系统。总线上的数字代表它的宽度。大部分模块运行速度是DSP&nbsp;核时钟的1/n，DDR&nbsp;的典型速度是1333MTS(Million Transfer per Second)。<br /><br /><img src=\"http://design.eccn.com/uploads/article/201506/20150618135715758.jpg\" style=\"max-width:500px;\" /><br />图1 <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=TMS320C6678+%B4%E6%B4%A2%C6%F7\" >TMS320C6678 存储器</a>系统<br /><br />本文为设计人员提供存储器访问性能评估的基本信息；提供各种操作条件下的性能测试数据；还探讨了影响存储器访问性能的一些因素。<br /><br />本文对分析以下常见问题会有所帮助：<br /><br />应该用DSP 核还是DMA&nbsp;来拷贝数据？<br /><br />一个频繁访问存储器的函数会消耗多少时钟周期？<br /><br />当多个主模块共享存储器时，对某个模块的性能会有多大的影响？<br /><br />本文中的大部分数据是在C6678 EVM (EValuation Module)板上测试得到的，它上面有64-bit 1333MTS 的DDR&nbsp;存储器。<br /><br />2.&nbsp; DSP 核，EDMA3，IDMA&nbsp;拷贝数据的性能比较<br /><br />数据拷贝的带宽由下面三个因素中最差的一个决定：<br /><br />总线带宽<br /><br />源端吞吐量<br /><br />目的端吞吐量<br /><br />表1 总结了C6678&nbsp;上C66x&nbsp;核，IDMA&nbsp;和EDMA&nbsp;的理论带宽。<br /><br />表1 1GHz C6678 上C66x&nbsp;核，IDMA&nbsp;和EDMA&nbsp;的理论带宽<br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://design.eccn.com/uploads/article/201506/20150618135736786.jpg\" ><img src=\"http://design.eccn.com/uploads/article/201506/20150618135736786_s.jpg\" style=\"max-width:500px;\" /></a><br /><br />表2 总结了C6678 EVM（64-bit 1333MTS DDR）上各种存储器端口的理论带宽。<br /><br />表2 1GHz C6678 上各种存储器端口的理论带宽<br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://design.eccn.com/uploads/article/201506/20150618135750719.jpg\" ><img src=\"http://design.eccn.com/uploads/article/201506/20150618135750719_s.jpg\" style=\"max-width:500px;\" /></a><br /><br />表3 列出了在1GHz C6678 EVM（ 64-bit 1333MTS DDR）上，在不同情况下用EDMA，IDMA 和DSP&nbsp;核做大块连续数据拷贝测得的吞吐量。<br /><br />在这些测试中，L1 上的测试数据块的大小是8KB；IDMA LL2-&gt;LL2 拷贝的数据块的大小是32KB；其它DSP&nbsp;核拷贝测试的数据块的大小是64KB，其它EDMA&nbsp;拷贝测试的数据块大小是128KB。<br /><br />吞吐量由拷贝的数据量除以消耗的时间得到。<br /><br />表3 DSP 核，EDMA&nbsp;和IDMA&nbsp;数据拷贝的吞吐量比较<br /><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://design.eccn.com/uploads/article/201506/20150618135802359.jpg\" ><img src=\"http://design.eccn.com/uploads/article/201506/20150618135802359_s.jpg\" style=\"max-width:500px;\" /></a><br /><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://design.eccn.com/uploads/article/201506/20150618135810393.jpg\" ><img src=\"http://design.eccn.com/uploads/article/201506/20150618135810393_s.jpg\" style=\"max-width:500px;\" /></a><br /><br />总的来说，DSP 核可以高效地访问内部存储器，而用DSP&nbsp;核访问外部存储器则不是有效利用资源的方式；IDMA&nbsp;非常适用于DSP&nbsp;核本地存储器&nbsp;(L1D，L1P，LL2)内连续数据块的传输，但它不能访问共享存储器&nbsp;(SL2, DDR)；而外部存储器的访问则应尽量使用EDMA。<br /><br />Cache 配置显著地影响DSP&nbsp;核的访问性能，Prefetch buffer 也能提高读访问的效率，但它们不影响EDMA&nbsp;和IDMA。这里所有DSP&nbsp;核的测试都是基于cold cache（cache和Prefetch buffer 在测试前被清空）。<br /><br />对DSP 核，SL2&nbsp;可以通过从0x0C000000&nbsp;开始的缺省地址空间被访问，通常这个地址空间被设置为cacheable&nbsp;而且prefetchable。SL2&nbsp;可以通过XMC&nbsp;(eXtended Memory Controller)被重映射到其它存储器空间，通常重映射空间被用作non-cacheable, nonprefetchable访问（当然它也可以被设置为cacheable 而且prefetchable）。通过缺省地址空间访问比通过重映射空间访问稍微快一点。<br /><br />前面列出的EDMA 吞吐量数据是在EDMA CC0 (Channel Controller 0) TC0 (Transfer Controller 0)上测得的，EDMA CC1 和EDMA CC2 的吞吐量比EDMA CC0 低一些，后面有专门的章节来比较10&nbsp;个EDMA&nbsp;传输控制器的差别。<br /><br />3.&nbsp; DSP 核访问存储器的时延<br /><br />L1 和 DSP 核的速度相同，所以DSP&nbsp;核每个时钟周期可以访问L1&nbsp;存储器一次。对一些特殊应用，需要非常快的访问小块数据，可以把L1&nbsp;的一部分配置成普通RAM（而不是cache）来存放数据。<br /><br />通常，L1 被全部配置成cache，如果cache&nbsp;访问命中(hit)，DSP&nbsp;核可在一个周期完成访问；如果cache&nbsp;访问没有命中(miss)，DSP&nbsp;核需要等待数据从下一级存储器中被读到cache&nbsp;中。<br /><br />本节讨论DSP 核访问内部存储器和外部DDR&nbsp;存储器的时延。下面是时延测试的伪代码:&nbsp;<br /><br /><img src=\"http://design.eccn.com/uploads/article/201506/20150618135826116.jpg\" style=\"max-width:500px;\" /><br /><br />3.1 DSP 核访问LL2&nbsp;的时延<br /><br />图2 是在1GHz C6678 EVM 上测得的DSP&nbsp;核访问LL2&nbsp;的时延。DSP&nbsp;核执行512&nbsp;个连续的LDDW&nbsp;(LoaD Double Word)或STDW (STore Double Word)指令所花的时间被测量，平均下来每个操作所花的时间被画在图中。这个测试使用了32KB L1D cache。<br /><br /><img src=\"http://design.eccn.com/uploads/article/201506/20150618135838717.jpg\" style=\"max-width:500px;\" /><br />图2 DSP 核访问LL2&nbsp;<br /><br />对LDB/STB 和LDW/STW&nbsp;的测试表明，它们的时延与LDDW/STDW&nbsp;相同。<br /><br />由于L1D cache 只有在读操作时才会被分配，DSP&nbsp;核读LL2&nbsp;总是通过L1D cache。所以，DSP核访问LL2 的性能高度依赖cache。多个访问之间的地址偏移(stride)显著地影响访问效率，地址连续的访问可以充分地利用cache；大于或等于64&nbsp;字节的地址偏移导致每次访问都miss L1 cache 因为L1D cache 行大小是64 bytes。<br /><br />由于L1D cache 不会在写操作时被分配，并且这里的测试之前cache&nbsp;都被清空了，所以任何对LL2&nbsp;的写操作都通过L1D write buffer (4x16bytes)。对多个写操作，如果地址偏移小于16 bytes，这些操作可能在write buffer 中被合并成一个对LL2&nbsp;的写操作，从而获得接近平均每个写操作用1&nbsp;个时钟周期的效率。<br /><br />当多个写操作之间的偏移是128 bytes 整数倍时，每个写操作都访问LL2&nbsp;的相同sub-bank&nbsp;(LL2包含两个banks，每个bank&nbsp;包含4&nbsp;个总线宽度为16-byte&nbsp;的sub-bank)，对相同sub-bank&nbsp;的连续访问的时延是4&nbsp;个时钟周期。对其它的访问偏移量，连续的写操作会访问LL2&nbsp;不同的bank，这样的多个访问的在流水线上可以被重叠起来，从而使平均的访问时延比较小。<br /><br />C66x 核在C64x+核的基础上有很多改进，C66x&nbsp;核的L2&nbsp;存储器控制器和DSP&nbsp;核速度相同，而 C64x+的L2 存储器控制器的运行速度是DSP&nbsp;核速度的1/2。图3&nbsp;比较了C66x&nbsp;和C64x+ Load/Store LL2 存储器的性能。<br /><br /><img src=\"http://design.eccn.com/uploads/article/201506/20150618135847363.jpg\" style=\"max-width:500px;\" /><br />图3 C66x 和C64x+核在LL2&nbsp;上Load/Store&nbsp;的时延比较<br /><br />3.2 DSP 核访问SL2&nbsp;的时延<br /><br />图4 是在1GHz C6678 EVM 上测得的DSP&nbsp;核访问SL2&nbsp;的时延。DSP&nbsp;核执行512&nbsp;个连续的LDDW&nbsp;(LoaD Double Word)或STDW (STore Double Word)指令所花的时间被测量，平均下来每个操作所花的时间被画在图中。测试中，L1D 被配置成32KB cache。<br /><br /><img src=\"http://design.eccn.com/uploads/article/201506/20150618135856587.jpg\" style=\"max-width:500px;\" /><br />图4 DSP 核访问SL2<br /><br />对LDB/STB 和LDW/STW&nbsp;的测试表明，它们的时延与LDDW/STDW&nbsp;相同。<br /><br />DSP 核读SL2&nbsp;通常会通过L1D cache，所以，和访问LL2 一样，DSP&nbsp;核访问SL2&nbsp;的性能高度依赖cache。<br /><br />XMC 中还有一个prefetch buffer (8x128bytes)，它可以被看作是一个额外的只对读操作可用的cache。DSP&nbsp;核之外的每16-MB&nbsp;存储器块都可以通过MAR&nbsp;(Memory Attribute Register)的PFX (PreFetchableeXternally) bit 被配置为是否通过prefetch buffer 读，使能它会对多个主模块共享存储器的效率有很大帮助；它也能显著地改善对SL2&nbsp;连续读的性能。不过，prefetch buffer 对写操作没有任何作用。<br /><br />SL2 可以通过从0x0C000000&nbsp;开始的缺省的地址空间访问，这个空间总是cacheable，通常它也被配置为prefetchable。SL2&nbsp;可以通过XMC&nbsp;的配置被重映射到其它地址空间，通常重映射空间被用作non-cacheable, nonprefetchable访问（当然它也可以被设置为cacheable 而且prefetchable）。通过缺省地址空间访问比通过重映射空间访问稍微快一点，因为地址重映射需要一个额外的时钟周期。<br /><br />由于L1D cache 不会在写操作时被分配，并且这里的测试之前cache&nbsp;都被清空了，所以任何对SL2&nbsp;的写操作都通过L1D write buffer (4x16bytes)。对多个写操作，如果地址偏移小于16 bytes，这些操作可能在write buffer 中被合并成一个对SL2&nbsp;的写操作，从而获得比较高的效率。XMC也有类似的写合并buffer，它可以合并两个在32 bytes 内的写操作，所以，对偏移小于32bytes&nbsp;的写操作，XMC&nbsp;的写buffer&nbsp;改善了写操作的性能。<br /><br />当写偏移是N*256 bytes 时，每个写操作总是访问SL2&nbsp;相同的bank&nbsp;(SL2&nbsp;存储器组织结构是4 bank x 2 sub-bank x 32 bytes)，对相同bank 的连续访问间隔是4&nbsp;个时钟周期。对其它的访问偏移量，连续的写操作会访问SL2&nbsp;不同的bank，这样的多个访问的在流水线上可以被重叠起来，从而使平均的访问时延比较小。<br /><br />图5 比较了DSP&nbsp;核访问SL2&nbsp;和LL2&nbsp;的访问时延。对地址偏移小于16 bytes 的连续访问，访问SL2&nbsp;的性能和LL2&nbsp;几乎相同。而对地址偏移比较大的连续访问，访问SL2&nbsp;的性能比LL2&nbsp;差。因此，SL2&nbsp;最适合于存放代码。<br /><br /><img src=\"http://design.eccn.com/uploads/article/201506/20150618135908885.jpg\" style=\"max-width:500px;\" /><br />图5 DSP 核访问SL2&nbsp;和LL2&nbsp;的性能比较<br /><br />3.3 DSP 核访问外部DDR&nbsp;存储器的时延<br /><br />DSP 核访问外部DDR&nbsp;存储器高度依赖cache。当DSP&nbsp;核访问外部存储器时，一个传输请求会被发给XMC。根据cacheable&nbsp;和prefetchable的设置，传输请求可能是下列情况中的一种:&nbsp;&nbsp;<br /><br />一个数据单元&nbsp;–&nbsp;如果存储器空间是non-cacheable，nonprefetchable<br /><br />一个L1 cache line -&nbsp;如果存储器空间是cacheable&nbsp;而没有L2 cache，<br /><br />一个L2 cache line -&nbsp;如果存储器空间是cacheable&nbsp;并且设置了L2 cache。<br /><br />如果要访问的数据在L1/L2 cache 或prefetch buffer 中，则不会有传输请求发出。<br /><br />如果被访问的空间是prefetchable的，可能还会产生额外的prefetch请求。<br /><br />外部存储器的内容可以被缓存在L1 cache 或/和L2 cache，或者都不用。DSP 核之外的每16-MB存储器块都可以通过MAR&nbsp;(Memory Attribute Register)的PC (Permit Copy) bit 被配置为是否通过cache&nbsp;访问。如果PC&nbsp;比特为0，这段空间就不是cacheable&nbsp;的。如果PC&nbsp;比特是1&nbsp;而L2 cache 大小为0&nbsp;(所有LL2&nbsp;都被用作普通SRAM)，那外部存储器的内容只会被L1 cache 缓存。如果PC比特是1&nbsp;并且L2 cache 大于0，则外部存储器的内容可以被L1&nbsp;和L2 cache 同时缓存。<br /><br />像访问SL2 一样，对外部存储器的读操作也可以利用XMC&nbsp;里的prefetch buffer。它可以通过MAR (Memory Attribute Register)的PFX (PreFetchableeXternally) bit 来配置。<br /><br />多个访问之间的地址偏移(stride)显著地影响访问效率，地址连续的访问可以充分地利用cache 和prefetch buffer；大于或等于64 字节的地址偏移导致每次访问都miss L1 cache 因为L1D cache行大小是64 bytes；大于或等于128 字节的地址偏移导致每次访问都miss L2 cache 因为L2 cache 行大小是128 bytes。<br /><br />如果发生cache miss，DSP 需要等待外部数据传输完成。等待的时间是请求发出时间，数据传输时间或数据返回时间的总和。<br /><br />图6 是在1GHz C6678 EVM（64-bit 1333MTS DDR）上测得的DSP 核访问DDR&nbsp;的时延。DSP核执行512&nbsp;个连续的LDDW&nbsp;(LoaD Double Word)或STDW (STore Double Word)指令所花的时间被测量，平均下来每个操作所花的时间被画在图中。测试中，L1D 被配置成32KB cache，LL2的256KB 被设置为cache。<br /><br />对LDB/STB 和LDW/STW&nbsp;的测试表明，它们的时延与LDDW/STDW&nbsp;相同。<br /><br />注意，下面第二和第三个图实际上是第一个图左边的放大。<br /><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://design.eccn.com/uploads/article/201506/20150618135918414.jpg\" ><img src=\"http://design.eccn.com/uploads/article/201506/20150618135918414_s.jpg\" style=\"max-width:500px;\" /></a><br />图6 DSP 核对DDR Load/Store 的时延<br /><br />对地址偏移小于128 bytes 的访问，性能主要受cache&nbsp;的影响。<br /><br />L2 cache 会在写操作时被分配，对任何写操作，cache&nbsp;控制器总是先把被访问的数据所在的cache&nbsp;行（128 bytes）读进L2 cache，然后在cache 中改写数据。被改写是数据会在发生cache冲突或手工cache&nbsp;回写操作时被最终写到外部存储里。当写操作的地址偏移是1024 bytes 的整数倍时，多个访问在L2 cache 中发生冲突的概率很大，所以L2 cacheable 写操作的时延会显著地增加。最坏的情况下，每个写操作都会导致一个cache&nbsp;行的回写&nbsp;(之前的数据因为冲突而被替换/回写)和一个cache&nbsp;行的读入(新的数据被分配到cache&nbsp;中)。<br /><br />当地址偏移大于512 bytes 时，DDR&nbsp;页（行）切换开销成为性能下降的主要因素。C6678 EVM上的DDR 页（行）大小或bank&nbsp;宽度是8KB，而DDR3&nbsp;存储器包含8&nbsp;个banks。最坏的情况是，当访问地址偏移量是64KB&nbsp;时，每个读或写操作都会访问相同bank&nbsp;中一个新的行，而这种行切换会增加大约40&nbsp;个时钟周期的时延。请注意，不同的DDR&nbsp;存储器的时延可能会不一样。<br /></p> <p><br /></p> <p><br /></p> <p><br /></p>  【DSP开发】哈佛结构与冯诺依曼结构 1454203287606 Text 1dad75de_9d002f5 【DSP开发】 <p><strong>哈佛结构</strong></p> <p><strong><img src=\"http://my.csdn.net/uploads/201204/19/1334839043_3697.png\" style=\"max-width:500px;\" /><br /></strong></p> <p>(<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E8%8B%B1%E8%AF%AD\" >英语</a>：<strong>Harvard architecture</strong>)是一种将程序指令储存和数据储存分开的存储器结构。<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8\" >中央处理器</a>首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作（通常是执行）。程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度，如<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/w/index.php?title=Microchip&amp;action=edit&amp;redlink=1\" >Microchip</a>公司的<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/PIC\" >PIC</a>16芯片的程序指令是14位宽度，而数据是8位宽度。</p> <p>哈佛结构的微处理器通常具有较高的执行效率。其程序指令和数据指令分开组织和储存的，执行时可以预先读取下一条指令。</p> <p>目前使用哈佛结构的<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8\" >中央处理器</a>和<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8\" >微控制器</a>有很多，除了上面提到的<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/w/index.php?title=Microchip&amp;action=edit&amp;redlink=1\" >Microchip</a>公司的<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/PIC\" >PIC</a>系列芯片，还有<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/Motorola\" >摩托罗拉公司</a>的MC68系列、<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/w/index.php?title=Zilog&amp;action=edit&amp;redlink=1\" >Zilog</a>公司的Z8系列、<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/w/index.php?title=ATMEL&amp;action=edit&amp;redlink=1\" >ATMEL</a>公司的AVR系列和<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E5%AE%89%E8%B0%8B\" >安谋</a>公司的ARM9、ARM10和ARM11。</p> <p><br /></p> <p><strong>冯&middot;诺伊曼结构</strong></p> <p><img src=\"http://my.csdn.net/uploads/201204/19/1334838473_9584.png\" style=\"max-width:500px;\" /></p> <p>（<strong>von Neumann architecture</strong>），也称<strong>普林斯顿结构</strong>，是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。本词描述的是一种实作<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%9C%96%E9%9D%88%E6%A9%9F\" >通用图灵机</a>的计算装置，以及一种相对于<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%8C%E8%A8%88%E7%AE%97\" >平行计算</a>的序列式结构参考模型（referential model）。</p> <p>本结构隐约指导了将储存装置与中央处理器分开的概念，因此依本结构设计出的计算机又称<strong>储存程式型</strong>电脑。</p> <p>最早的计算机器仅内涵固定用途的程式。现代的某些计算机依然维持这样的设计方式，通常是为了简化或教育目的。例如一个<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E5%99%A8\" >计算器</a>仅有固定的<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8\" >数学计算</a>程式，它不能拿来当作<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E6%96%87%E6%9B%B8%E8%99%95%E7%90%86\" >文书处理</a>软件，更不能拿来玩<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%81%8A%E6%88%B2\" >游戏</a>。若想要改变此机器的程式，你必须更改线路、更改结构甚至重新设计此机器。当然最早的计算机并没有设计的那个可编程化。当时所谓的“重写程式”很可能指的是纸笔设计程式步骤，接着制订工程细节，再施工将机器的电路配线或结构改变。</p> <p>而储存程式型电脑的概念改变了这一切。借由创造一组<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B\" >指令集结构</a>，并将所谓的<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E7%90%86%E8%AB%96\" >运算</a>转化成一串<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F\" >程式</a>指令的执行细节，让此机器更有弹性。借着将指令当成一种特别型态的静态资料，一台储存程式型电脑可轻易改变其程式，并在程控下改变其运算内容。<strong>冯&middot;诺伊曼结构</strong>与<strong>储存程式型电脑</strong>是互相通用的名词，其用法将于下述。而<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84\" >哈佛结构</a>则是一种将程式资料与普通资料分开储存的设计概念,但是它并未完全突破冯.诺伊曼架构。</p> <p>储存程式型概念也可让程式执行时自我修改程式的运算内容。本概念的设计动机之一就是可让程式自行增加内容或改变程式指令的内存位置，因为早期的设计都要使用者手动修改。但随着索引暂存器与间接位置存取变成硬件结构的必备机制后，本功能就不如以往重要了。而程式自我修改这项特色也被现代程式设计所弃扬，因为它会造成理解与除错的难度，且现代中央处理器的管线与快取机制会让此功能效率降低。</p> <p>从整体而言，将指令当成资料的概念使得<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80\" >组合语言</a>、<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8\" >编译器</a>与其他自动编程工具得以实现；可以用这些“自动编程的程式”，以人类较易理解的方式编写程式<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84#cite_note-0\" >[1]</a>；从局部来看，强调I/O的机器，例如<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/w/index.php?title=Bitblt&amp;action=edit&amp;redlink=1\" >Bitblt</a>，想要修改画面上的图样，以往是认为若没有客制化硬件就办不到。但之后显示这些功能可以借由“执行中编译”技术而有效达到。</p> <p>此结构当然有所缺陷，除了下列将述的<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84#.E5.86.AF.C2.B7.E8.AF.BA.E4.BC.8A.E6.9B.BC.E7.93.B6.E9.A0.B8\" >冯&middot;诺伊曼瓶颈</a>之外，修改程式很可能是非常具伤害性的，无论无意或设计错误。在一个简单的储存程式型电脑上，一个设计不良的程式可能会伤害自己、其他程式甚或是操作系统，导致<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E7%95%B6%E6%A9%9F\" >当机</a>。<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E7%B7%A9%E8%A1%9D%E5%8D%80%E6%BA%A2%E4%BD%8D\" >缓冲区溢位</a>就是一个典型例子。而创造或更改其他程式的能力也导致了<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E6%83%A1%E6%84%8F%E8%BB%9F%E9%AB%94\" >恶意软件</a>的出现。利用缓冲区溢位，一个恶意程式可以覆盖<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A\" >呼叫堆栈</a>（Call stack）并覆写程式码，并且修改其他程式<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88\" >档案</a>以造成连锁破坏。<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E4%BF%9D%E8%AD%B7\" >内存保护</a>机制及其他形式的<a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6\" >存取控制</a>可以保护意外或恶意的程式码更动。</p> <p><br /></p> v/+7dOaQXQpnxZ6K5NGX3g== zhangpy 总结一下： <br />哈佛结构或者冯诺依曼结构可以说是计算机架构，总线方式，或者是存储器结构 1454204141374 3Wx9vl0wdoE=    【DSP开发】精简指令集与复杂指令集 1454201860329 Text 1dad75de_9d002cc 【DSP开发】 <p>RISC(精简指令集计算机)和CISC(复杂指令集计算机)是当前CPU的两种架构。它们的区别在于不同的CPU设计理念和方法。</p> <p>早期的CPU全部是CISC架构，它的设计目的是要用最少的机器语言指令来完成所需的计算任务。比如对于乘法运算，在CISC架构的CPU上，您可能需要这样一条指令：MUL ADDRA, ADDRB就可以将ADDRA和ADDRB中的数相乘并将结果储存在ADDRA中。将ADDRA, ADDRB中的数据读入寄存器，相乘和将结果写回内存的操作全部依赖于CPU中设计的逻辑来实现。这种架构会增加CPU结构的复杂性和对CPU工艺的要求，但对于编译器的开发十分有利。比如上面的例子，C程序中的a*=b就可以直接编译为一条乘法指令。今天只有Intel及其兼容CPU还在使用CISC架构。</p> <p>RISC架构要求软件来指定各个操作步骤。上面的例子如果要在RISC架构上实现，将ADDRA, ADDRB中的数据读入寄存器，相乘和将结果写回内存的操作都必须由软件来实现，比如：MOV A, ADDRA; MOV B, ADDRB; MUL A, B; STR ADDRA, A。这种架构可以降低CPU的复杂性以及允许在同样的工艺水平下生产出功能更强大的CPU，但对于编译器的设计有更高的要求。</p> <p>&nbsp;</p> <p>另：</p> <p><strong>CISC</strong><a target=\"_blank\" rel=\"nofollow\" ><strong>（复杂指令集）</strong></a><strong>与RISC（精简指令集）的区别</strong></p> <p><strong><span style=\"text-decoration:underline;\" >复杂指令集计算机(CISC)</span></strong><br />　　长期来，计算机性能的提高往往是通过增加硬件的复杂性来获得．随着集成电路技术．特别是VLSI（超大规模集成电路）技术的迅速发展，为了软件编程方便和提高程序的运行速度，硬件工程师采用的办法是不断增加可实现复杂功能的指令和多种灵活的编址方式．甚至某些指令可支持高级语言语句归类后的复杂操作．至使硬件越来越复杂，造价也相应提高．为实现复杂操作，微处理器除向程序员提供类似各种寄存器和机器指令功能外．还通过存于只读存贮器(ROM)中的微程序来实现其极强的功能&nbsp;，傲处理在分析每一条指令之后执行一系列初级指令运算来完成所需的功能，这种设计的型式被称为复杂指令集计算机(Complex Instruction Set Computer-CISC)结构．一般CISC计算机所含的指令数目至少300条<br />以上，有的甚至超过500条．<br /><strong><span style=\"text-decoration:underline;\" >精简指令集计算机(RISC)</span></strong><br />　　采用复杂指令系统的计算机有着较强的处理高级语言的能力．这对提高计算机的性能是有益的．当计算机的设计沿着这条道路发展时．有些人没有随波逐流．他们回过头去看一看过去走过的道路，开始怀疑这种传统的做法：IBM公司没在纽约Yorktown的JhomasI.Wason研究中心于1975年组织力量研究指令系统的合理性问题．因为当时已感到，日趋庞杂的指令系统不但不易实现．而且还可能降低系统性能．1979年以帕特逊教授为首的一批科学家也开始在美国加册大学伯克莱分校开展这一研究．结果表明，CISC存在许多缺点．首先．在这种计算机中．各种指令的使用率相差悬殊：一个典型程序的运算过程所使用的80％指令．只占一个处理器指令系统的20％．事实上最频繁使用的指令是取、存和加这些最简单的指令．这样-来，长期致力于复杂指令系统的设计，实际上是在设计一种难得在实践中用得上的指令系统的处理器．同时．复杂的指令系统必然带来结构的复杂性．这不但增加了设计的时间与成本还容易造成设计失误．此外．尽管VLSI技术现在已达到很高的水平，但也很难把CISC的全部硬件做在一个芯片上，这也妨碍单片计算机的发展．在CISC中，许多复杂指令需要极复杂的操作，这类指令多数是某种高级语言的直接翻版，因而通用性差．由于采用二级的微码执行方式，它也降低那些被频繁调用的简单指令系统的运行速度．因而．针对CISC的这些弊病．帕特逊等人提出了精简指令的设想即指令系统应当只包含那些使用频率很高的少量指令．并提供一些必要的指令以支持操作系统和高级语言．按照这个原则发展而成的计算机被称为精简指令集计算机(Reduced Instruction Set Computer-RISC)结构．简称RISC．</p> <p><a target=\"_blank\" rel=\"nofollow\" ><strong><span style=\"text-decoration:underline;\" >CISC</span></strong></a><strong><span style=\"text-decoration:underline;\" >与RISC的区别</span></strong><strong><span style=\"text-decoration:underline;\" >　</span></strong></p> <p>　　我们经常谈论有关&quot;PC&quot;与&quot;Macintosh&quot;的话题，但是又有多少人知道以Intel公司X86为核心的PC系列正是基于CISC体系结构，而&nbsp;Apple公司的Macintosh则是基于RISC体系结构，CISC与RISC到底有何区别？<br />　　从硬件角度来看CISC处理的是不等长指令集，它必须对不等长指令进行分割，因此在执行单一指令的时候需要进行较多的处理工作。而RISC执行的是等长精简指令集，CPU在执行指令的时候速度较快且性能稳定。因此在并行处理方面RISC明显优于CISC，RISC可同时执行多条指令，它可将一条指令分割成若干个进程或线程，交由多个处理器同时执行。由于RISC执行的是精简指令集，所以它的制造工艺简单且成本低廉。<br />　　从软件角度来看，CISC运行的则是我们所熟识的DOS、Windows操作系统。而且它拥有大量的应用程序。因为全世界有65%以上的软件厂商都理为基于CISC体系结构的PC及其兼容机服务的，象赫赫有名的Microsoft就是其中的一家。而RISC在此方面却显得有些势单力薄。虽然在RISC上也可运行DOS、Windows，但是需要一个翻译过程，所以运行速度要慢许多。<br />　　目前CISC与RISC正在逐步走向融合，Pentium Pro、Nx586、K5就是一个最明显的例子，它们的内核都是基于RISC体系结构的。他们接受CISC指令后将其分解分类成RISC指令以便在遇一时间内能够执行多条指令。由此可见，下一代的CPU将融合CISC与RISC两种技术，从软件与硬件方面看二者会取长补短。</p> <p><br /></p> v/+7dOaQXQpnxZ6K5NGX3g== zhangpy 总结一下： <br />复杂，指的就是指令集比较复杂，一是指令多，杂，二是功能复杂，采用二级微码执行方式，它也降低那些被频繁调用的简单指令系统的运行速度。 <br />精简，指的就是指令集比较简单，一是指令少，精，二是功能简单，都是一些简单的指令，但是需要编译器和软件去自行组合，而不是由CPU来管理，所以降低了CPU的设计难度。 1454202429105 3Wx9vl0wdoE=    【科普杂谈】如何订阅顶级期刊杂志 1454050641635 1454050659775 Text 1dad75de_9cbcabe 【科普杂谈】 <p>著作权归作者所有。<br />商业转载请联系作者获得授权，非商业转载请注明出处。<br />作者：鹿鳴<br />链接：http://www.zhihu.com/question/21307027/answer/19428811<br />来源：知乎<br /><br /></p> <p>我一般是通过RSS源来订阅我所关注的TOP期刊：PAMI，TIP，IJCV，JMLR或者arxiv上的相关板块的文章。这样就可以及时地关注新鲜出炉的文章，紧跟大牛的动向。<br />RSS的订阅工具有很多，我原来使用的是Google Reader，现在使用的是Ino Reader/AOL Reader/Digg Reader等，不过都不如曾经的真爱Google Reader。<br /><br />下面附几个TOP期刊的RSS源：<br />PAMI：<a target=\"_blank\" rel=\"nofollow\" href=\"//link.zhihu.com/?target=http%3A//ieeexplore.ieee.org/rss/TOC34.XML\" >http://ieeexplore.ieee.org/rss/TOC34.XML</a><br />TIP：<a target=\"_blank\" rel=\"nofollow\" href=\"//link.zhihu.com/?target=http%3A//ieeexplore.ieee.org/rss/TOC83.XML\" >http://ieeexplore.ieee.org/rss/TOC83.XML</a><br />JMLR：<a target=\"_blank\" rel=\"nofollow\" href=\"//link.zhihu.com/?target=http%3A//jmlr.org/jmlr.xml\" >http://jmlr.org/jmlr.xml</a><br /><br />最后的附图是我的Ino Reader中订阅的一些期刊：<br />&amp;lt;img src=&quot;https://pic2.zhimg.com/e25712bfebb61508ac9fbfd79e985bf5_b.jpg&quot; data-rawwidth=&quot;270&quot; data-rawheight=&quot;355&quot; class=&quot;content_image&quot; width=&quot;270&quot;&amp;gt;<img src=\"https://pic2.zhimg.com/e25712bfebb61508ac9fbfd79e985bf5_b.jpg\" style=\"max-width:500px;\" /><br /><br />/**************************************补充更新（2015-05-27）********************************************/<br />在评论中有人问到关于IEEE期刊的RSS源在哪里的问题，所以这里更新一下答案。<br />下面以Pattern Analysis and Machine Intelligence期刊为例。<br />1.&nbsp;首先进入IEEE官方网站（<a target=\"_blank\" rel=\"nofollow\" href=\"//link.zhihu.com/?target=http%3A//ieeexplore.ieee.org/Xplore/dynhome.jsp\" >IEEE Xplore Digital Library</a>）搜索该期刊。<br />2.&nbsp;进入下述页面后就可以找到该期刊的RSS订阅源了。<br />&amp;lt;img src=&quot;https://pic3.zhimg.com/2ff6901192aa209c648b6bb0dbbf3836_b.jpg&quot; data-rawwidth=&quot;1584&quot; data-rawheight=&quot;778&quot; class=&quot;origin_image zh-lightbox-thumb&quot; width=&quot;1584&quot; data-original=&quot;https://pic3.zhimg.com/2ff6901192aa209c648b6bb0dbbf3836_r.jpg&quot;&amp;gt;3.&nbsp;最后将RSS订阅源加入到你的RSS Reader中即可。<img src=\"https://pic3.zhimg.com/2ff6901192aa209c648b6bb0dbbf3836_b.jpg\" style=\"max-width:500px;\" />3.&nbsp;最后将RSS订阅源加入到你的RSS Reader中即可。</p> <p><br /></p>  【机器学习与模式识别】GitHub上最好的100个DeepLearning 1454035945559 Text 1dad75de_9cb3a9c 【机器学习与模式识别】 <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/\" ><img src=\"http://meta-guide.com/wp-content/uploads/2015/11/cropped-AI-ConsultingbyMarcus-L-Endicott-3.png\" style=\"max-width:500px;\" /></a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/\" >Meta-Guide.com</a></p> <ul> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/\" >Home</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/consulting\" >Consulting</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/bibliography\" >Bibliography</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/videography\" >Videography</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/links-to-similar-projects\" >Links</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/html-sitemap\" >Sitemap</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/tag-index\" >Tags</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/about\" >About</a></p></li> </ul>&nbsp; <p>100 Best GitHub: Deep Learning</p> &nbsp; <a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/\" >Home</a>&nbsp;/&nbsp; <a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/software-meta-guide\" >Software Meta Guide</a>&nbsp;/&nbsp;100 Best GitHub: Deep Learning <ul> <li><p><br /></p></li> </ul> <p><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/search?q=%22deep-learning%22\" ><img src=\"http://meta-guide.com/wp-content/uploads/2015/04/githubDeep-Learning415.jpg\" style=\"max-width:500px;\" /></a></p> <p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://en.wikipedia.org/wiki/Deep_learning\" >Deep Learning</a></strong></p> <p>Notes:</p> <p>This 100 item list represents a search of github for “deep-learning”, Apr 2015.&nbsp; As of 2015, this is the most popular webpage on the <strong>Meta-Guide.com</strong> website.</p> <p>Resources:</p> <ul> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.aforgenet.com/\" ><strong>aforgenet</strong>.com</a>&nbsp;..&nbsp;(<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.microsoft.com/net\" >microsoft.com/net</a>&nbsp;+&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://accord-framework.net/\" >accord-framework.net</a>&nbsp;= Windows)&nbsp;..&nbsp;{<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.google.com/search?q=related:aforgenet.com\" >related:</a>}</p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://caffe.berkeleyvision.org/\" ><strong>caffe</strong>.berkeleyvision.org</a>&nbsp;.. speed makes Caffe perfect for industry use ..&nbsp;{<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.google.com/search?q=related:caffe.berkeleyvision.org\" >related:</a>}</p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://developer.nvidia.com/cuDNN\" >developer.nvidia.com/<strong>cuDNN</strong></a>&nbsp;.. GPU-accelerated library of primitives for deep neural networks ..&nbsp;{<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.google.com/search?q=related:developer.nvidia.com/cuDNN\" >related:</a>}</p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/maddin79/darch\" >github.com/maddin79/<strong>darch</strong></a>&nbsp;.. create deep architectures in the R programming language {<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.google.com/search?q=related:github.com/maddin79/darch\" >related:</a>}</p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://deeplearning4j.org/\" ><strong>deeplearning4j</strong>.org</a>&nbsp;.. commercial-grade deep-learning library written in Java ..&nbsp;{<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.google.com/search?q=related:deeplearning4j.org\" >related:</a>}</p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://keras.io/\" ><strong>keras</strong>.io</a>&nbsp;.. Theano-based Deep Learning library {<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.google.com/search?q=related:keras.io\" >related:</a>}</p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://deeplearning.net/software/theano/\" >deeplearning.net/software/<strong>theano</strong></a>&nbsp;.. supports GPU based model training and automatic code optimization in Python ..&nbsp;{<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.google.com/search?q=related:deeplearning.net/software/theano\" >related:</a>}</p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://h2o.ai/\" ><strong>h2o</strong>.ai</a>&nbsp;.. an open source parallel processing engine for machine learning {<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.google.com/search?q=related:h2o.ai\" >related:</a>}</p></li> </ul> <p>References:</p> <ul> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://neuralnetworksanddeeplearning.com/\" >Neural Networks and Deep Learning</a>&nbsp;(2014)</p></li> </ul> <p>See also:</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/videography/100-best-deep-belief-network-videos/\" >100 Best Deep Belief Network Videos</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/videography/100-best-deep-learning-videos/\" >100 Best Deep Learning Videos</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/videography/100-best-deepmind-videos/\" >100 Best DeepMind Videos</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/videography/100-best-matlab-videos/\" >100 Best MATLAB Videos</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/dialog-systems/deep-belief-network-dialog-systems/\" >Deep Belief Network &amp; Dialog Systems</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/dialog-systems/deep-learning-dialog-systems-2014/\" >Deep Learning &amp; Dialog Systems 2014</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/data-processing/automated-reasoning/deep-reasoning-systems/\" >Deep Reasoning Systems</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/data-processing/nlp/dnlp/deepdive/\" >DeepDive</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/data-processing/nlp/dnlp/\" >DNLP (Deep Natural Language Processing)</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/dialog-systems/matlab-dialog-systems-2011/\" >MATLAB &amp; Dialog Systems 2011</a>&nbsp;|<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/dialog-systems/matlab-dialog-systems-2012/\" >MATLAB &amp; Dialog Systems 2012</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/dialog-systems/matlab-dialog-systems-2013/\" >MATLAB &amp; Dialog Systems 2013</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/dialog-systems/matlab-dialog-systems-2014/\" >MATLAB &amp; Dialog Systems 2014</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/data-processing/nlp/dnlp/skipgram-deep-learning-2014/\" >Skipgram &amp; Deep Learning 2014</a>&nbsp;|&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/data-processing/nlp/dnlp/word2vec-neural-network/\" >Word2vec Neural Network</a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/search?q=%22deep-learning%22\" >“deep-learning”</a>&nbsp;[100x Apr 2015]</p> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/yusugomori/DeepLearning\" >yusugomori/DeepLearning</a></strong>&nbsp;.. Deep Learning (Python, C/C++, Java, Scala, Go)</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/lisa-lab/DeepLearningTutorials\" >lisa-lab/DeepLearningTutorials</a></strong>&nbsp;.. Deep Learning Tutorial notes and code. See the wiki for more info.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/qiuwch/DeepLearning\" >qiuwch/DeepLearning</a></strong>&nbsp;.. Deep learning code by Hinton</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/mnielsen/neural-networks-and-deep-learning\" >mnielsen/neural-networks-and-deep-learning</a></strong>&nbsp;.. Code samples for my book “Neural Networks and Deep Learning”</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/ChristosChristofidis/awesome-deep-learning\" >ChristosChristofidis/awesome-deep-learning</a></strong>&nbsp;.. A curated list of awesome Deep Learning tutorials, projects and communities.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/wendykan/DeepLearningMovies\" >wendykan/DeepLearningMovies</a></strong>&nbsp;.. Kaggle’s competition for using Google’s word2vec package for sentiment analysis</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/jaberg/DeepLearningBenchmarks\" >jaberg/DeepLearningBenchmarks</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/memkite/DeepLearningBibliography\" >memkite/DeepLearningBibliography</a></strong>&nbsp;.. Bibliography for Publications about Deep Learning using GPU</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/BVLC/caffe\" >BVLC/caffe</a></strong>&nbsp;.. Caffe: a fast open framework for deep learning.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/nitishsrivastava/deepnet\" >nitishsrivastava/deepnet</a></strong>&nbsp;.. Implementation of some deep learning algorithms.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/andersbll/deeppy\" >andersbll/deeppy</a></strong>&nbsp;.. Deep learning in Python</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/dmlc/cxxnet\" >dmlc/cxxnet</a></strong>&nbsp;.. fast, concise, distributed deep learning framework</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/NVIDIA/DIGITS\" >NVIDIA/DIGITS</a></strong>&nbsp;.. Deep Learning GPU Training System</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/dcatcher9/DeepLearning\" >dcatcher9/DeepLearning</a></strong>&nbsp;.. Simple and Cutting-edge Deep Learning Library accelerated with GPU using C++ AMP</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/Syndrome777/DeepLearningTutorial\" >Syndrome777/DeepLearningTutorial</a></strong>&nbsp;.. Deep learning tutorial in Chinese/?????????</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/vishwa-raman/DeepLearning\" >vishwa-raman/DeepLearning</a></strong>&nbsp;.. Code to build MLP models for outdoor head orientation tracking</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/gonzojive/deep-learning\" >gonzojive/deep-learning</a></strong>&nbsp;.. Deep learning algorithms: A sparse autoencoder (and someday more algorithms), implemented in Common Lisp.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/greeness/deep-learning\" >greeness/deep-learning</a></strong>&nbsp;.. Collection of deep learning resources.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/hannes-brt/hebel\" >hannes-brt/hebel</a></strong>&nbsp;.. GPU-Accelerated Deep Learning Library in Python</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/zygmuntz/kaggle-blackbox\" >zygmuntz/kaggle-blackbox</a></strong>&nbsp;.. Deep learning made easy</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/deeplearning4j/deeplearning4j\" >deeplearning4j/deeplearning4j</a></strong>&nbsp;.. Deep Learning for Java, Scala &amp; Clojure on Hadoop &amp; Spark</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/ty4z2008/Qix\" >ty4z2008/Qix</a></strong>&nbsp;.. Node.Js?Golang?Machine Learning?PostgreSQL?Deep Learning</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/fchollet/keras\" >fchollet/keras</a></strong>&nbsp;.. Theano-based Deep Learning library</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/ahelou2/deep-learning-scene-recognition\" >ahelou2/deep-learning-scene-recognition</a></strong>&nbsp;.. Using convolutional deep belief nets to learn natural scene representations</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/songjmcn/deep_learning\" >songjmcn/deep_learning</a></strong>&nbsp;..&nbsp;????</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/dusano/DeepLearning\" >dusano/DeepLearning</a></strong>&nbsp;.. Python implementation of UFLDL tutorial code</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/zewemli/DeepLearning\" >zewemli/DeepLearning</a></strong>&nbsp;.. An OpenCL implementation of Deep Belief Networks and Restricted Boltzmann Machines</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/nyanp/tiny-cnn\" >nyanp/tiny-cnn</a></strong>&nbsp;.. deep learning(convolutional neural networks) in C++11/TBB</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/bashrc/libdeep\" >bashrc/libdeep</a></strong>&nbsp;.. A deep learning library for C/C++</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/phanein/deepwalk\" >phanein/deepwalk</a></strong>&nbsp;.. DeepWalk – Deep Learning for Graphs</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/amaas/stanford_dl_ex\" >amaas/stanford_dl_ex</a></strong>&nbsp;.. Programming exercises for the Stanford Unsupervised Feature Learning and Deep Learning Tutorial</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/ivan-vasilev/neuralnetworks\" >ivan-vasilev/neuralnetworks</a></strong>&nbsp;.. java deep learning algorithms and deep neural networks with gpu acceleration</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/guoding83128/OpenDL\" >guoding83128/OpenDL</a></strong>&nbsp;.. The Deep Learning training framework on Spark</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/karpathy/convnetjs\" >karpathy/convnetjs</a></strong>&nbsp;.. Deep Learning in Javascript. Train Convolutional Neural Networks (or ordinary ones) in your browser.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/jatinshah/ufldl_tutorial\" >jatinshah/ufldl_tutorial</a></strong>&nbsp;.. Stanford Unsupervised Feature Learning and Deep Learning Tutorial</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/bashrc/libdeep\" >bashrc/libdeep</a></strong>&nbsp;.. A deep learning library for C/C++</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/nyanp/tiny-cnn\" >nyanp/tiny-cnn</a></strong>&nbsp;.. deep learning(convolutional neural networks) in C++11/TBB</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/phanein/deepwalk\" >phanein/deepwalk</a></strong>&nbsp;.. DeepWalk – Deep Learning for Graphs</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/RichardKelley/deep-learning\" >RichardKelley/deep-learning</a></strong>&nbsp;.. Repo for my intro course on Deep Learning</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/ylecun/deep-learning-course\" >ylecun/deep-learning-course</a></strong>&nbsp;.. Examples and exercises in Torch for the Deep Learning course at NYU</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/vkaynig/ComputeFest2015_DeepLearning\" >vkaynig/ComputeFest2015_DeepLearning</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/rasmusbergpalm/DeepLearnToolbox\" >rasmusbergpalm/DeepLearnToolbox</a></strong>&nbsp;.. Matlab/Octave toolbox for deep learning. Includes Deep Belief Nets, Stacked Autoencoders, Convolutional Neural Nets, Convolutional Autoencoders and vanilla Neural Nets. Each method has examples to get you started.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/zellyn/deeplearning-class-2011\" >zellyn/deeplearning-class-2011</a></strong>&nbsp;.. Code for Deep Learning class at Google</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/nusinga/singa\" >nusinga/singa</a></strong>&nbsp;.. distributed deep learning training system</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/jdeng/rbm-mnist\" >jdeng/rbm-mnist</a></strong>&nbsp;.. C++ 11 implementation of Geoff Hinton’s Deep Learning matlab code</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/dirkneumann/deepdist\" >dirkneumann/deepdist</a></strong>&nbsp;.. Lightning-Fast Deep Learning on Spark</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/einsnull/DeepLearningToolBox\" >einsnull/DeepLearningToolBox</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/priyaank/deep-learning\" >priyaank/deep-learning</a></strong>&nbsp;.. Deep Learning Reading List of some of the materials i found on the web for Deep Learning beginners.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/xrobin/DeepLearning\" >xrobin/DeepLearning</a></strong>&nbsp;.. R package for deep learning</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/JimmyLin192/DeepLearning\" >JimmyLin192/DeepLearning</a></strong>&nbsp;.. Github repository for group study towards Deep learning</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/colah/Visualizing-Deep-Learning\" >colah/Visualizing-Deep-Learning</a></strong>&nbsp;.. A series of blog posts on visualizing deep learning.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/TorontoDeepLearning/TorontoDeepLearning.github.io\" >TorontoDeepLearning/TorontoDeepLearning.github.io</a></strong>&nbsp;.. Webpage for Toronto Deep Learning Code</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/chonglinsun/DeepLearning\" >chonglinsun/DeepLearning</a></strong>&nbsp;.. Stanford Deep Learning</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/SnippyHolloW/DL4H\" >SnippyHolloW/DL4H</a></strong>&nbsp;.. Deep learning for hackers: a hands-on approach to machine learning and deep learning.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/erikbern/deep-pink\" >erikbern/deep-pink</a></strong>&nbsp;.. Deep Pink is a chess AI that learns to play chess using deep learning.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/tariqdaouda/Mariana\" >tariqdaouda/Mariana</a></strong>&nbsp;.. The cutest Deep Learning Framework ever</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/Lewuathe/n42\" >Lewuathe/n42</a></strong>&nbsp;.. Deep learning module for nodejs</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/BVLC/caffe-tutorial\" >BVLC/caffe-tutorial</a></strong>&nbsp;.. DIY Deep Learning for Vision: a Hands-On Tutorial with Caffe</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/nicholas-leonard/dp\" >nicholas-leonard/dp</a></strong>&nbsp;.. A deep learning library for streamlining research and development using the Torch7 distribution.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/lucktroy/regression-deep-learning\" >lucktroy/regression-deep-learning</a></strong>&nbsp;.. Deep learning for regression</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/kahitomi/Deep-Learning\" >kahitomi/Deep-Learning</a></strong>&nbsp;.. It is for my MSc final project</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/baojie/senna\" >baojie/senna</a></strong>&nbsp;.. a fork of Ronan Collobert’s senna deep learning based NLP tools</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/pannous/caffe-speech-recognition\" >pannous/caffe-speech-recognition</a></strong>&nbsp;.. Speech Recognition with the Caffe deep learning framework</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/deeplearningparis/dl-machine\" >deeplearningparis/dl-machine</a></strong>&nbsp;.. Scripts to setup a GPU / CUDA-enabled compute server with libraries for deep learning</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/howarth/DeepLearnLab\" >howarth/DeepLearnLab</a></strong>&nbsp;.. Deep Learning in Matlab</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/pannous/caffe-ocr\" >pannous/caffe-ocr</a></strong>&nbsp;.. OCR with caffe deep learning framework</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/jcjohnson/DeepLearningTheory\" >jcjohnson/DeepLearningTheory</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/primaryobjects/deep-learning\" >primaryobjects/deep-learning</a></strong>&nbsp;.. Simple example of using the Accord .NET C# library to implement a deep-learning neural network (deep belief network) with machine learning. Solves XOR and an ASCII digit dataset.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/justanotherbrain/deep-learning\" >justanotherbrain/deep-learning</a></strong>&nbsp;.. Deep Learning with Yann LeCun</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/DrkSephy/Deep-Learning\" >DrkSephy/Deep-Learning</a></strong>&nbsp;.. A collection of Deep Learning Algorithms</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/mhlee1116/DeepLearningDropout\" >mhlee1116/DeepLearningDropout</a></strong>&nbsp;.. MATLAB implementation of Deep Learning with dropout</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/taranai/DeepLearning\" >taranai/DeepLearning</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/JoseLlarena/Deep-Learning-NER\" >JoseLlarena/Deep-Learning-NER</a></strong>&nbsp;.. Re-Implementation of named entitiy recognition using deep neural networks.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/roles/deep_learning\" >roles/deep_learning</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/terrychenism/Deep_Learning_UFLDL\" >terrychenism/Deep_Learning_UFLDL</a></strong>&nbsp;.. The practice of Deep Learning</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/jasonustc/DeepLearning\" >jasonustc/DeepLearning</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/carpedm20/neural-networks-and-deep-learning-ko\" >carpedm20/neural-networks-and-deep-learning-ko</a></strong>&nbsp;.. Translation of Neural Networks and Deep Learning by Michael Nielsen</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/solrac-ceam/DIP_DeepLearning\" >solrac-ceam/DIP_DeepLearning</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/yifeng-li/deep_learning\" >yifeng-li/deep_learning</a></strong>&nbsp;.. Deep Learning Package in Python Based on The Deep Learning Tutorials and Theano</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/zhushun0008/deepLearningExerciseOfStanfordOnline\" >zhushun0008/deepLearningExerciseOfStanfordOnline</a></strong>&nbsp;.. This project includes how to implement sparse autoEncoder, Vectorization, and so on.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/poweltalwar/DeepLearning\" >poweltalwar/DeepLearning</a></strong>&nbsp;.. a repo for my B.tech project</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/uchicago-cs/deepdish\" >uchicago-cs/deepdish</a></strong>&nbsp;.. Deep learning experiments at the University of Chicago</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/wichtounet/dll\" >wichtounet/dll</a></strong>&nbsp;.. Deep Learning Library (DLL) for C++</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/cran/deepnet\" >cran/deepnet</a></strong>&nbsp;.. deep learning toolkit in R</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/yajiemiao/pdnn\" >yajiemiao/pdnn</a></strong>&nbsp;.. PDNN: A Python Toolkit for Deep Learning. http://www.cs.cmu.edu/~ymiao/pdnntk.html</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/tleyden/elastic-thought\" >tleyden/elastic-thought</a></strong>&nbsp;.. Scalable REST API for the Caffe deep learning framework</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/phvu/deeplearn\" >phvu/deeplearn</a></strong>&nbsp;.. Deep Learning in C++</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/mihaelacr/pydeeplearn\" >mihaelacr/pydeeplearn</a></strong>&nbsp;.. Deep learning API with emotion recognition application</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/ccorcos/deep-learning\" >ccorcos/deep-learning</a></strong>&nbsp;.. Some deep learning models and experiments built with Theano.</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/revantkumar/Deep-Learning\" >revantkumar/Deep-Learning</a></strong>&nbsp;.. Solutions to Assignments of Deep Learning Class (CS-8803DL at Gatech)</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/YabinHu/OclDeepLearning\" >YabinHu/OclDeepLearning</a></strong>&nbsp;.. A deep learning implementation with OpenCL</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/jhoward/deep_learning\" >jhoward/deep_learning</a></strong>&nbsp;.. Stanford deep learning tutorial</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/romaindeveaud/deep-learning-nlp\" >romaindeveaud/deep-learning-nlp</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/manojstonybrook/Deep_Learning\" >manojstonybrook/Deep_Learning</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/ajtulloch/DeepLearning.jl\" >ajtulloch/DeepLearning.jl</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/wendykan/AWSGPU_DeepLearning\" >wendykan/AWSGPU_DeepLearning</a></strong>&nbsp;.. Code to setup AWS GPU instance to run Daniel Nouri’s Facial Keypoints competition</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/cdathuraliya/deep-learning\" >cdathuraliya/deep-learning</a></strong>&nbsp;..</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/alexanderrich/DeepLearning\" >alexanderrich/DeepLearning</a></strong>&nbsp;.. projects for deep learning class</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/Leonardo-mbc/deep-learning\" >Leonardo-mbc/deep-learning</a></strong>&nbsp;..&nbsp;?????????????????</p></li> </ul> <ul> <li><p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/YUXingrui/Deep-Learning\" >YUXingrui/Deep-Learning</a></strong>&nbsp;.. Deep Learning ??????</p></li> </ul> Top Content <ol> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/software-meta-guide/100-best-github-deep-learning\" >100 Best GitHub: Deep Learning</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/videography/100-best-appinventor-videos\" >100 Best AppInventor Videos</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/videography/100-best-informatica-powercenter-videos\" >100 Best Informatica PowerCenter Videos</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/software-meta-guide/100-best-github-artificial-intelligence\" >100 Best GitHub: Artificial Intelligence</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/videography/100-best-selenium-tutorial-videos\" >100 Best Selenium Tutorial Videos</a></p></li> </ol>Recent Changes <ul> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/data-processing/summarization/intellexer\" >Intellexer</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/integration/olympusravenclaw-dialog-management-framework\" >Olympus/Ravenclaw Dialog Management Framework</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/integration/dialog-management-middleware\" >Dialog Management Middleware</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/dialog-systems/modules/dialog-management-module\" >Dialog Management Module</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"http://meta-guide.com/dialog-manager\" >Dialog Manager</a></p></li> </ul> <a target=\"_blank\" rel=\"nofollow\" href=\"http://feeds.feedburner.com/AnswersByMarcusLEndicottOnQuora\" ><img src=\"http://meta-guide.com/wp-includes/images/rss.png\" style=\"max-width:500px;\" /></a> <a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/profile/Marcus-L-Endicott/answers\" >Quora</a> <ul> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/If-extreme-work-is-put-into-development-of-a-chatbot-will-it-have-a-proper-answer-to-most-questions/answer/Marcus-L-Endicott\" >If extreme work is put into development of a chatbot, will it have a proper answer to most questions?</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/What-is-the-most-advanced-conversational-AI-I-can-speak-to-right-now/answer/Marcus-L-Endicott\" >What is the most advanced conversational AI I can speak to right now?</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/Is-there-any-syntactic-analyzer-for-English/answer/Marcus-L-Endicott\" >Is there any syntactic analyzer for English?</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/Where-are-some-good-research-papers-to-learn-about-evaluating-semantic-similarity/answer/Marcus-L-Endicott\" >Where are some good research papers to learn about evaluating semantic similarity?</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/Can-Amazon-Echo-Siri-Google-Now-or-Cortana-intelligently-communicate-with-each-other/answer/Marcus-L-Endicott\" >Can Amazon Echo, Siri, Google Now or Cortana intelligently communicate with each other?</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/How-does-luka-ai-work/answer/Marcus-L-Endicott\" >How does luka.ai work?</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/Is-there-a-tagged-touristic-destination-dataset-similar-to-last-fm/answer/Marcus-L-Endicott\" >Is there a tagged touristic destination dataset (similar to last.fm)?</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/What-is-the-best-open-source-natural-language-processor-for-doing-concept-searches/answer/Marcus-L-Endicott\" >What is the best open-source, natural language processor for doing concept searches?</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/Why-is-it-not-a-good-idea-to-generate-paragraphs-from-a-Twitter-stream-about-a-selected-topic/answer/Marcus-L-Endicott\" >Why is it not a good idea to generate paragraphs from a Twitter stream about a selected topic?</a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.quora.com/What-will-be-the-application-of-a-bot-in-todays-world-which-creates-memes-jokes/answer/Marcus-L-Endicott\" >What will be the application of a bot in todays world which creates memes/jokes?</a></p></li> </ul> <p>Contents of this website may not be reproduced without prior written permission.</p> <p>Copyright &copy; 2011-2016 <a target=\"_blank\" rel=\"nofollow\" href=\"http://mendicott.com/\" >Marcus L Endicott</a></p> <ul> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://twitter.com/mendicot\" ><img src=\"http://meta-guide.com/wp-content/uploads/2015/11/t.gif\" style=\"max-width:500px;\" /></a></p></li> <li><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.linkedin.com/in/mendicott\" ><img src=\"http://meta-guide.com/wp-content/uploads/2015/11/social-icon-linkedin.png\" style=\"max-width:500px;\" /></a></p></li> <li><p><br /></p></li> </ul> <p><br /></p>  【DSP开发】TI DSP开发相关参考资料 1453968832954 Text 1dad75de_9c9e8c2 <p><br /></p> <p>这个网站有达芬奇系列的相关资料，包括相关开发板的原理图和Geber文件&nbsp;&nbsp;资料较全&nbsp;&nbsp;很有帮助</p> <p><br /></p> <p>http://c6000.spectrumdigital.com/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6000系列的</p> <p>http://c5000.spectrumdigital.com/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5000系列的</p> <p>http://c2000.spectrumdigital.com/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2000系列的</p> <p><br /></p>  【DSP开发】Rapid IO 1453778466263 Text 1dad75de_9c330ad 【DSP开发】 <p><img src=\"http://focus.ti.com.cn/cn/graphics/shared/contributed_articles/CA_rapid_io_09.gif\" style=\"max-width:500px;\" /><br /></p>  【科普杂谈】intel i7 1453718612696 Text 1dad75de_9c17772 【科普杂谈】 <p><br />自去年Intel发布第四代Haswell处理器之后，虽然有了首次引入FIVR（集成供电系统）进CPU内部这一跨越式发展，简化了主板供电设计，但性能提升不大、功耗发热增加这些表面问题依然使得众多消费者不买账。一年之后，Intel未能如期按照钟摆策略发布第五代Broadwell处理器，而是于2014年5月12日推出了一个名为“Haswell Refresh”的产品线来顶上（以下将Haswell Refresh简称为HSWR或HSW-R），并推出了对应的Z97及H97芯片组。<br /><br />那么这个Haswell Refresh到底是何方神圣，和Haswell又有何区别？先看看本次发布的产品线。本次发布的桌面版Haswell Refresh处理器多达26款，其中包含四款i7、9款i5、5款i3和奔腾，以及3款赛扬。<br /><img src=\"http://bbs.pceva.com.cn/data/attachment/forum/201407/23/174708r7q7utmq33tq99b7.jpg\" style=\"max-width:500px;\" /><br /><br />Core i7-4790依然是使用LGA 1150接口，兼容Z97主板，Z87主板升级BIOS后也可以使用，背面的走线和电容一个也没变。<br /><img src=\"http://bbs.pceva.com.cn/data/attachment/forum/201407/23/174742q37a3ay3pn4c34m3.jpg\" style=\"max-width:500px;\" />&nbsp;<br /><br />相比Z87，是不是外观都差不多？甚至PCB上的走线都一样？<br /><img src=\"http://bbs.pceva.com.cn/data/attachment/forum/201407/23/174810r3eizekww4kkw27l.jpg\" style=\"max-width:500px;\" /><br /><br />SATA Express接口曾经被Intel官方在9系列芯片组中否决，表示不支持，但最后我们还是在原生接口上看到了它。但根据Intel的说法是，这个SATA-E接口并不是基于最新的SATA 3.2规范，而是旧的SATA 3.0规范（做8系列芯片组的时候还没3.2规范）。所以虽然正牌3.2规范的SATA-E接口可通过复用PCIE 2x达到16Gbps的速率，但估计9系列芯片组的“未成熟版”SATA-E做不到，而且不知道哪个主板会把2x PCIE带宽浪费在这样一个鸡肋接口上，所以目前你可以把它看成是两根SATA线接同一个设备，以达到带宽翻倍的效果。<br /><img src=\"http://bbs.pceva.com.cn/data/attachment/forum/201407/23/174910dcj3002mgh5zjjcs.jpg\" style=\"max-width:500px;\" /><br /><br />Core i7-4790性能表现<br /><br />测试平台：<br />CPU：Intel Core i7-4790<br />主板：Gigabyte Z97X-SOC Force<br />内存：Avexir DDR3-2800 CL12 4GBx2<br />显卡：Galaxy GTX 760 Gamer<br />硬盘：Plextor PX-256M5Pro<br />电源：Enermax Revolution 85+ 1050W<br />散热器：Prolimatech Megahalems Rev.B<br /><br />CPU-Z识别主板及显卡信息：<br /><img src=\"http://bbs.pceva.com.cn/data/attachment/forum/201407/23/174939fpn2wmaae0n13mo1.png\" style=\"max-width:500px;\" />&nbsp;<br /><br />我们看到，i7-4790和4770K默频相比有一定提升，和模拟4790的4770K相比基本表现完全相同，而4770K和3770K超频到4.5G之后轻易超越4790，基本上和预期结果没出入。另外4790超频内存到DDR3-2800之后，性能稍微有一点提升，但并不明显。<br /><br />从加权综合性能对比来看，以4790默频为参照，4770K默频大约落后2.6-2.7%，基本跟频率差别百分比相同，超频内存之后4790的单线程和多线程效能分别提升1.5%和4.9%，区别也不是很明显，而模拟4790的4770K由于频率一样，性能几乎也一样。<br /><img src=\"http://bbs.pceva.com.cn/data/attachment/forum/201407/23/174957ftbgtszxecjzb71b.png\" style=\"max-width:500px;\" />&nbsp;<br /><br />我们手上这颗i7 4790最低可降压至1.06V左右跑完Prime 95，再低的电压就不稳定了。降电压后室温26度裸机烧机满载温度依然能到66度，基本也和HSW没什么区别。<br /><img src=\"http://bbs.pceva.com.cn/data/attachment/forum/201407/23/175034m9yfby97dh78lkxe.jpg\" style=\"max-width:500px;\" /><br /><br />关于Z97芯片组，目前我测下来的几张主板，芯片组本身并未带来任何性能和超频能力的提升，只是规格上有所增强，例如增加了M.2接口，以及部分主板拥有的SATA Express接口，也算是给大家在存储产品上提供了更多更快的选择，尤其是M.2接口，在缩小SSD体积的同时可以得到更快的传输速度，并且完美支持智能响应技术，做系统盘和缓存盘均可。<br /><br />当然了，今年Intel值得期待的东西并不是这个Haswell Refresh，接下来Devil’s Canyon和Haswell-E都会在今年发布，届时都会有好戏看，也希望Intel不要再让我们失望。另外，Z97芯片组的寿命会很长，别忘了明年中旬才发布的Broadwell还是用它呢！<br /><br />PCEVA综合评价：Core i7-4790，加量不加价，换汤不换药。<br /><br /></p>  【DSP开发】6678 Hyperlink接口 1453718524846 Text 1dad75de_9c1776e 【DSP开发】 <p>冯华亮/Brighton Feng---Communication Infrastructure<br /><br />摘要<br />HyperLink 为两个 KeyStone 架构&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;之间提供了一种高速，低延迟，引脚数量少的<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=%CD%A8%D0%C5%BD%D3%BF%DA\" >通信接口</a>。HyperLink 的用户手册已经详细的对其进行了描述。本文主要是为 HyperLink 的编程提供了一些额外的补充信息。<br /><br />同时本文还讨论了 HyperLink 的性能，提供了在各种操作条件下的性能测试数据。对影响HyperLink&nbsp;性能的一些参数进行了讨论。<br /><br />文章的最后附上对应本文的应用代码。<br /><br />1、HyperLink 介绍<br /><br />HyperLink 为两片&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;之间提供一种高速、低延迟，引脚数少的通信连接接口。<br /><br />HyperLink 的设计速度最高速率支持 12.5Gbps，目前在大部分的 KeyStone <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>s 上,&nbsp;由于受限于 SerDes 和板级布线，速度接近为 10Gbps 。HyperLink&nbsp;是 TI 专有的外设接口。相对于用于高速 Serdes 接口的传统的 8b10b 编码方式，HyperLink&nbsp;减少了编码冗余，编码方式等效于 8b9b。单片&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;为 HyperLink 提供 4 个 SerDes 通道，所以 10Gbps 的HyperLink&nbsp;理论吞吐率为 10*4*(8/9)= 35.5Gbps= 4.44GB/s.<br /><br />HyperLink 使用了 PCIE 类似的内存映射机制，但它为多核&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;提供了一些更灵活的特性。本文将会使用几个范例来详细解释这一点。<br /><br />本文还讨论了 HyperLink 的性能，提供了在各种操作条件下的性能测试数据。对影响HyperLink&nbsp;性能的一些因素进行了讨论。<br /><br />2、HyperLink 配置<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />本节提供了一些配置 HyperLink 模块的补充信息。<br /><br />2.1 Serdes 配置<br /><br />Serdes 必须配置成期望的链接速度。&nbsp;图 1 表示了输入参考时钟和输出时钟之间的关系。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020129285.jpg\" style=\"max-width:500px;\" /><br /><br />输入参考时钟建议限制在 156.25MHz ~312.5MHz&nbsp;范围内。Serdes PLL 的倍频系数必须合理配置生成的内部时钟（internal&nbsp; clock）&nbsp;限制在 1.5625GHz ~ 3.125GHz 范围内。<br /><br />最后的链接速度由内部时钟(internal clock)驱动，通过 link rate 配置来得到。<br /><br />2.2 HyperLink 存储映射配置<br /><br />HyperLink 的存储映射非常的灵活。 HyperLink 的用户手册对此作了详细的描述。本节将用两个例子来详细的解释它。图 2 是第一个例子。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020129192.jpg\" style=\"max-width:500px;\" /><br />图 2 &nbsp;通过 HyperLink 窗口&nbsp;映射到远端不同类型的存储空间<br /><br />在这个例子里面，&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 的存储空间映射到了&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 的存储空间窗口 0x40000000~0x50000000<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 可以访问&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 的所有内存空间，包括 LL2，SL2，DDR，就像访问自己的本地的存储空间一样。在&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 上，所有的 Master 都可以通过以 0x40000000 起始的 Outbound 窗口地址来访问&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 的存储空间，但是不同 master 事实上可能访问到&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 上不同的存储空间。原因是HyperLink&nbsp;发送侧传输数据时，会将 PrivID 一起传输。接受侧通过 PrivID 值，可以建立不同的地址映射表<br /><br />对&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 与&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 的内存映射关系总结在下表(表 1)。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020129817.jpg\" style=\"max-width:500px;\" /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020130951.jpg\" style=\"max-width:500px;\" /><br /><br />通过上表的配置，可知<br />&nbsp;&nbsp;&nbsp;&nbsp;当&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 的 core 0/1 访问 0x40800000，它事实上&nbsp;访问了&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 上的 LL2 地址空间。<br />当&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 的 core0 访问 0x4D000000，它事实上访问了&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 上 DDR 的地址空间 0x8C000000 <br />当&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 的 core1 访问 0x4D000000 ，它事实上访问了&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 上 DDR 的地址空间 0x8F000000 与本文档对应的范例工程将 HyperLink 配置成上述的内存映射关系。下面是关键部分的配置代码。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020130197.jpg\" style=\"max-width:500px;\" /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020130829.jpg\" style=\"max-width:500px;\" /><br /><br />对于一些简单的应用，可能只是想访问远程&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;的 DDR 空间,那么下面的例子用于这种情况。存储映射关系如下图所示。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020130913.jpg\" style=\"max-width:500px;\" /><br />图 3 &nbsp;通过 HyperLink 窗口只映射到远端的 DDR 空间<br /><br />这是最简单的例子,但是却可以访问远端&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;的大块存储空间。<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 上的每个 master(core 或者其他外设)&nbsp;都可以可以访问&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 上 256MB DDR 空间。下表描述了 core0 和 core1 的对 remote <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a> DDR 存储映射。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020130636.jpg\" style=\"max-width:500px;\" /><br /><br />3、HyperLink 性能考虑<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />本节将让设计者对 HyperLink 访问远程存储空间的性能评估有基本的认识。同时提供了在不同的操作条件下获得的性能测试数据。大部分测试是在最理想的测试条件进行，以评估可以获得的最大吞吐量。<br /><br />本文所描述的绝大部分性能数据是在 C6670EVM 上获得。C6670 EVM 上 DDR 配置成 64bit 位宽1333M， HyperLink 速率配置成 10Gbit。<br /><br />一些影响 HyperLink 访问性能的因素在本节中将会被讨论到。<br /><br />3.1 通过 HyperLink 实现存储拷贝的性能<br />下表（表 3）描述了使用 HyperLink 在 LL2 与远程大块线性存储空间进行数据传送测试获得的传输带宽。传输块的大小为 64KB。带宽的计算是通过计算传输总的字节数除以传输所用的时间获得。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020132207.jpg\" style=\"max-width:500px;\" /><br /><br />上述数据展示了 cache 能够极大的改善&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;内核通过 HyperLink 读取数据的性能。<br /><br />但是 L2 cache 却遏制了通过 HyperLink 写数据的性能，这是因为 L2 是 write-allocate cache。对于使能 L2cache 后的写操作，它总是会先从将要写入的存储区读取 128 字节的数据到 L2cache ，然后在 L2 cache 中修改数据，最后在 cache 冲突的时候回写回到原先的存储区，或者人为的回写回原存储区。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020133525.jpg\" style=\"max-width:500px;\" /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://www.eccn.com/uploads/article/201401/20140115020135851.jpg\" style=\"max-width:500px;\" /><br /><br />上述 EDMA 吞吐率数据是通过 TC0 (传输控制器 0)和 CC0(通道控制器 0)上测试得到，其他 TCs的数据会比 TC0 稍低。整个传输的瓶颈是在 HyperLink，不是在 EDMA 传输控制器上。<br /><br />上述测试结果表明通过 HyperLink 进行写操作的性能会比通过 HyperLink 进行读操作的性能要好。<br /><br />远程&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;存储空间类型不会对带宽造成明显的影响。访问远程&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;的 SL2 会比 LL2 快一些。<br /><br />目前，通过 HyperLink 来访问远程&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;存储空间（相对其他接口）是具有最高的带宽性能的，但是访问远程存储空间比访问本地存储空间还是要慢。下表对比了访问本地 LL2 和 DDR 与远程DDR&nbsp;的吞吐性能。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020137904.jpg\" style=\"max-width:500px;\" /><br /><br />大体来说，对本地存储空间的写入吞吐率是对远程空间进行写入操作的吞吐率的 3 倍。对远程空间的读性能会更差些。我们应该尽量避免远程读取数据。<br /><br />3.2 <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a> core 通过 HyperLink 进行远程访问的延迟<br /><br /><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;核通过 HyperLink 访问远程空间的性能高度依赖于 cache。当&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;内核通过 HyperLink 来访问远程存储空间的时候，一个 TR(传输请求)可能会被生成并传送给 XMC（这取决于数据是否可以进入 cache 和被预取）。TR&nbsp;将会是下面中的一种。<br /><br />一个单一的元素-&nbsp;如果存储空间不能被 cache 和预存取。<br /><br />一个 L1 cache line –&nbsp;如果存储空间可以进入 cache ，但是 L2 cache 没有被使能。<br />一个 L2 cache line -如果存储空间可以进入 cache，同时 L2 cache 被使能.&nbsp;<br />如果存储空间可以被预存取,&nbsp;预存取将会被使能为一个预存取的 buffer slot.<br /><br />如果 L1/L2cache 或者预存取命中， Hyperlink 端口不会有数据传输<br /><br />远程空间数据可以被本地 L1 cache/L2 cache 缓存，或者都没有被 cache。如果对应存储空间的MAR(Memory Attribute Register)&nbsp;寄存器上的 PC(Permit&nbsp; copy)位没有被置位，那么对应存储区的数据将不会进入 cache。<br /><br />如果 MAR 寄存器上 PC 位被置位，同时 L2 的 cache 空间是 0（L2 被全部配置成 SRAM），那么外部存储空间的数据可以进入 L1cache。<br /><br />如果 MAR 寄存器上 PC 位被置位，L2&nbsp;的 Cache 空间大于 0．那么外部存储空间的数据就可以进入 L1cache 和 L2cache。<br /><br />读取远程存储空间数据也可以使用 XMC 中的 prefetch buffer。该特性可以在 MAR 寄存器PFX(PreFetchable eXternally)被置位后使能。<br /><br />地址步进长度也会影响 Cache 和 Prefetch buffer 的使用效果。连续空间的访问可以最充分的利用cache&nbsp;和 prefetch buffer，从而达到更好的性能。<br /><br />以 64bytes 距离或者更大间隔进行步进访问将会导致每次 L1 cache 命中失败（miss），这是因为L1 cache line 的大小是 64byte。<br /><br />以 128bytes 距离或者更大间隔进行步进访问将会导致每次 L2 cache 命中失败（miss）。<br />如果 cache miss 发生，那么&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;核就会被 stall（等待数据）。Stall 的时间长度等于传输延迟、传输间隔，数据返回时间，cache&nbsp;请求延迟的总和。<br /><br />下面的章节描述&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;内核通过 HyperLink 访问存储区的延迟。测试伪代码如下列所示。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020138169.jpg\" style=\"max-width:500px;\" /><br /><br />下图（图 4）为 1GHz C6670EVM 上配置 DDR 64bit 1333M 测试获得的结果。通过 HyperLink 实现 512 次 LDDW(load double word)&nbsp;或者 STDW( store double word)操作的性能测试。图 4 绘制了各种测试条件下的性能&nbsp;。 LDB/STB 和 LDW/STW 和 LDDW/STDW 的指令周期数相同。虽然cache&nbsp;和 prefetch buffer 可以被独立配置，但是测试的时候使用的配置是：如果 cache 被使能，那么 prefetch 也被使能，如果 cache 没有被使能，那么 prefetch 也没有被使能。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/2014011502013873.jpg\" style=\"max-width:500px;\" /><br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020138875.jpg\" style=\"max-width:500px;\" /><br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020138190.jpg\" style=\"max-width:500px;\" /><br /><br />Non-cachable 写是 post 操作。所以它只会 stall <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a> core 很短的一段时间。<br /><br />但是 read 是 non-post 的，所以&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;内核会等待数据的到来，所以它会 stall <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;内核相对长一点时间。<br /><br />当 cache 被使能后，<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a> core 访问 remote 空间的吞吐性能高度依赖于 cache。<br /><br />地址的步进间隔也会影响到 cache 的使用。连续的地址访问可以充分的利用 cache。但是地址的步进间隔超过 case line 的大小（L1 case line =64Byte,L2 Case line =128Byte）将会导致每次cache&nbsp;都无法命中，从而制约了性能。所以，对连续地址空间的数据访问（像大块数据拷贝），cache&nbsp;需要被使能，在其他情况下 cache 应当不要使能。<br /><br />通过上面的图可以发现通过 HyperLink 访问 DDR，SL2，LL2 在性能上并没有明显的差异。所以，正常情况下，通过 HyperLink 来共享 DDR 是一个很好的选择，因为 DDR 容量大，而且成本低。<br /><br />3.3 HyperLink 传输使用 DMA 方式的开销（overhead）<br />初始延迟被定义为 EMDA 事件触发到真实数据之间的传输开始之间的延迟。因为初始延迟很难被测量。所以我们就测试传输的开销，它被定义为传输最小单元数据的延迟&nbsp;。延迟的大小取决于源和目标端的类型。下表描述了使用 EDMA 在 1GHz&nbsp; TCI6618EVM 不同端口间传输一个字（word）时，从 EDMA 触发(写 ESR)到 EDMA 传输结束(读 IPR=1)的平均指令数目。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020138907.jpg\" style=\"max-width:500px;\" /><br /><br />表 6 中，读 Hyperlink 的延迟是 853 个指令周期，&nbsp;写 Hyperlink 的延迟是 322 指令周期，因为写是 post 操作，而读是 non-post 操作。所以从 HyperLink 端口读取数据的延迟要高于写入数据到HyperLink。<br /><br />对于小批量数据传送，传输开销(overhead)是很大的顾虑，尤其是系统中队列 DMA 阻塞的时候。单一元素的传送性能较差，延迟会占用大部分时间。所以，对于小批量数据传送，必须对使用EMDA&nbsp;方式还是&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;核方式来访问数据进行权衡。使用内核来访问单个随机数据的延迟会比DMA 方式延迟小很多。本文 3.2 节已经做了详细的描述。<br /><br />3.4 HyperLink 中断延迟<br /><br />一个&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;可以通过 HyperLink 来触发另外一个&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;的中断。通过 HyperLink 传递中断的延迟通过下列的伪代码获得测量。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020138732.jpg\" style=\"max-width:500px;\" /><br /><br />测试是在 Loopback 模式下测试。<br /><br />1GHz C6670 的测试结果是&nbsp;大概 710 个&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a> core cycles。<br /><br />4、范例工程<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />本文的范例代码在 C6670EVM 上通过测试。EVM&nbsp;板子上有两个 C6670 <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>，他们通过HyperLink 互联。<br /><br />在这个例子中，<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 存储空间通过 HyperLink 被映射到了&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 上。<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 通过 HyperLink 窗口访问&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 的存储空间就像访问自己的本地空间一样。这个工程范例也支持 loopback 模式。在loopback&nbsp;模式下，<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0 事实上是通过自己的 HyperLink 窗口访问了自己的本地地址空间。<br /><br />本例也演示了通过 HyperLink 来实现中断传递。<br /><br />工程代码的目录结构如下图所示。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020138828.jpg\" style=\"max-width:500px;\" /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图&nbsp; 7 &nbsp;工程代码目录树<br /><br />该示例代码同样可以在其他 KeyStone <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a> EVM 板上运行。只是如果板子上只有一个&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;芯片，那么只能运行 loopback 模式。<br /><br />下表列出了 KeyStone 工程的关键代码列表。<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/2014011502013921.jpg\" style=\"max-width:500px;\" /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020139966.jpg\" style=\"max-width:500px;\" /><br /><br />运行这个范例工程的步骤：<br /><br />1.&nbsp;连通 CCS 与&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a> EVM.&nbsp;<br />2.&nbsp;下载代码到 core 0 of <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0.<br />3.&nbsp;下载代码到 core 0 of <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1.<br />4.&nbsp;先运行&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>1 ,&nbsp;然后运行&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0.&nbsp;(如果 EVM 上只有一个&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>,且运行在 loopback 模式下，那么直接下载到<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>0，再运行)<br />5.&nbsp;检测每个&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eccn.com/search/?q=DSP\" >DSP</a>&nbsp;的 stdout 窗口，验证测试结果。<br /><br />典型的输出信息如下:<br /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020139985.jpg\" style=\"max-width:500px;\" /><br /><img src=\"http://www.eccn.com/uploads/article/201401/20140115020139890.jpg\" style=\"max-width:500px;\" /><br /><br />用户可以在 HyperLink_Test.c 中的 HyperLink_config()函数中修改初始化值，然后重新编译来验证在不同配置下的 HyperLink 性能。<br /><br />这个例子是在 CCS5.1 下编译，使用 pdk_c6618_1_0_0_5。如果在你的电脑上进行重新编译新的配置，你可能需要修改 csl 包含路径。<br /><br />参考资料<br />1. KeyStone Architecture HyperLink User Guide (SPRUGW8)<br />2. TMS320C6670 datasheet (SPRS689)<br /></p>  【硬件开发】波特率与比特率的区别，Baud与bps 1453683743866 Text 1dad75de_9c0a53e 【硬件开发】 <p>在电子通信领域，波特率（Baud rate）即调制速率，指的是有效数据信号调制载波的速率，即单位时间内载波调制状态变化的次数。它是对符号传输速率的一种度量，1波特即指每秒传输1个符号，而通过不同的调制方式，可以在一个码元符号上负载多个bit位信息。&nbsp;单位“波特”本身就已经是代表每秒的调制数，以“波特每秒”（Baud per second）为单位是一种常见的错误。</p> <p>中文名波特率外文名Baud rate</p> <p>目录</p> <ol> <li><p>1&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/subview/543280/8239956.htm#1\" >定义</a></p></li> <li><p>2&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/subview/543280/8239956.htm#2\" >应用</a></p></li> <li><p>3&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/subview/543280/8239956.htm#3\" >波特率和比特率</a></p></li> </ol> 定义 <a target=\"_blank\" rel=\"nofollow\" >编辑</a> <p>波特是设备(如调整解调器)每秒钟发生信号变化的度量。它代表的是信号的变</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/pic/%E6%B3%A2%E7%89%B9/35033/0/d048addefbf9fa1accbf1a9a?fr=lemma&amp;ct=single\" ><img src=\"http://h.hiphotos.baidu.com/baike/s%3D220/sign=a1273b7a5343fbf2c12ca121807fca1e/fcfaaf51f3deb48feb2fbfacf01f3a292df57879.jpg\" style=\"max-width:500px;\" /></a>波特率</p>化，而不是传输数据的多少。它表示每秒钟内通信线路状态改变的次数。“波特”来源于法国人Baudot，他于1877年为法国 <a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/1473.htm\" >电报</a>系统开发了编码方案。如果数据不压缩，波特等于每秒钟传输的数据位数，如果数据进行了压缩。那么每秒钟传输的数据位数通常大于 <a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/1448057.htm\" >调制速率</a>，使得交换使用波特和比特/秒有时会产生错误。 应用 <a target=\"_blank\" rel=\"nofollow\" >编辑</a> <p>波特很少用于<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/1074.htm\" >调制解调器</a>速度，因为它与高速调制解调器上每秒钟传输的位数没有关系。如果调制解调器对每个信号变化传输一位，则它的速率(bit/s)和<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/119333.htm\" >波特率</a>将相同。然而，可以应用编码技术使1个波特&nbsp;(即信号变化)表示2个bit或更多bit。2bit/Baud被称为双位编码，3bit/Baud被称为三位编码。也就是说，一次电压（或电流波型）的变化可能包括了几位数据，因此我们不能把波特率和<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/56355.htm\" >比特率</a>给混起来了，前一个指的是电压的变化量，后一个指的是传输数据的多少。注意，波特一词常常与比特率混淆。</p> 波特率和比特率 <a target=\"_blank\" rel=\"nofollow\" >编辑</a> <p>码元：在数字通信中常常用时间间隔相同的符号来表示数字。这样的时间间隔内的信号称为码元，这个间隔称为码元长度</p> <p>波特率：是码元传输速率单位，他说明单位时间传输了多少个码元。</p> <p>比特率：是信息量传送速率单位，即每秒传输二进制代码位数。bit/s</p> <p>可能还不是很清楚，举例说明：</p> <p>如果在数字传输过程中，用0V表示数字0,5V表示数字1，那么每个码元有两种状态0和1.&nbsp;每个码元代表一个二进制数字。此时的每秒码元数和每秒二进制代码数是一样的，这叫两相调制，波特率等于比特率。</p> <p>如果在数字传输过程中，0V、2V、4V和6V分别表示00、01、10和11，那么每个码元有四种状态00、01、10和11.&nbsp;每个码元代表两个二进制数字。此时的每秒码元数是每秒二进制代码数是一半的，这叫四相调制，波特率等于比特率一半。</p> <p><br /></p>  【科普杂谈】盘点全球十大半导体IP供应商 1453649181718 Text 1dad75de_9bfea69 【科普杂谈】 <p>2013年全球<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/%E5%8D%8A%E5%AF%BC%E4%BD%93\" >半导体</a>IP市场规模达24.5亿美元，较上一年增长11.5%，其中<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/ARM\" >ARM</a>以43.2%的市占率遥遥领先，稳居龙头地位，Synopsys 与Imagination Technologies分别以13.9%与9%市占率占据二、三位。而Cadence由于在IP业务策略上改弦更张，并收购了Tensilica 与 Cosmic Circuits等公司，以163.7%的年增长率跃居排行榜第四位，表现十分抢眼。下面小编为大家一一介绍全球前十大<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/%E5%8D%8A%E5%AF%BC%E4%BD%93\" >半导体</a>IP供应商们。</p>本文引用地址： <a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/article/266414.htm\" >http://www.eepw.com.cn/article/266414.htm</a> <p>　　NO.10、Vivante Corporation(市占率1%)</p> <p>　　Vivante Corporation(图芯技术有限公司)是嵌入式图形处理器(<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/GPU\" >GPU</a>)设计领域中的技术先行者。公司总部位于加州森尼韦尔，为全球移动设备和家庭娱乐市场的尖端应用提供一套全面的图形处理器解决方案。种类繁多的2D和2D/3D图形处理器，能够提供高性能和低功耗消耗。</p> <p>　　同时，用最小的硅印模为业界标准应用程序接口(OpenGL; ES 2.0和OpenGL; ES 1.1OpenVG、DirectX 9)提供强大支持。图芯芯片技术，将桌面质量的图象和性能带入位于您卧室、汽车和手掌中的屏幕。Vivante的嵌入式解决方案是可升级的，建立在业界标准之上，且优化功耗、性能和大小，因此，可以有效的区别其他产品。</p> <p>　　NO.9、eMemory(市占率1.1%)</p> <p>　　eMemory(力旺电子)为全球最大的嵌入式非挥发性记忆体(eNVM)技术开发及矽智财供应厂商。力旺电子与全球主要的晶圆代工厂、整合元件制造商以及专业IC设计公司有紧密的合作关系，协助这些合作夥伴导入力旺电子独特开发之矽智财(IP)。</p> <p>　　NeoBit, NeoFuse, NeoMTP, NeoFlash 与NeoEE为力旺电子之五大核心技术，目前全球已有超过120亿个IC产品，嵌入使用力旺电子所提供的核心技术，应用领域涵括消费性电子产品、工业规格、以及车用电子之领域。</p> <p>　　NO.8、Rambus(市占率1.4%)</p> <p>　　Rambus创立于1990年3月，是一家专门从事高速芯片接口的发明及设计的技术授权公司。总部位于美国加州的洛斯拉图斯。</p> <p>　　1990年，Mike Farmwald和Mark Horowitz创立Rambus公司，并开始提出专利的申请，到1995年拥有SyncLink和RamLink等专利技术。1996年11月，在经过了几年的谈判之后，Intel同Rambus共同致力于Direct Rambus DRAM发展。威盛推出的Apollo Pro133一度取代Rambus DR DRAM，美光选择Apollo Pro133。</p> <p>　　Rambus大部份的收入是来自专利，Rambus经常处于诉讼状态。目前Rambus的产品有 RDRAM、XDR DRAM、XDR2 DRAM。</p> <p>　　NO.7、Sonic(市占率1.5%)</p> <p>　　Sonic是一家生产包括Roxio数字媒体播放器等产品在内的互联网视频技术公司。Sonic在2012年排名第九，2013年进步至第七名，其IP业务年营收成长了44.8%。</p> <p>　　NO.6、Ceva(市占率1.7%)</p> <p>　　CEVA公司是手机、便携设备和消费电子产品的的硅片知识产权(SIP)平台解决方案和数字信号处理器(DSP)内核授权厂商。CEVA的知识产权组合包括面向无线通信、多媒体、高清(HD)视频和音频、VoP、蓝牙、串行连接SCSI和SATA的广泛技术。</p> <p>　　NO.5、Silicon Image(市占率2.0%)</p> <p>　　Silicon Image(矽映电子科技)是一个上市的美国的大型<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/%E5%8D%8A%E5%AF%BC%E4%BD%93\" >半导体</a>设计公司。该公司有雇员约600人，总部设在加州桑尼维尔&nbsp;。</p> <p>　　该公司制造了各种常用的在现代计算机和消费电子装置中使用的集成电路，但是业务集中在存储，分配和介绍高清的消费类电子产品如：个人电脑和移动设备市场。&nbsp;该公司成立于1995年，是上市公司，&nbsp;在纳斯达克市场的标志是SIMG。</p> <p>　　NO.4、Cadence(市占率5.1%)</p> <p>　　铿腾电子科技有限公司或益华电脑科技股份有限公司(Cadence Design Systems, Inc)是一个专门从事电子设计自动化(EDA)的软件公司，由SDA Systems和ECAD两家公司于1988年兼并而成。是全球最大的电子设计技术(Electronic Design Technologies)、程序方案服务和设计服务供应商。其解决方案旨在提升和监控半导体、计算机系统、网络工程和电信设备、消费电子产品以及其它各类型电子产品的设计。产品涵盖了电子设计的整个流程，包括系统级设计，功能验证，IC综合及布局布线，模拟、混合信号及射频IC设计，全定制集成电路设计，IC物理验证，PCB设计和硬件仿真建模等。&nbsp;其总部位于美国加州圣何塞(San Jose)，在全球各地设有销售办事处、设计及研发中心。</p> <p>　　NO.3、 Imagination Technologies(市占率9%)</p> <p>　　Imagination Technologies公司现以硅智财(SIP)授权贩售及DAB收音机为主要业务，PowerVR为其主力销售的一项技术。英特尔及苹果公司分别持有Imagination Technologies 16.02%及9.5%股份。</p> <p>　　2012年11月5日宣布收购MIPS科技公司。</p> <p>　　NO.2、 Synopsys(市占率13.9%)</p> <p>　　Synopsys公司是全球最大的电子设计自动化(EDA)(ElectronicDesignAutomation)软件工具领导厂商，为全球电子市场提供技术先进的集成电路(IC)设计与验证平台，致力于复杂的芯片上系统(SoCs)的开发。同时，Synopsys公司还提供知识产权(IP)和设计服务。Synopsys公司总部设在美国加利福尼亚州MountainView，有超过60家分公司分布在北美、欧洲、日本与亚洲。在中国，Synopsys建立了上海、北京两个研发中心，整合了500多位研发人员。目前，Synopsys中国的研发人员与美国总部的研发人员一起，为全球的IC设计工程师协同开发新的设计工具，并不断为中国的IC设计业提供深入支持，这是Synopsys公司在美国以外最大的IC设计工具研发机构。</p> <p>　　NO.1、<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/ARM\" >ARM</a>(市占率43.2%)</p> <p>　　<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.eepw.com.cn/news/listbylabel/label/ARM\" >ARM</a>公司是一家知识产权(IP)供应商，它与一般的半导体公司最大的不同就是不制造芯片且不向终端用户出售芯片，而是通过转让设计方案，由合作伙伴生产出各具特色的芯片。ARM公司利用这种双赢的伙伴关系迅速成为了全球性RISC微处理器标准的缔造者。这种模式也给用户带来巨大的好处，因为用户只掌握一种ARM内核结构及其开发手段，就能够使用多家公司相同ARM内核的芯片。</p> <p>　　目前，总共有超过100家公司与ARM公司签订了技术使用许可协议，其中包括Intel、IBM、LG、NEC、SONY、NXP和NS这样的大公司。至于软件系统的合伙人，则包括Microsoft、升阳和MRI等一系列知名公司。</p> <p>　　ARM架构是ARM公司面向市场设计的第一款低成本RISC微处理器。它具有极高的性价比、代码密度，及时出色的实时中断响应和极低的功耗，并且占用硅片的面积极少，从而使它成为嵌入式系统的理想选择。其应用范围非常广泛，比如手机、PDA、MP3/MP4和种类繁多的便携式消费产品。2004年ARM公司的合作伙伴生产了12亿片ARM处理器。</p> <p>　　ARM公司是苹果、Acorn、VLSI、Technology等公司的合资企业。ARM将其技术授权给世界上许多著名的半导体、软件和OEM厂商，每个厂商得到的都是一套独一无二的ARM相关技术及服务。利用这种合伙关系，ARM很快成为许多全球性RISC标准的缔造者。目前，总共有30家半导体公司与ARM签订了硬件技术使用许可协议，其中包括Intel、IBM、LG半导体、NEC、SONY、飞利浦和国家半导体这样的大公司。至于软件系统的合伙人，则包括微软、SUN和MRI等一系列知名公司。1991 年ARM&nbsp;公司成立于英国剑桥，主要出售芯片设计技术的授权。目前，采用ARM技术知识产权( IP )核的微处理器，即我们通常所说的ARM&nbsp;微处理器，已遍及工业控制、消费类电子产品、通信系统、网络系统、无线系统等各类产品市场，基于ARM&nbsp;技术的微处理器应用约占据了32&nbsp;位RISC&nbsp;微处理器75&nbsp;%以上的市场份额，ARM&nbsp;技术正在逐步渗入到我们生活的各个方面。</p> <p><br /></p>  【编程开发】FPGA开发之IP核：软核、硬核以及固核概念 1453648849658 Text 1dad75de_9bfea60 【编程开发】 <p>IP（<a target=\"_blank\" rel=\"nofollow\" href=\"http://intel.dzsc.com/\" >Intel</a>ligent Property）核是具有知识产权核的<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.dzsc.com/product/searchfile/584.html\" >集成电路</a>芯核总称，是经过反复验证过的、具有特定功能的宏模块，与<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.dzsc.com/product/searchfile/6465.html\" >芯片</a>制造工艺无关，可以移植到不同的半导体工艺中。到了SOC阶段，IP核设计已成为<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.dzsc.com/a/ASIC.html\" >ASIC</a>电路设计公司和FPGA提供商的重要任务，也是其实力体现。对于FPGA开发软件，其提供的IP核越丰富，用户的设计就越方便，其市场占用率就越高。<br />　　IP（In<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.dzsc.com/product/searchfile/10366.html\" >te</a>llectual Property）就是常说的知识产权。美国Dataquest咨询公司将半导体产业的IP定义为用于ASIC、ASSP和PLD等当中，并且是预先设计好的电路模块。IP核模块有行为（Behavior）、结构（Structure）和物理（Physical）三级不同程度的设计，对应描述功能行为的不同分为三类，即软核（Soft IP Core）、完成结构描述的固核（Firm IP Core）和基于物理描述并经过工艺验证的硬核（Hard IP Core）。<br />　　从IP 核的提供方式上，通常将其分为软核、硬核和固核这3&nbsp;类。从完成IP&nbsp;核所花费的成本来讲，硬核代价最大；从使用灵活性来讲，软核的可复用使用性最高。<br />　　<strong>软核&nbsp;(Soft IP Core)<br /></strong>　　软核在&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://wiki.dzsc.com/info/2775.html\" >EDA</a>&nbsp;设计领域指的是综合之前的<a target=\"_blank\" rel=\"nofollow\" href=\"http://product.dzsc.com/product/searchfile/19403.html\" >寄存器</a>传输级&nbsp;(RTL)&nbsp;模型&nbsp;；具体在 FPGA 设计中指的是对电路的硬件语言描述，包括逻辑描述、网表和帮助文档等。软核只经过功能仿真，需要经过综合以及布局布线才能使用。其优点是灵活性高、可移植性强，允许用户自配置&nbsp;；缺点是对模块的预测性较低，在后续设计中存在发生错误的可能性，有一定的设计风险。软核是 IP 核应用最广泛的形式。<br />　　<strong>固核&nbsp;(Firm IP Core)<br /></strong>　　固核在 EDA 设计领域指的是带有平面规划信息的网表；具体在 FPGA 设计中可以看做带有布局规划的软核，通常以 RTL 代码和对应具体工艺网表的混合形式提供。将 RTL 描述结合具体标准单元库进行综合优化设计，形成门级网表，再通过布局布线工具即可使用。和软核相比，固核的设计灵活性稍差，但在可靠性上有较大提高。<br />　　<strong>硬核&nbsp;(Hard IP Core)<br /></strong>　　硬核在EDA设计领域指经过验证的设计版图&nbsp;；具体在 FPGA 设计中指布局和工艺固定、经过前端和后端验证的设计，设计人员不能对其修改。不能修改的原因有两个&nbsp;：首先是系统设计对各个模块的时序要求很严格，不允许打乱已有的物理版图&nbsp;；其次是保护知识产权的要求，不允许设计人员对其有任何改动。IP&nbsp;硬核的不许修改特点使其复用有一定的困难，因此只能用于某些特定应用，使用范围较窄。<br /></p>  【编程开发】超标量、超级流水线、超长指令字、向量机 1453648681976 Text 1dad75de_9bfea5c 【编程开发】 <p><strong>1、超标量（Super Scalar)<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;将一条指令分成若干个周期处理以达到多条指令重叠处理,从而提高cpu部件利用<br />率的技术叫做标量流水技术.<br />&nbsp;&nbsp;&nbsp;&nbsp;超级标量是指cpu内一般能有多条流水线,这些流水线能够并行处理.在单流水线结构<br />中,指令虽然能够重叠执行,但仍然是顺序的,每个周期只能发射(issue)或退休(retire)<br />一条指令.超级标量结构的cpu支持指令级并行,每个周期可以发射多条指令(2-4条居多).<br />这样,可以使得cpu的IPC(Instruction Per Clock)&nbsp;&gt; 1,&nbsp;从而提高cpu处理速度.<br />&nbsp;&nbsp;&nbsp;&nbsp;超级标量机能同时对若干条指令进行译码，将可以并行执行的指令送往不同的执行<br />部件,在程序运行期间，由硬件(通常是状态记录部件和调度部件)来完成指令调度.<br />&nbsp;&nbsp;&nbsp;&nbsp;超级标量机主要是借助硬件资源重复(例如有两套译码器和ALU等)来实现空间的并行<br />操作.<br />&nbsp;&nbsp;&nbsp;&nbsp;我们熟知的pentium系列(可能是p-II开始),还有SUN SPARC系列的较高级型号,以及<br />MIPS若干型号等都采用了超级标量技术.</p> <p><strong>2、超级流水线（Super Pipeline)<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;超级流水线又叫做深度流水线，它是提高cpu速度通常采取的一种技术。CPU处理指令<br />是通过Clock来驱动的，每个clock完成一级流水线操作。每个周期所做的操作越少，那么<br />需要的时间久越短，时间越短，频率就可以提得越高。所以超级流水线就是将cpu处理<br />指令是得操作进一步细分，增加流水线级数来提高频率。频率高了，当流水线开足马力<br />运行时平均每个周期完成一条指令（单发射情况下），这样cpu处理得速度久提高了。<br />当然，这是理想情况下，一般是流水线级数越多，重叠执行的执行就越多，那么发生<br />竞争冲突得可能性就越大，对流水线性能有一定影响。<br />&nbsp;&nbsp;&nbsp;&nbsp;现在很多cpu都是将超标量和超级流水线技术一起使用，例如pentium IV，流水线达<br />到20级，频率最快已经超过3GHZ.我们教科书上用于教学的经典MIPS只有5级流水。</p> <p><strong>3、超长指令字（VLIW：Very Long Instruction Word）<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;超常指令字是由美国Yale大学教授Fisher提出的。它有点类似于超级标量，是一条<br />指令来实现多个操作的并行执行，之所以放到一条指令是为了减少内存访问。通常<br />一条指令多达上百位，有若干操作数，每条指令可以做不同的几种运算。那些指令可以<br />并行执行是由编译器来选择的。通常VLIW机只有一个控制器，每个周期启动一条长指令，<br />长指令被分为几个字段，每个字段控制相应的部件。由于编译器需要考虑数据相关性，<br />避免冲突，并且尽可能利用并行，完成指令调度，所以硬件结构较简单。<br />&nbsp;&nbsp;&nbsp; VLIW机器较少，可能不太容易实现，我们平时很少接触VLIW机器（也许是我孤陋寡<br />闻），我知道业界比较有名的VLIW公司之一是Transmeta，在加州硅谷Santa Clara（呵呵<br />我心目中硅谷圣地之一，还有San Jose， Palo Alto，都是it英雄辈出的地方）。它做的<br />机器采用X86指令集，VLIW实现，具体资料可以去访问公司的网站。</p> <p><strong>4、向量机（Vector Machine）<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;我们平时接触的计算机都是标量机，向量机都是大型计算机，一般用于军事工业，气<br />象预报，以及其他大型科学计算领域，这也说明了向量机都很贵。国产的银河计算机就是<br />向量机。<br />&nbsp;&nbsp;&nbsp;&nbsp;普通的计算机所做的计算，例如加减乘除，只能对一组数据进行操作，<br />被称为标量运算。向量运算一般是若干同类型标量运算的循环。<br />向量运算通常是对多组数据成批进行同样运算，所得结果也是一组数据。<br />&nbsp;&nbsp;&nbsp;&nbsp;很多做科学计算的大（巨）型机都是向量机，例如国产银河。这个好像我们平时不太<br />接触的到。</p> <p><strong>5、SIMD技术<br /></strong>&nbsp;&nbsp;&nbsp;刚刚看到网上一段介绍SIMD的文字，贴在这里：<br />&nbsp;&nbsp;&nbsp;单指令多数据（Single Instruction Multiple Data）<br />&nbsp;&nbsp;&nbsp;简称SIMD。SIMD结构的CPU有多个执行部件，但都在同一个指令部件的控制下。<br />SIMD在性能上有什么优势呢？以加法指令为例，单指令单数据（SISD）的CPU对加法指令<br />译码后，执行部件先访问内存，取得第一个操作数；之后再一次访问内存，取得第二个操<br />作数；随后才能进行求和运算。<br />&nbsp;&nbsp;&nbsp;而在SIMD型CPU中，指令译码后几个执行部件同时访问内存，一次性获得所有操作数进<br />行运算。这个特点使得SIMD特别适合于多媒体应用等数据密集型运算。AMD公司的3D NOW！<br />技术其实质就是SIMD，这使K6－2处理器在音频解码、视频回放、3D游戏等应用中显示出优<br />异性能。</p> <p><br /></p>  【编程开发】关于并行的小结 1453648605841 Text 1dad75de_9bfea5a 【编程开发】 <p>这里只想稍微提一下自己的理解：</p> <p>1.&nbsp;通常针对处理器所提出的线程，指的是处理器级别的线程，或者说是指令级别的并行度，或者说是操作系统所识别出的单个CPU对应的逻辑处理器的个数。而不是操作系统级别的线程，并不是指的在程序开发中所采用的多线程应用程序。</p> <p>2.&nbsp;操作系统级别的多线程，指的就是一个进程中细分出来的线程，通过下面的一个关于在windows下的可以开的最多线程数就可以理解针对处理器所说的线程与针对处理器所说的线程的区别了。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cnblogs.com/lancidie/archive/2011/12/15/2289337.html\" >WINDOWS操作系统中可以允许最大的线程数</a></p> <p>默认情况下，一个线程的栈要预留1M的内存空间&nbsp;<br />而一个进程中可用的内存空间只有2G，所以理论上一个进程中最多可以开2048个线程&nbsp;<br />但是内存当然不可能完全拿来作线程的栈，所以实际数目要比这个值要小。&nbsp;<br />你也可以通过连接时修改默认栈大小，将其改的比较小，这样就可以多开一些线程。&nbsp;<br />如将默认栈的大小改成512K，这样理论上最多就可以开4096个线程。&nbsp;<br /><br />即使物理内存再大，一个进程中可以起的线程总要受到2GB这个内存空间的限制。&nbsp;<br />比方说你的机器装了64GB物理内存，但每个进程的内存空间还是4GB，其中用户态可用的还是2GB。&nbsp;<br /><br /><br />如果是同一台机器内的话，能起多少线程也是受内存限制的。每个线程对象都要站用非页面内存，而非页面内存也是有限的，当非页面内存被耗尽时，也就无法创建线程了。&nbsp;<br /><br />如果物理内存非常大，同一台机器内可以跑的线程数目的限制值会越来越大。&nbsp;&nbsp;</p> <p>在Windows下写个程序，一个进程Fork出2000个左右线程就会异常退出了，为什么？</p> <p>这个问题的产生是因为windows32位系统，一个进程所能使用的最大虚拟内存为2G，而一个线程的默认线程栈StackSize为1024K（1M），这样当线程数量逼近2000时，2000*1024K=2G(大约），内存资源就相当于耗尽。</p> <p>&nbsp;</p> <p><strong>MSDN原文：</strong></p> <p>“The number of threads a process can create is limited by the available virtual memory. By default, every thread has one megabyte of stack space. Therefore, you can create at most 2,028 threads.&nbsp;<span style=\"text-decoration:underline;\" >If you reduce the default stack size, you can create more threads.</span>However, your application will have better performance if you create one thread per processor and build queues of requests for which the application maintains the context information. A thread would process all requests in a queue before processing requests in the next queue.”</p> <p>&nbsp;</p> <p><strong>如何突破2000个限制？</strong></p> <p>可以通过修改CreateThread参数来缩小线程栈StackSize，例如</p> <p>#define&nbsp;&nbsp; MAX_THREADS &nbsp; 50000DWORD &nbsp; WINAPI &nbsp; ThreadProc(&nbsp;&nbsp; LPVOID &nbsp; lpParam &nbsp;&nbsp;){while(1){Sleep(100000);}return&nbsp;&nbsp; 0;}int&nbsp;&nbsp; main()&nbsp;&nbsp;&nbsp;{DWORD &nbsp; dwThreadId[MAX_THREADS];HANDLE &nbsp; hThread[MAX_THREADS];for(int&nbsp;&nbsp; i &nbsp;&nbsp;=&nbsp;&nbsp; 0;&nbsp;&nbsp; i &nbsp;&nbsp;&lt;&nbsp;&nbsp; MAX_THREADS;&nbsp;&nbsp;&nbsp;++i){hThread[i]&nbsp;&nbsp;= CreateThread(0,&nbsp; 64, ThreadProc, 0, STACK_SIZE_PARAM_IS_A_RESERVATION,&nbsp;&nbsp;&nbsp;&amp;dwThreadId[i]);if(0 &nbsp;&nbsp;==&nbsp;&nbsp; hThread[i]){DWORD &nbsp; e &nbsp;&nbsp;=&nbsp;&nbsp; GetLastError();printf(&quot;%d\\r\\n&quot;,e);break;}}ThreadProc(0);}</p> <p>&nbsp;</p> <p><strong>服务器端程序设计</strong></p> <p>如果你的服务器端程序设计成：来一个client连接请求则创建一个线程，那么就会存在2000个限制（在硬件内存和CPU个数一定的情况下）。建议如下：</p> <p>The &quot;one thread per client&quot; model is well-known not to scale beyond a dozen clients or so. If you're going to be handling more than that many clients simultaneously, you should move to a model where instead of dedicating a thread to a client, you instead allocate an object.&nbsp;(Someday I'll muse on the duality between threads and objects.) Windows provides I/O completion ports and a <strong>thread pool</strong> to help you convert from a thread-based model to a work-item-based model.</p> <a target=\"_blank\" rel=\"nofollow\" >1. Serve many clients with each thread, and use nonblocking I/O and <strong>level-triggered</strong>readiness notification</a> <a target=\"_blank\" rel=\"nofollow\" >2. Serve many clients with each thread, and use nonblocking I/O and readiness<strong>change</strong> notification</a> <a target=\"_blank\" rel=\"nofollow\" >3. Serve many clients with each server thread, and use asynchronous I/O</a> <p><a target=\"_blank\" rel=\"nofollow\" ><br /></a></p> <p><br /></p> <p><br /></p> <p><br /></p>  【编程开发】一分钟看懂CPU多发射超标量/多线程/多核之概念和区别 1453647641910 Text 1dad75de_9bfea34 【编程开发】 <p>处理器性能提高之公开秘笈：超标量、多线程、多核。</p> <p>用于说明的生活模型：高速公路及收费站。</p> <p>&nbsp;</p> <p>简单CPU的原型：单车道马路&nbsp;+&nbsp;单收费闸口，车辆只能一辆辆排队通过，并行度为1。</p> <p>&nbsp;</p> <p>为了提高通行能力同时积极创收，相关部门运用世界顶尖CPU设计理念，对高速公路系统进行了如下拓宽改造：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=6f5257650101816k&amp;url=http://s3.sinaimg.cn/orignal/6f525765gcbbf56e570a2\" ><img src=\"http://s3.sinaimg.cn/middle/6f525765gcbbf56e570a2&amp;690\" style=\"max-width:500px;\" /></a><br />&nbsp;</p> <p>（1）&nbsp;&nbsp;增加车道（图示为3条车道）；</p> <p>（2）&nbsp;&nbsp;增加收费通道（图示为2个通道）；</p> <p>（3）&nbsp;&nbsp;每个收费通道放置多个收费员（图示每条通道有a和b两个收费窗口）。</p> <p>&nbsp;</p> <p>其中（1）+（3）组合手段就是所谓的超标量结构，该图示为双发射超标量。超标量指有多个车道，双发射是指有a和b两位收费员可以同时发卡，把两辆车送到不同车道上去。</p> <p>&nbsp;</p> <p>手段（2）就是多线程的模型了，原有车道不变、只增加收费通道，这样多个车流来的时候可以同时发卡放行。</p> <p>&nbsp;</p> <p>从这个比喻来看多线程显然是个非常直观和有用的办法，但为什么在CPU世界中似乎有点模糊难懂的感觉呢？那是因为CPU的指令流喜欢一个挨一个、一列纵队龟速前进，这样的话单通道多收费员还起点作用、多通道就形同虚设了。收费员1.a和1.b会累死，而2.a和2.b则能够睡觉。因此把车流进行整队就很重要——这就是并行编程，即要设法把一列纵队排列成多列纵队。</p> <p>&nbsp;</p> <p>至于多核的概念，那就简单粗暴很多了，直接在这条马路边上进行征地拆迁、新修一条一模一样的高速公路便是，牛吧。现在大家手机里面的多核，就是并排几条“单收费通道+多车道”的马路，车流稀少、路况不错，不过相关部门表示因为道路利用率底下、经济效益欠佳、回收投资压力巨大。</p> <p>&nbsp;</p> <p>无论多核还是多线程，都有一个同样的问题需要解决，就是要把车流整成多列纵队，这样多条马路和多个收费通道的并行度才能发挥作用。</p> <p><br /></p>  【编程开发】流水线、超流水、超标量发射 1453647189464 Text 1dad75de_9bfea2a 【编程开发】 <p><strong>流水线</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;流水线技术是一种将每条指令分解为多步，并让各步操作重叠，从而实现几条指令并行处理的技术。程序中的指令仍是一条条顺序执行，但可以预先取若干条指令，并在当前指令尚未执行完时，提前启动后续指令的另一些操作步骤。这样显然可加速一段程序的运行过程。&nbsp;<br />市场上推出的各种不同的1 6位/ 3 2位微处理器基本上都采用了流水线技术。如8 0 4 8 6和P e n t i u m均使用了6步流水线结构，流水线的6步为：&nbsp;<br />( 1 )&nbsp;取指令。C P U从高速缓存或内存中取一条指令。&nbsp;<br />( 2 )&nbsp;指令译码。分析指令性质。&nbsp;<br />( 3 )&nbsp;地址生成。很多指令要访问存储器中的操作数，操作数的地址也许在指令字中，也许要经过某些运算得到。&nbsp;<br />( 4 )&nbsp;取操作数。当指令需要操作数时，就需再访问存储器，对操作数寻址并读出。&nbsp;<br />( 5 )&nbsp;执行指令。由A L U执行指令规定的操作。&nbsp;<br />( 6 )&nbsp;存储或&quot;写回&quot;结果。最后运算结果存放至某一内存单元或写回累加器A。&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在理想情况下，每步需要一个时钟周期。当流水线完全装满时，每个时钟周期平均有一条指令从流水线上执行完毕，输出结果，就像轿车从组装线上开出来一样。P e n t i u m、Pentium Pro和Pentium II处理器的超标量设计更是分别结合了两条和三条独立的指令流水线，每条流水线平均在一个时钟周期内执行一条指令，所以它们平均一个时钟周期分别可执行2条和3条指令。&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;流水线技术是通过增加计算机硬件来实现的。例如要能预取指令，就需要增加取指令的硬件电路，并把取来的指令存放到指令队列缓存器中，使M P U能同时进行取指令和分析、执行指令的操作。因此，在1 6位/3 2位微处理器中一般含有两个算术逻辑单元A L U，一个主A L U用于执行指令，另一个A L U专用于地址生成，这样才可使地址计算与其它操作重叠进行。</p> <p>&nbsp;</p> <p><strong>超流水线</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;超级流水线以增加流水线级数的方法来缩短机器周期，相同的时间内超级流水线执行了更多的机器指令。采用简单指令以加快执行速度是所有流水线的共同特点，但超级流水线配置了多个功能部件和指令译码电路，采用多条流水线并行处理，还有多个寄存器端口和总线，可以同时执行多个操作，因此比普通流水线执行的更快，在一个机器周期内可以流出多条指令。</p> <p>&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般而言，CPU执行一条指令需要经过以下阶段：取指-&gt;译码-&gt;地址生成-&gt;取操作数-&gt;执行-&gt;写回，每个阶段都要消耗一个时钟周期，同时每个阶段的计算结果在周期结束以前都要发送到阶段之间的锁存器上，以供下一个阶段使用。所以，每个时钟周期所消耗的时间就是由以上几个阶段中的耗时最长的那个决定的。假设耗时最长的阶段耗时为s秒，那么时钟频率就只能设计到1/s赫兹（这里不考虑阶段间信号传递的时间和锁存器的反应时间）。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，要提高时钟频率，一种可能的方法就是减小每个阶段的时间消耗。其中一种最简单的办法，就是将每个阶段再进行细分成更小的步骤，同样是细分后的每个阶&nbsp;段，单个阶段的运算量小了，单位耗时s也就减少，这样实际上就是提高了时钟频率。这种将标准流水线细分的技术，就是超级流水线技术。当然，流水线和超级流&nbsp;水线之间并没有很明显的区别。这样的技术，虽然提高了CPU的主频，但是也带来了很大的副作用：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，细分后的每一个阶段都要在其后使用锁存器锁存，因此将一个阶段细分为N的子阶段并不能让单位时间减少到s/N,&nbsp;而是s/N + d,&nbsp;其中d为锁存器的反应时间。这实际上就是增加了多余的时间消耗。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，随着流水线级数的加深，一旦分支预测出现错误，会导致CPU中大量的指令作废，这样的消耗是十分巨大的。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上原因，也就是什么Pentium IV具有31级的流水线，指令的执行效率却赶不上只有14级流水线的Pentium M</p> <p>&nbsp;</p> <p><strong>超标量</strong><strong><br /></strong>　　超标量（superscalar）是指在CPU中有一条以上的流水线，并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术。&nbsp;其实质是以空间换取时间。而超流水线是通过细化流水、提高主频，使得在一个机器周期内完成一个甚至多个操作，其实质是以时间换取空间。</p> <p><br /></p>  【编程开发】SMT Simultaneous Multithreading 同时多线程 1453646698380 Text 1dad75de_9bfea16 【编程开发】 <p>多线程技术获得大众广泛关注源于Intel。在其新一代基于奔腾４的Xeon处理器中，Intel使用了Hyperthreading技术，而这一技术的核心就是同时多线程。几乎与此同时，IBM也宣布，将于2004年推出其下一代具备“同时多线程”能力的64位处理器——Power 5。其实，高性能处理器的先锋Alpha早就决定在Alpha 21464（EV8）中采用“同时多线程”结构了。要不是由于某些非技术的原因，在今年年底我们就能看到这款64位同时多线程处理器了。</p> <p>众多主流处理器厂商将其新一代高端产品的结构定为“同时多线程”（SMT——Simultaneous Multithreading），绝非偶然。当许多人还在讨论“EPIC”是否真的比“RISC”或“CISC”更好的时候，我们不妨从更深的层次上，了解这种前途光明的处理器结构。因为，许多人认为同时多线程处理器时代已经离我们不远了。</p> <p>别让发射槽闲着</p> <p>超标量技术和多线程技术的结合，产生了SMT，从而让处理器资源得到充分利用，也让处理器性能得到提高。<img src=\"http://www2.ccw.com.cn/02/0236/b/pic/b18_1t1.jpg\" style=\"max-width:500px;\" /></p> <p>在过去的20多年中，为了提高性能，处理器结构不断发生变化。最简单的标量处理器在一个时钟周期内最多发射一条指令，而指令间又存在着某种相关性。这些相关性表现在三个方面：一是由于使用同一功能部件造成的结构相关;二是访问同一寄存器或同一存储器单元而产生的逻辑相关;三是由于转移指令所造成的控制相关。指令的相关性导致在一些时钟周期内，无法发射指令（如图1（a））。因此，这种结构的IPC（instruction per cycle）实际上小于1。</p> <p>为了提高IPC，产生了多发射技术，其中最常用的就是“超标量”。这类处理器每个时钟周期可以给不同的功能部件发射多条指令。为了减少指令间的相关性对性能产生的不良影响，在超标量处理器中，采用了乱序执行、寄存器重命名和分支预测技术。但仍然无法完全消除相关，造成在一个时钟周期内可能没有足够的可发射指令来填满所有的发射槽，有的时钟周期内甚至可能出现没有指令可以发射的情况（如图1（b）），空闲的发射槽将被白白浪费。在多处理机系统中，远程访问延迟所造成的性能损失就更大了。因此一个4发射的处理器的IPC一般只略大于2，而且如不采用其他技术，对于一个m发射的超标量处理器来说，当m &gt; 4时，随着m的增加，IPC的增幅将迅速降低。为此，必须通过其他方式来提高处理器的性能。</p> <p>多线程处理器便是一个很好的尝试。多线程处理器对线程的调度与传统意义上由操作系统负责的线程调度是有区别的。它完全由处理器硬件负责线程间的切换。由于采用了大量的硬件支持，线程的切换甚至可以在一个时钟周期内完成。在一个细粒度多线程处理器中，每个时钟周期都从一个不同的线程中选择指令，并发射到相应的功能部件中。由于不同线程的指令间不存在相关性，因此可以保证每个时钟周期都有指令可以发射。即使某条指令有很长的访存延迟，多个线程的切换运行也可以有效地隐藏延迟。但是，在采用多线程技术的超标量处理器中，同一时钟周期内执行的还是同一线程的指令，仍然存在相关性，因此仍然有一些发射槽被浪费（如图1（c））。那么还有没有更好的处理器结构呢？当然有！那就是同时多线程。</p> <p>同时多线程技术是超标量技术与多线程技术的完美结合。它允许指令发射部件每一时钟周期都可以从多个线程中选择多条不相关的指令，发射到相应的功能部件中去执行。同时多线程处理器完全有能力每个时钟周期都填满所有的发射槽，而不产生任何浪费（如图1（d））。由此可以看出，多线程处理器在性能方面的优势是不言而喻的。</p> <p>减少相关性就是提高性能</p> <p>SMT无疑是处理器结构方面一次不小的突破。在其他处理器结构中，许多想尽办法也无法解决的难题，在同时多线程结构中却很容易解决。这一技术的优势就体现在它具备解决影响处理器性能的诸多难题的能力，如减少相关性。</p> <p>(1)&nbsp;减少结构相关对性能的影响</p> <p>当某条指令由于使用的功能部件被前面的指令所占用而无法执行时，这两条指令就发生了功能部件冲突，我们称这样的指令之间存在结构相关性。超标量处理器中使用了计分板(scoreboard)或Tomasulo机制来支持指令的乱序执行。其原理是:当某条指令由于功能部件冲突而无法执行时，其后继的无结构相关的指令可以先被执行。</p> <p>同时多线程处理器不但支持乱序执行，而且其采用的同时从多个不同线程中选择指令的方式，还大大减少了指令间出现功能部件冲突的概率，也就进一步减少了结构相关产生的危害。</p> <p>(2)&nbsp;减少逻辑相关对性能的影响</p> <p>为了消除寄存器的“读后写”和“写后写”相关，也就是所谓的“伪相关”，超标量处理器的寄存器文件中物理寄存器数目都大于程序员所能看到的逻辑寄存器数，并采取了相应的“寄存器重命名”策略。但对于“写后读”相关，也就是所谓的“真相关”，超标量处理器却无法解决。</p> <p>在同时多线程处理器中，为了在线程切换过程中快速保存和恢复现场，每个线程都配备了独立的寄存器文件，只要选择不同线程的指令就不存在寄存器的“写后读”相关。当再次调度到同一线程时，即使下一条指令与前面的指令存在“写后读”相关，前面的指令也已经执行完毕，相关性危害也就不存在了。同时，对于每个线程，同样采用寄存器重命名技术来消除伪相关。因此，同时多线程处理器有能力消除各种由于寄存器相关而产生的危害。</p> <p>对于访问同一存储器单元的指令，传统的方式是通过编译器优化，将前一条指令的前驱指令或后一条指令的后继指令插入到这两条指令中间，拉大这两条指令的间距，以期减少此类相关引起的危害。但编译器找不到合适的插入指令的情况并不少见。而同时多线程处理器可以通过切换线程的方式，近一步增大这类指令的间隔，减少访存地址相关的危害。</p> <p>(3)&nbsp;减少控制相关对性能的影响</p> <p>当执行到转移指令时，只有等到它执行完毕才能准确得知后继指令的地址。如果不采取措施，在等待转移指令执行结果的这段时间里，后继指令将无法执行，造成指令流水线的闲置。在超标量处理器中通常采用转移预测技术，预测可能的转移方向，并按照这一方向继续执行。当转移地址确定后，如果与预测方向相同，则确认推测执行的结果;如果与预测方向不同，则在转移指令之后被发射的所有指令将作废，并从正确的转移地址处开始执行。因此，转移预测的正确率就显得非常重要了。现在的转移预测技术的正确率可以达到85%～95%，对于特定作业甚至可以高达99%以上。但随着处理器一个时钟周期内发射指令条数和指令流水线级数的增加，处理器中处于in-flighting状态的指令数目也迅速增加。一旦预测失败，作废的指令条数也就增加了。</p> <p>同时多线程技术的出现，为减少预测失败提供了一条新的途径。它将分支的两个转移方向映射到不同的线程中，同时执行，等转移地址确定后，从两个线程中选取正确的一个继续执行，错误的线程将被中止。虽然废止错误的线程会损失一些效率，但由于存在多个同时运行的线程，因此不会出现所有in-flighting指令都被作废的情况。虽然单独使用这一技术来处理转移指令，效率并不高，但是将这一方法与传统的转移预测技术相结合，则会进一步减少控制相关所产生的危害。</p> <p>（4）隐藏远程访问和同步等待延迟</p> <p>在大规模并行计算机系统，特别是拥有数千个处理器节点的DSP系统（分布共享处理器系统）中，处理器访问远程存储空间的延迟可以高达200多个时钟周期。同样在如此大的系统中，多个节点间的同步等待延迟也不容忽视。传统处理器通过忙等待（busy waiting），或一个耗时很长的操作系统级线程切换来处理此类情况，随着高性能计算对系统效率要求的不断提高，这样的处理方式已经不能满足要求了。<img src=\"http://www2.ccw.com.cn/02/0236/b/pic/b18_1t2.jpg\" style=\"max-width:500px;\" /></p> <p>操作系统级线程切换所消耗的时间开销可能比访存延迟造成的损失还要大。而同时多线程处理器中由硬件支持的快速线程切换机制，几乎可以做到“零时间开销”。因此，同时多线程处理器可以通过线程切换，在一个任务进行远程访问和同步等待过程中，运行其他任务的线程，将延迟有效地隐藏起来。</p> <p>SMT有两种实现方式</p> <p>SMT的两种实现方式各有千秋，同时不同的企业对此也会给出不同的方案。在这个显山露水的领域，竞争正在如火如荼地进行。</p> <p>同时多线程处理器的实现方式主要有两种:一是在超标量处理器的基础上，对同时多线程的取指令、现场保留、指令退出（retire）提供相应的硬件支持。而不同线程仍然共享其他的处理器资源，如取指缓冲、不同寄存器组中用做重命名寄存器的物理寄存器、指令窗口和reorder缓冲。硬件设计人员可以将主要精力集中在构建一个快速的单线程超标量处理器上，然后在此基础上增加多线程处理能力。这一方式的好处在于附加硬件少，开发周期短。</p> <p>二是每条线程都有各自独立的指令窗口、译码部件、寄存器文件和退出部件。发射部件可以同时发射不同指令窗口中的指令到各个功能部件。这一结构形式更多地改变了超标量处理机的结构。但这样很自然地分离了指令窗口，并简化了流水线的发射和退出段。</p> <p>以Alpha 21464的实现方式为例，介绍同时多线程处理器的实现方式。</p> <p>Alpha 21464处理器是Compaq公司的下一代处理器产品，但由于Intel收购了Alpha开发小组，使得这一项目被迫取消。我们之所以在此仍然要介绍这一处理器，一方面是从21064开始，Alpha在高性能处理器领域始终处于领先位置，21464中许多技术仍旧是值得研究和借鉴的；另一方面，虽然我们不知道Intel是否会将21464的技术直接应用于其下一代处理器，但或多或少会受其影响。</p> <p>Alpha 21464采用8发射动态调度超标量流水线，可处理4个同时线程。它采用了类似于上文中提到的第一种同时多线程的实现方式。所有线程共享物理寄存器、指令队列、分支预测器、指令执行单元和一、二级Cache。只有程序计数器（PC）、寄存器映射机构和返回栈预测器等部分是每个线程一份的，如图２所示。</p> <p>Alpha在超标量流水线设计方面已经炉火纯青了，因此它的同时多线程实现方法只是在其高效率的8发射动态调度超标量流水线中，对取指令、物理寄存器尺寸、数据Cache存储器接口和指令退出这四个部分做了修改。</p> <p>SMT与CMP对阵，SMT胜出</p> <p>在上个世纪末，讨论未来处理器结构时，有两个主要的选择——同时多线程处理器和单芯片多处理器（CMP——Chip Mulitprocessor）。SMT在与CMP对阵中胜出。</p> <p>随着大规模集成电路技术的发展，在芯片容量足够大时，就可以将大规模并行处理器中的SMP（对称多处理机）或DSP（分布共享处理机）节点集成到同一芯片内，各个处理器并行执行不同的进程，这就是CMP。在SMP单芯片多处理机中，处理器之间通过片内的１级或２级缓存，或者片外的３级缓存，或者片外的共享存储器来进行通信。而在DSP单芯片多处理机中，处理器间通过连接分布式存储器的片内高速交叉开关网络进行通信。SMP和DSP已经是非常成熟的技术了，而CMP结构虽然设计比较容易，但是其后端设计和芯片制造工艺的要求较高。</p> <p>而同时多线程处理器的设计难度相对就要大得多。但由于CMP中各处理器仍然是超标量流水线结构，因此IPC和处理器硬件的利用率比不上同时多线程处理器。在可比情况下，一个８发射的同时多线程处理器的性能要高于由４个双发射的超标量处理器组成的CMP。</p> <p>Alpha在其第四代处理器21364中使用了CMP技术，而第五代处理器21464中使用了同时多线程技术。无独有偶，IBM在Power 4中使用的是CMP，而在Power 5中将使用同时多线程。这从一个侧面也说明，同时多线程相对于CMP有不小的优势。</p> <p>如果说几年前，同时多线程处理器还只是各个大学的研究课题，或者只是一个由软件模拟的处理器结构，那么一两年后，我们将能看到采用这一技术的实实在在的高性能处理器了。不难预测，它将使高性能计算向前迈进一大步。不信，我们骑驴看唱本走着瞧!</p> <p><br /></p> <p><br /></p> <p>多线程的概念:</p> <p>　　传统的CPU 在某一时间只能处理一个指令序列，通常我们把它称为一个线程。在线程处理的过程中CPU&nbsp;的处理单元需要不断调入指令与数据进行处理。随着CPU&nbsp;技术的发展，CPU&nbsp;的主频与性能不断提高，从而要求调入指令和数据的速度也不断提高。但是内存技术的发展并没有跟上CPU&nbsp;发展的速度，内存通常无法提供足够的指令和数据给CPU&nbsp;进行处理。为了解决这个问题，业界通常采用多级缓存的方式：CPU&nbsp;处理单元中的寄存器是最快的，通常一个CPU&nbsp;中有一、二百个寄存器，它可以在一个时钟周期内提供指令和数据；其次是一级缓存，它的大小通常为几十KB，它需要几个时钟周期的访问时间；再其次是二级缓存，它的大小通常为几MB，它需要十几个时钟周期的访问时间；然后是内存，从内存中取得数据需要几十个时钟周期的访问时间；而最慢的是硬盘，通常需要几千甚至几万个时钟周期的访问时间。当CPU&nbsp;需要处理下一条指令时，它通常按照寄存器、一级缓存、二级缓存、内存、硬盘这一顺序去查找。如果在内存中仍然找不到需要的指令或数据时，系统会进行Context Switch，终止此线程在CPU 上的运行，使其处于等待状态，而让其它的线程运行。当此线程需要的数据被调入内存后，此线程处于就绪状态，可以被调度到CPU&nbsp;上运行。线程间的Context Switch 需要几十个时钟周期。</p> <p>　　由此可见当CPU&nbsp;需要从内存中取数据时，处理单元需要空转几十个时钟周期，有关统计显示当前CPU&nbsp;处理单元的平均利用率不足25%。为了提高CPU&nbsp;处理单元的利用率，设计者采用了线程级的并行技术，即在CPU&nbsp;的核心中执行一个以上的指令序列。对于操作系统来说，一个物理的处理器相当于两个逻辑的处理器。一般来说，多线程的演变可以大致划分为以下四种模式：</p> <p>　　单线程</p> <p>　　粗粒度多线程</p> <p>　　细粒度多线程</p> <p>　　同步多线程</p> <p>&nbsp;</p> <p><br />　　下图展示了这四种模式的多线程.&nbsp;图表中的每一个方框代表了各指令管道的一个执行阶段.&nbsp;每个图块左边的字母缩写分别是定点执行&nbsp;(FX)&nbsp;单元,&nbsp;装入存储&nbsp;(LS)&nbsp;单元,&nbsp;浮点&nbsp;(FP)&nbsp;单元,&nbsp;分支执行(BRX)&nbsp;单元,&nbsp;和条件寄存器逻辑执行单元&nbsp;(CRL):</p> <p>&nbsp;</p> <p>　　单线程模式，在此模式下，每周期一个线程执行两条指令。注意，在单线程模式中，第一周期只用到两个执行单元（FX0 和 LS0）。在此模式下，如何利用执行单元依赖于指令级的并行算法，该算法是由编译器或汇编语言程序员利用超大处理器中的八个指令管道（FX0 - CRL）产生的。</p> <p>　　粗粒度多线程，在任一时刻只有一个线程执行，当线程遇到一个长延迟事件时，如二级缓存不命中，则系统调度另一个线程执行，而不是让系统资源空转等待此线程。这一机制可以提高整个系统的利用率。这两个线程共享许多系统资源，如CPU 的寄存器和缓存等，因此这两个线程的切换比Context Switch 要快得多，只需要几个时钟周期。IBM&nbsp;在使用PowerPC RS64 IV 处理器的pSeries 680 和pSeries 660-6M1 上使用过这种粗粒度的多线程技术。</p> <p>　　细粒度多线程，采用这种多线程的系统循环的执行两个线程的指令，这就需要在处理器的设计上增加许多冗余的部件。如果一个线程遇到长延迟事件时，对应这一线程执行的时钟周期仍然没有被利用。</p> <p>　　同步多线程（SMT），与其它的多线程技术一样，同步多线程能够从多个线程中取出指令来运行，它能够同时执行不同线程的指令。通过同步多线程技术，系统能够动态调整系统环境，如有可能同时执行不同线程的指令。当一个线程遇到长延迟事件时，允许另一个线程使用所用的处理单元。</p> <p>　　AIX 5L V5.3 中的同步多线程（SMT）：</p> <p>　　同步多线程（SMT）是一种在一个CPU&nbsp;的时钟周期内能够执行来自多个线程的指令的硬件多线程技术。本质上，同步多线程是一种将线程级并行处理（多CPU）转化为指令级并行处理（同一CPU）的方法。POWER5&nbsp;是实现这一技术的第一款IBM PowerPC 处理器，既可以处理单线程，也可以处理双线程。每个处理器核上有两个线程，并且AIX&nbsp;将每个线程配置为一个单独的逻辑处理器。尽管SMT&nbsp;是实现在物理硬件上的，但它的使用却是在操作系统层激活的，要求操作系统软件支持这一特性。&nbsp;在POWER5&nbsp;上， AIX V5.3 支持SMT。</p> <p>　　在AIX 5L V5.3 中SMT&nbsp;的每个线程都被操作系统视为一个单独的逻辑处理器。&nbsp;因此，拥有一个物理处理器的专属分区（dedicated partition）就会被AIX 5L V5.3 缺省配置为逻辑双路。由于这是不依赖于分区的类型的，因此拥有两个虚拟处理器的共享分区（shared partition）就会被AIX 5L V5.3 缺省配置为逻辑四路.用于列出物理设备的&nbsp;’lsdev’&nbsp;命令将显示出所安装的物理处理器的数量（每个POWER5&nbsp;芯片上有两个处理器），而其它的系统工具，如topas， nmon 以及bindprocessor，将会记录逻辑处理器的数量，也就是物理cpu数量的两倍。</p> <p>　　为了优化负载分配来使用SMT，AIX 5L V5.3 的系统调度策略也作了相应的修改。其一是为确保最大可能地利用物理CPU&nbsp;资源，在开始分配负载到每个处理器的第二个逻辑cpu&nbsp;之前，首先分配负载到它的第一个逻辑cpu.&nbsp;因此如果可运行的线程数少于可供使用的处理器数，&nbsp;此时可以得到最好的性能。只有当可运行的线程数多于可供使用的处理器数时，AIX&nbsp;才会开始调度线程到处理器的第二个逻辑cpu&nbsp;上去运行。其次，AIX&nbsp;也将调低空闲线程的优先权，并且提高那些拥有关键锁的线程的优先权，以便减少锁的持有时间。</p> <p>　　通过评估，SMT&nbsp;对于商业事务处理负载的性能优化可达30%。在更加注重系统的整体吞吐量而非单独线程的吞吐量时，SMT&nbsp;是一个很好地选择。例如，Web&nbsp;服务器和数据库服务器就非常适合应用SMT。</p> <p>　　下图展示了在一个4- way的1.65 GHz p5 570 POWER5系统上对于不同的负载SMT 所获得的性能优化。如图所示，针对不同的负载，系统吞吐量的提高在10%到50%之间。</p> <p>　　但是并非所有的应用都能通过SMT&nbsp;取得性能优化。那些性能受到执行单元限制的应用，或者那些耗尽所有处理器的内存带宽的应用，其性能都不会通过在同一个处理器上执行两个线程而得到提高。正是基于这个原因，POWER5&nbsp;也支持单线程执行模式。</p> <p>　　尽管SMT&nbsp;可以使系统识别到双倍于物理CPU数量的逻辑CPU（lcpu），但是这并不意味着系统拥有了两倍的CPU能力。</p> <p><br /></p>  【编程开发】cpu的核心数、线程数、处理器的位数、操作系统的位数、能够支持最大内存 小结 1453645494290 Text 1dad75de_9bfe9f1 【编程开发】 <p>一般处理器，都是几个核心，那就有几个线程。但是由于处理器技术发展越来越快，就诞生了一个“超线程”技术。如果是一核心一线程的话，那么核心在工作时，难免会有空闲、休息的时候。但是我们不想让它(核心)休息，就可以用超线程技术，给核心更多的线程，让处理器的利用率更高，从而提升处理器的能力。例如I3-2100就是双核心四线程，一个核心对应两条工作线，这样处理器核心绝对不会有空闲的时间。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：现在&nbsp;一般&nbsp;是&nbsp;一个核心，多个线程。<br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们也可以形象的把核心比喻为工作机器，线程则就是生产线。生产线多了，工作机器就绝对不会有空闲的机会，通过超线程技术，从而达到榨干处理器的目的。而且超线程技术是先天决定的，一些老处理器是没有的，且不会通过后天赋予！<br /></p> <p><br /></p> <p>最大支持内存和操作系统有直接关系，即使是64位处理器，使用32位操作系统支持的内存也最多为2的32次方，就是4G。在windows 32位操作系统中最大只识别3.25-3.75之间，根据windows版本不同而不同。而64位操作系统的寻址能力就是2的64次方。也就是17179869184G，当然这只是理论值，实际中不可能用到这么大的内存，目前64位windows系统最大只支持128G。而当前主流主板只能加到16G。</p> <p><br /></p>  【编程开发】再论超线程技术 1453644990098 Text 1dad75de_9bfe9db 【编程开发】 <p>Hyper-Threading做法是复制一颗处理器的架构指挥中心(architectural state)变成两个，使得Windows操作系统认为是在与两颗处理器沟通，但这两个架构指挥中心共享该处理器的工作资源（execution resources）。架构指挥中心追踪每个程序或执行绪的执行状况；工作资源指的则是“处理器用来进行加、乘、加载等工作的单元（execution unit）”。如此一来，操作系统把工作线程安排好以后，就分派给这两个逻辑上的处理器执行，而这颗CPU的每个执行单元等于在同样的时间内要服务两个“指令处理中心”，当然它的效率就高多了，操作系统就把一颗实体的处理器认定为两个逻辑处理器作工作指派，当然整体工作效能就比没有具备Hyper-Threading 的处理器高出许多，性价比自然高出许多。&nbsp;<br /><br />超线程技术实现的必要条件&nbsp;<br /><br />除了硬件支持之外，我们必须注意到，超线程技术的实现还需要软件的支持才能够发挥出应有的威力。首先是操作系统的支持，我们必须使用支持双处理器的操作系统，如Win2000等才能完全发挥出超线程技术的性能。至于软件方面，目前很多专业的应用程序对于双处理器都提供了支持，如著名的图形处理软件3Dmax、Maya等。&nbsp;<br /><br />此外，很多用户可能会有疑问，既然超线程技术以前专门针对服务器处理器，那么现有的众多软件，能否完全兼容支持超线程技术的处理器，是否还需要什么修改才能运行呢？其实这个我们大可不必担心，现有的IA32软件不需进行任何的修改，就可以在支持超线程的P4处理器上很好的运行了。&nbsp;<br /><br />超线程＝效能提升？&nbsp;<br /><br />一般很多人都会认为，采用超线程技术，就能使得系统效能大幅提升，但是事实真是如此么？不要忘了我们前面说到的超线程技术实现的必要条件，这可是超线程技术发挥应有效能的前提条件。除了操作系统支持之外，还必须要软件的支持。从这点我们就可以看出，就目前的软件现状来说，支持双处理器技术的软件毕竟还在少数。对于大多数软件来说，目前由于设计的原理不同，还并不能从超线程技术上得到直接的好处。因为超线程技术是在线程级别上并行处理命令，按线程动态分配处理器等资源。该技术的核心理念是“并行度（Parallelism）”，也就是提高命令执行的并行度、提高每个时钟的效率。这就需要软件在设计上线程化，提高并行处理的能力。而目前PC上的应用程序几乎没有为此作出相应的优化，采用超线程技术并没不能获得效能的大幅提升。&nbsp;<br /><br />上面说的只是目前软件支持的现状，操作系统在这个方面则没有太大的问题，毕竟Windows的某些版本、Linux都是支持多处理器的操作系统。并且随着Intel支持超线程技术的处理器面世之后，凭借Intel处理器的号召力，必然会引起目前应用程序设计上的改变，必然会有更多的支持并行线程处理的软件面世，届时，当然是支持超线程处理器大显身手的时候了。那时候，普通用户才能够从超线程技术中得到最直接的好处。&nbsp;<br /><br />但是我们还是需要看到，随着目前操作系统对于双处理器技术的广泛支持，例如Windows2000、Windows XP等操作系统都支持双处理器，在这些操作系统上使用支持超线程技术的处理器，对于系统的整体性能还是有一定的提高的<br /></p> v/+7dOaQXQpnxZ6K5NGX3g== zhangpy 但是得注意，一旦发生了共享资源的争夺，只能suspend一个，然后执行另一个，直到释放共享资源；然后对于多核结构来说，首先有完全独立的ALU，算术逻辑单元，硬件上是并行的，所以不存在对计算资源的争夺情况！！！ 1453645145178 3Wx9vl0wdoE=  v/+7dOaQXQpnxZ6K5NGX3g== zhangpy &acute;采用超线程即是可在同一时间里，应用程序可以使用芯片的不同部分。 &acute;虽然单线程芯片每秒钟能够处理成千上万条指令，但是在任一时刻只能够对一条指令进行操作。 &acute;而超线程技术可以使芯片同时进行多线程处理，使芯片性能得到提升。 1453645015958 3Wx9vl0wdoE=    【编程开发】超线程与多线程技术区别 1453643872220 Text 1dad75de_9bfe9bb 【编程开发】 <p>可以简单地把双核心技术理解为两个“物理”处理器，是一种“硬”的方式；而超线程技术只是两个“逻辑”处理器，是一种“软”的方式。从原理上来说，超线程技术属于Intel版本的多线程技术。这种技术可以让单CPU拥有处理多线程的能力，而物理上只使用一个处理器。超线程技术为每个物理处理器设置了两个入口─AS(Architecture State，架构状态)接口，从而使操作系统等软件将其识别为两个逻辑处理器。这两个逻辑处理器像传统处理器一样，都有独立的IA-32架构，它们可以分别进入暂停、中断状态，或直接执行非凡线程，并且每个逻辑处理器都拥有APIC(Advanced Programmable Interrupt Controller，高级可编程中断控制器)。<strong>虽</strong><strong>然支持超线程的Pentium 4能同时执行两个线程，但不同于传统的双处理器平台或双内核处理器，超线程中的两个逻辑处理器并没有独立的执行单元、整数单元、寄存器甚至缓存等等资源。它们在运行过程中仍需要共用执行单元、缓存和系统总线接口。在执行多线程时两个逻辑处理器均是交替工作，假如两个线程都同时需要某一个资源时，其中一个要暂停并要让出资源，要待那些资源闲置时才能继续。因此，超线程技术所带来的性能提升远不能等同于两个相同时钟频率处理器带来的性能提升。</strong>可以说Intel的超线程技术仅可以看做是对单个处理器运算资源的优化利用。而双核心技术则是通过“硬”的物理核心实现多线程工作：每个核心拥有独立的指令集、执行单元，与超线程中所采用的模拟共享机制完全不一样。在操作系统看来，它是实实在在的双处理器，可以同时执行多项任务，能让处理器资源真正实现并行处理模式，其效率和性能提升要比超线程技术要高得多，不可同日而语。<br /></p>  【编程开发】超线程技术 1453643819509 Text 1dad75de_9bfe9b8 【编程开发】 <p>超线程技术的原理很简单，以前的单核心处理器，在同一时间内只可以处理一项工作&nbsp;(<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/subview/1053/1053.htm\" >线程</a>，Thread)，如果要处理一项以上的工作时，以前的单核心处理器是不可行的，所以英特尔就开发了超线程技术，以一个单核心的处理器，去模拟出双核心的环境，但这并非能够把处理器的效能提升双倍，原因在于实体的核心始终只有一个，而效能有约百分之至二十至三十增长。</p> <p>在奔腾四时代<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/subview/2396/2396.htm\" >INTEL</a>就已经引入了人超线程技术，而特意的加长的流水线反而成了<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/subview/22761/22761.htm\" >HT技术</a>的累赘。</p> <p>所以推出奔腾D及后来的<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/subview/304287/304287.htm\" >酷睿2</a>系列时，英特尔并没有加进超线程技术，因为奔腾D及酷睿2处理器已支援双核心处理器的运作，而且INTEL也在默默的钻研指令预测技术减少流水线。在酷睿2后期英特尔推出了酷睿2<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/subview/1066166/1066166.htm\" >四核心处理器</a>，因为有用户反映双核不足以应付手头的工作，再到后来，&nbsp;英特尔酷睿i7出现了，他带着 Intel 全新的超线程技术，很短的流水线这得益于他的指令<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/subview/512423/512423.htm\" >分支预测</a>技术，拥有着奔腾四无法企及的效率，它是四核心处理器加进了超线程技术，处理器同时支持处理八个线程的工作，在这种环境下电脑可挂很多应用程序，支持多线程的应用，因此即使N多程序同时运行，电脑也没有运行减慢的感觉，操作起来依然是流畅如行云流水。</p> <p>其实超线程技术拥有最高的功耗效能比，加入超线程技术所增加的晶体管数目及功耗并不多，但却相比增加一颗完整的核心更具性价比，加上<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/subview/2187192/2187192.htm\" >酷睿i7</a>微架构拥有高带宽及高容量三级高速缓存的优势，更能将超线程技术的功效发挥到极致。</p> <p>要打开超线程技术，很简单，一般而言，在<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/361.htm\" >BIOS</a>内就可以设定超线程技术的启动与否。当设定完成后，进入Windows的“我的电脑”，查看处理器，就能看出八个线程的工作情况。</p> <p><br /></p>  【编程开发】超线程技术 多核 多处理器 1453643374906 Text 1dad75de_9bfe9aa 【编程开发】 <p>1 超线程技术</p> <p>每个单位时间内，CPU只能处理一个线程（Thread）。除非有两个核心处理单元，否则要想在单位时间内处理超过一个的线程是不可能的。</p> <p>超线程HT（Hyper-Threading）技术是在单个核心处理单元中集成两个逻辑处理单元，也就是一个实体内核（共享的运算单元），两个逻辑内核（有各自独立的处理器状态），在一颗CPU同时执行多个程序而共同分享一颗CPU内的资源，理论上要像两颗CPU一样在同一时间执行两个线程，P4处理器需要多加入一个Logical CPU Pointer（逻辑处理单元）。因此新一代的P4 的面积比以往的P4增大了5%。而其余部分如ALU（整数运算单元）、FPU（浮点运算单元）、L2 Cache（二级缓存）则保持不变，这些部分是被分享的。</p> <p>虽然采用超线程技术能同时执行两个线程，但它并不象两个真正的CPU那样，每各CPU都具有独立的资源。当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。因此超线程的性能并不等于两颗CPU的性能。</p>2 多处理器 <p>多处理器（Multiprocessor）系统由不同芯片上的多个处理器组成。多处理器系统因IT服务器的应用在上世纪九十年代得以普及。在当时，它们是可以插入机架服务器的处理器主板。现在，多处理器系统可以构建在同一块电路板上，处理器之间通过一个高速通信接口连接。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://images.cnitblog.com/blog/434663/201310/10233924-11e7d1fcb9e14d6185edcb026e91c56f.png\" ><img src=\"http://images.cnitblog.com/blog/434663/201310/10233926-90dc398a627843dc832fb31291087b5b.png\" style=\"max-width:500px;\" /></a></p> <p>图1 多处理器系统具有远程互联结构的独立高速缓存与MMU内存管理单元</p> <p>多处理器系统的复杂度低于多核系统，因为它们本质是互连在一起的单芯片CPU。多处理器系统的不足在于其高昂的价格，因为它们需要多个芯片，这比单芯片解决方案要昂贵得多。</p>3&nbsp;双核与多核处理器 <p>双核处理器是指单个芯片上有两个CPU，而多核处理器则是指在单个芯片上包含任意多个（如2、4或8）CPU的处理器。多核处理器的挑战在于软件开发部分。系统性能提升的多少直接与通过多线程编程源代码的并行程度有关。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://images.cnitblog.com/blog/434663/201310/10233927-cdf692beabdf467a81dc00a2c11aa8cf.png\" ><img src=\"http://images.cnitblog.com/blog/434663/201310/10233928-501fea7dcc554cf0b0f42d6c626f74d8.png\" style=\"max-width:500px;\" /></a></p> <p>图2 多核处理器共享具有短程互联结构的高速缓存和MMU内存管理单元</p>4&nbsp;总结 <p>超线程由于处理器实际上只有一个核心，能够提升的效能约为5~15%左右，且万一发生资源互抢的情形时，整体效能反而会下降。双核共用cache，程序设计合理性能可能比双处理器性能更好，多处理器可能还需在两个cache间传输数据，多核和超线程的区别如图3。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://images.cnitblog.com/blog/434663/201310/10233929-321e939c585743faa750d450049313ad.png\" ><img src=\"http://images.cnitblog.com/blog/434663/201310/10233929-3338288076cf4861a917d48a3e682138.png\" style=\"max-width:500px;\" /></a></p> <p>图 3 超线程和多核区别</p> <p><br /></p>  【编程开发】多核多线程的区别 1453641481826 Text 1dad75de_9bfe961 【编程开发】 <p>毫无疑问的，“多核”、“多线程”此二词已快成为当今处理器架构设计中的两大显学，如同历史战国时代以“儒”、“墨”两大派的显学，只不过当年两大治世思想学派是争得你死我亡，而多核、多线程则是相互兼容并蓄，今日几乎任何处理器都朝同时具有多核多线程的路线发展迈进。</p> <p>虽然两词到处可见，但可有人知此二者的实际差异？在执行设计时又是以何者为重？到底是该多核优先还是多线程提前？关于此似乎大家都想进一步了解，本文以下试图对此进行个中差异的解说，并尽可能在不涉及实际复杂细节的情形下，让各位对两者的机制观念与差别性有所理解。</p> <p><strong>行程早于线程</strong></p> <p>若依据信息技术的发展历程，在软件程序执行时的再细分、再切割的小型化单位上，先是有行程（Process），之后才有线程（Thread），线程的单位比行程更小，一个行程内可以有多个线程，在一个行程下的各线程，都是共享同一个行程所建立的内存寻址资源及内存管理机制，包括执行权阶、内存空间、堆栈位置等，除此之外各个线程自身仅拥有少许因为执行之需的变量自属性，其余都依据与遵行行程所设立的规定。</p> <p>相对的，程序与程序之间所用的就是不同的内存设定，包括分页、分段等起始地址的不同，执行权阶的不同，堆栈深度的不同等，一颗处理器若执行了A行程后要改去执行B行程，对此必须进行内存管理组态的搬迁、变更，而这个搬迁若是在处理器内还好，若是在高速缓存甚至是系统主存储器时，此种切换、转移程序对执行效能的损伤就非常大，因为完成搬迁、切换程序的相同时间，处理器早就可以执行数十到上千个指令。</p> <p><strong>两种路线的加速思维</strong></p> <p>所以，想避免此种切换的效率损耗，可以从两种角度去思考，第一种思考就是扩大到整体运算系统的层面来解决，在一部计算机内设计、配置更多颗的处理器，然后由同一个操作系统同时掌控及管理多颗处理器，并将要执行的程序的各个程序，一个程序喂（也称：发派）给一颗处理器去执行，如此多颗同时执行，每颗处理器执行一个程序，如此就可以加快整体的执行效率。</p> <p>当然！这种加速方式必须有一个先决条件，即是操作系统在编译时就必须能管控、发挥及运用多行程技术，倘若以单行程的系统组态来编译，那么操作系统就无法管控服务器内一颗以上的处理器，如此就不用去谈论由操作系统负责让应用程序的程序进行同时的多颗同时性的执行派送。</p> <p>即便操作系统支持多程序，而应用程序若依旧只支持单程序，那情形一样是白搭，操作系统无法对单行程程序再行拆分，依然是只喂入单一颗处理器上去执行，无从加速。</p> <p>同时用多颗处理器来执行，且每颗处理器执行一个行程，这是一种加速法，另一种加速法则是：尽量不进行内存管理组态的切换，避免切换的效能折损，线程正是在此概念下所出现的产物。</p> <p>不过，线程也要程序的搭配才能发挥，线程的概念出现与落实已是“C++看消、Java看长”的阶段，所以C++只能通过API呼用的方式来支持与使用多线程，如此必须改写过往的程序才行，改写成有呼用到支持多线程的API才行。相对的，较C++晚问世的Java则是原生支持多线程，不用改写也能发挥及运用多线程的特性及其加速效益。</p> <p>有了线程后，执行的分割、切割更加细腻，线程机制不仅在多颗处理器的系统内可以加速，在单颗处理器内也一样能获得好处，在多颗处理器的系统上每颗处理器不仅可以单独执行一个程序，当然也可以单独执行一个线程，而在单处理器系统上因为省去内存管理组态的搬迁，所以一样可以加速，很明显的，线程使执行的发派、分配更加细腻与灵活化。</p> <p><strong>线程的副作用</strong></p> <p>线程虽有好用的优点，不过它也有副作用的缺点，且此一优缺是一体两面无从分割，缺点是各个线程共享同一组内存管理组态及机制，倘若有一个线程的执行发生错误、瑕疵、或遭入侵等，其余在同一个行程内的每个线程也都会遭受影响、波及，最严重是同一个行程内的一切都错乱、毁坏，由此可知：线程其实是带有若干安全性牺牲的加速法。</p> <p>此外有人会误会，就字面上而言，多核表示同时间有多颗处理器在执行，每颗处理器可以执行一个行程或一个线程，但是一颗具有多线程能力的处理器并不表示它可以同时执行多个线程，事实上在同一时间内一颗具多线程功效的处理器也依然是执行一个线程而已，只是多线程处理器的内部可以将原有线程的相关信息及变量暂时搁摆，然后去执行其它的线程，执行完后在切换回原来执行到一半的线程，甚至没执行完也可以切换回来，且整个切换过程都在处理器内进行，不用与快取与内存进行搬迁置换，如此以快速换线程执行的方式来加速。</p> <p>相对于此的，一颗不具多线程能力的处理器，执行一个线程到一半若想改执行另一个线程，就必须将原线程、现线程的相关内容与信息搬迁到快取或内存，然后自快取及内存引入另一个线程，由于此一搬转颇耗时，所以多半选择将原有的线程执行完再引入下一个线程，如此在时间上可能还比较经济。然而无论一线程完整执行后再执行下一个线程，还是进行线程的进出搬迁转移，都不会比具备多线程能力的处理器来的快速有效。</p> <p><strong>至此我们可以归纳整理：</strong></p> <p>1.多核、多处理器系统中的每颗处理器（每个核），同时间内可以执行各自不同的行程（或线程）。</p> <p>2.一颗多线程能力的处理器，无论是支持二线程、四线程、八线程，这些线程都必须是在同一个行程内，所以一颗处理器（一个核）还是只能执行一个行程，双核处理器就能够同时执行两个不同的行程（或线程），四核就可以同时不同的四个行程（或线程）。</p> <p>3.倘若是执行不支持多线程的程序，其执行上的分拆最多只到行程而未到线程，那么每颗处理器内的多线程功效就无从发挥，而这类的程序历史较长久，相对的原生支持多线程的程序历史较短，不过信息技术的脚步向来进展快速，两种不同层次的支持仅差距数年时间。</p> <p><strong>产业实际发展可为证明</strong></p> <p>真的是多核优于、先于多线程吗？关于此可通过产业实际发展做为应证，Sun的UltraSPARC T1处理器（研发代号：Niagara）是八核四线程的设计，但接续的UltraSPARC T2处理器（研发代号：Niagara 2）则是八核八线程的设计，所以是核多、核优先，然后再来拉跋、提升线程的执行。</p> <p>同样的，IBM为Microsoft Xbox 360所设计的Xenon处理器，是个三核二线程的设计，核数依然是高于线程数，又如IBM、Sony、Toshiba三家业者合研的Cell处理器，现有第一代的Cell（研发代号：DD1）是九核，组态上是八核媒体（SPE）、一核泛用（PPE），新一代的Cell（研发代号：DD2）也针对PPE的部分进行双线程发展，如此再次表示核比线程重要，当Cell仅进行增一线程的扩展改进时，而非再增一核，即可知这仅是一次小幅的改进。</p> <p><strong>“多核”、“多线程”之外　还有“多令”、“多机”</strong></p> <p>最后，且让我们谈谈与多核、多线程不同加速走向的“多令”，“多令”是笔者发明的词，指的是比执行行程（Process）、线程（Thread）更基底层次的执行指令（Instruction），多核的作法是尽可能在同时间内执行多个行程，多令则是尽可能在同时间内执行多个指令，学术上的VLIW与产业上的EPIC皆是多令理念下的架构。</p> <p>到目前为止多令并非不可行，但仅行于数字信号、图像等处理，绘图芯片、媒体处理器等多实行VLIW架构，然多令在泛用运算上却未见效益，至于科学研究之类的高效运算也倾向使用更高层次的平行：多机（丛集、网格，执行范畴与分配类同于线程、行程），看来多令、多程/线程、多机各有所用，端看运用场合的适切性。</p> <p><br /></p> v/+7dOaQXQpnxZ6K5NGX3g== zhangpy 这在回到多核上去，多核就是有多个处理器核心，这样的话就是硬件上的并行，是真实的并行！ 1453641955302 3Wx9vl0wdoE=  v/+7dOaQXQpnxZ6K5NGX3g== zhangpy 真正的并行执行，只能是通过硬件上来支持，比如有多个处理单元，可以供调度使用。比如FPGA，这种完全的硬件逻辑电路，存粹的并行架构，因为它的并行实际上是一堆逻辑处理单元支持的，在同一时间，所有的units都是并发的process。 1453641882214 3Wx9vl0wdoE=  v/+7dOaQXQpnxZ6K5NGX3g== zhangpy 实际上，从操作系统来讲，多线程只是在线程调度算法下，比如时间片轮转调度算法，不同的线程分别抢占当前CPU的使用权而已，也就是说，在同一时间，只有一个线程在执行。这里的多线程在我看来，实际上只是为了减少由于等待而导致的CPU闲置时间，当发生比如IO阻塞的时候，多线程技术可以使得CPU切换到别的线程继续执行，直到发生IO阻塞的线程从阻塞中退出来后，在抢占CPU而已。这点对于提高用户体验非常有帮助，提高了系统的响应速率。 1453641747367 3Wx9vl0wdoE=    【编程开发】OpenMP的好处 1453639663407 Text 1dad75de_9bfe927 【编程开发】 <p>进入多核时代后，必须使用多线程编写程序才能让各个 CPU 核得到利用。在单核时代，通常使用操作系统提&nbsp;供的 API 来创建线程，然而，在多核系统中，情况发生了很大的变化，&nbsp;如果仌然使用操作系统 API 来创建线程会&nbsp;遇到一些问题。具体来说，有以下三个问题：&nbsp;<br /></p> <p>1) CPU 核数扩展性问题&nbsp;多核编程需要考虑程序性能随 CPU 核数的扩展性，即硬件升级到更多核后，能够丌修改程序就让程序性能增&nbsp;长，这要求程序中创建的线程数量需要随 CPU 核数变化，丌能创建固定数量的线程，否则在 CPU 核数超过线&nbsp;程数量上的机器上运行，将无法完全利用机器性能。虽然通过一定方法可以使用操作系统 API 创建可变化数量&nbsp;的线程，但是比较麻烦，比如 OpenMP 方便。 2)&nbsp;方便性问题&nbsp;在多核编程时，要求计算均摊到各个 CPU 核上去，所有的程序都需要并行化执行，对计算的负载均衡有很高&nbsp;要求。这就要求在同一个函数内戒同一个循环中，可能也需要将计算分摊到各个 CPU 核上，需要创建多个线&nbsp;程。操作系统 API 创建线程时，需要线程入口函数，很难满足这个需求，除非将一个函数内的代码手工拆成多&nbsp;个线程入口函数，这将大大增加程序员的工作量。使用 OpenMP 创建线程则丌需要入口函数，非常方便，可&nbsp;以将同一函数内的代码分解成多个线程执行，也可以将一个 for 循环分解成多个线程执行。 3)&nbsp;可移植性问题&nbsp;目前各个主流操作系统的线程 API 互丌兼容，缺乏事实上的统一规范，要满足可移植性得自己写一些代码，将&nbsp;各种丌同操作系统的 api 封装成一套统一的接口。 OpenMP 是标准规范，所有支持它的编译器都是执行同一&nbsp;套标准，丌存在可移植性问题。&nbsp;综上所述，在多核编程中，使用 OpenMP 就很有必要，。</p> <p><br /></p>  【编程开发】五种主要多核并行编程方法分析与比较 1453639229831 Text 1dad75de_9beacb8 【编程开发】 <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cnblogs.com/jpcflyer/archive/2012/02/18/2356906.html\" >五种主要多核并行编程方法分析与比较</a></p> <p>　　随着多核时代的到来与流行，传统的单线程串行程序的编程模式必将改变，取而代之的将是并行编程。目前已经有五种主要并行编程模型，下面将对此五种模型进行概括性的分析与比较：</p> <p><strong>1. MPI</strong></p> <p>　　MPI(Message Passing Interface)消息传递接口是MPI论坛发布的一个库，而不是一门实现语言，支持C/C++/Fortran。是一种消息传递编程模型，为进程间通信服务。MPI提供了一种与平台无关，可以被广泛使用的编写消息传递程序的标准。用它来编写消息传递程序，不仅实用、可移植、高效和灵活，而且和当前已有的实现没有太大的变化。目前MPI的主要实现有以下三种：</p> <p>&nbsp;</p> <p><img src=\"http://pic002.cnblogs.com/images/2012/364723/2012021816490619.jpg\" style=\"max-width:500px;\" /></p> <p>&nbsp;</p> <p>　　优点：可以在集群上使用，也可以在单核/多核CPU上使用，它能协调多台主机间的并行计算，因此并行规模上的可伸缩性很强，能在从个人电脑到世界TOP10的超级计算机上使用。</p> <p>　　缺点：第一，基于消息传递，需要显示划分和分布计算任务，显示进行消息传递与同步，且不易增量开发串行程序的并行性；第二，使用进程间通信的方式协调并行计算，这导致并行效率较低、内存开销大、不直观、编程麻烦。</p> <p>　　参考资料：<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.mpi-forum.org/\" >MPI论坛</a></p> <p><strong>2. OpenMP</strong></p> <p>　　OpenMP(Open Multi Processing)是由Open ARB发布的一种用于并行编程的规范，是建立在串行语言上的扩展，目前可以在C/C++/Fortran中使用。</p> <p>　　OpenMP由三部分组成：编译指导(compiler directive)、运行库(runtime library)和环境变量(environment variables)。其语言模型基于以下假设：执行单元是共享一个地址空间的线程，即OpenMP是基于派生/连接(fork/join)的编程模型。Fork/join的并行机制如下图所示：</p> <p><img src=\"http://pic002.cnblogs.com/images/2012/364723/2012021811561455.gif\" style=\"max-width:500px;\" /></p> <p>　　Fork/join并行机制：并行区前，串行命令派生出多条并行命令并行执行，执行到并行区末等待，等所有并行任务都结束，再转到串行执行。</p> <p>　　OpenMP有两种常用的并行开发形式：一是通过简单的fork/join对串行程序并行化；二是采用单程序多数据对串行程序并行化。</p> <p>　　优点：第一，共享存储模型，使得程序员不必进行数据划分和分布，使得开发并行程序比较容易；第二，更适合于SMP系统；第三，主要面向循环级的并行开发，可以容易地实现增量性的并行化。</p> <p>　　缺点：第一，OpenMP只适用于SMP结构；第二，OpenMP主要开发循环级的并行程序，受此限制，对某些应用并不适合；第三，OpenMP的编写、正确性调试和性能调度复杂。</p> <p>　　参考资料：<a target=\"_blank\" rel=\"nofollow\" href=\"http://openmp.org/wp/about-openmp/\" >Open ARB - OpenMP</a></p> <p><strong>3. Intel IPP</strong></p> <p>　　Intel IPP(Integrated Performance Primitives)，Intel集成性能基元是Intel函数库的第二代。Intel为每种新的多核处理器都发布一个IPP函数库（C/C++ API），专用于多核架构，提供了调度优化的函数库，其中涉及的领域有数学、信号处理、音频视频、图像处理与编码、字符串、密码学。 IPP的组成如下图所示：</p> <p>&nbsp;</p> <p><img src=\"http://pic002.cnblogs.com/images/2012/364723/2012021817012525.jpg\" style=\"max-width:500px;\" /></p> <p>&nbsp;</p> <p>　　优点：是经过性能高度优化的库，执行效率高。</p> <p>　　缺点：专用于Intel处理器和某些领域，不方便移植。</p> <p>　　参考资料：<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.xlsoft.com.cn/product.asp?action=1&amp;id=68\" >Intel IPP产品介绍</a></p> <p><strong>4. Intel TBB</strong></p> <p>　　Intel TBB(Threading Building Blocks)，Intel线程构建模块，是一个为创建可靠的、可移植的和可扩展的并行程序的C++模板库。专用于编写高层抽象的C++程序，和可移植的程序。</p> <p>　　优点：可移植、可扩展。</p> <p>　　缺点：性能没有IPP高。</p> <p>　　参考资料：<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.xlsoft.com.cn/product.asp?action=1&amp;id=201\" >Intel TBB产品介绍</a></p> <p><strong>5. MapReduce</strong></p> <p>　　&nbsp;&nbsp;MapReducesh是Google的人研究出来的一个模型，开发的一个针对大规模群组中的海量数据处理的分布式编程模型。</p> <p>　　参考资料：<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.mapreduce.org/\" >http://www.mapreduce.org/</a></p> <p>　　此外，并行编程模式还有X3H5, Phreads, HPF等，但都不常用。</p> <p><br /></p> v/+7dOaQXQpnxZ6K5NGX3g== zhangpy 现在主要想学的是基于DSP的OpenMP，想着是可以先从Windows或者Linux操作系统下熟悉这种并行结构的发开，然后再转战到DSP6678上来。OpenMP的好处是具备良好的可移植性，估计在windows下或者在linux，还是在DSP的SYS/BIOS下都是一样的：OpenMP的参考下一篇文章！ 1453639628415 3Wx9vl0wdoE=  v/+7dOaQXQpnxZ6K5NGX3g== zhangpy SMP对称多处理器结构，前段时间做过的关于操作系统的概述PPT，真是让我获益匪浅啊！ 1453639398932 3Wx9vl0wdoE=    【编程开发】使用OpenMP进行多核编程开发 1453639093495 1453639104791 Text 1dad75de_9beacae 【编程开发】 <p><strong>使用多核CPU，并行编程超简单！</strong><br /></p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OpenMP提供了对<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/754510.htm\" >并行算法</a>的高层的抽象描述，<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/39175.htm\" >程序员</a>通过在<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/60376.htm\" >源代码</a>中加入专用的pragma来指明自己的意图，由此<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/487018.htm\" >编译器</a>可以自动将程序进行并行化，并在必要之处加入同步互斥以及通信。但是，作为高层抽象，OpenMP并不适合需要复杂的线程间同步和互斥的场合。OpenMP的另一个缺点是不能在非<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/120892.htm\" >共享内存</a>系统(如<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/800440.htm\" >计算机集群</a>)上使用，在这样的系统上，MPI使用较多。<br /></strong></p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，还有一个更简单的方法就是使用Go语言。&nbsp;&nbsp;</strong></p> <p><strong><br /></strong></p> <p><strong><br /></strong></p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windows &nbsp;例子(Visual Studio，C语言)<br /></strong></p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我用的是Windows系统(Win8)的双核台式机&nbsp;&nbsp;,&nbsp;&nbsp;用C语言写源代码，以Visual Studio 2012为编译器。打开Visual Studio 2012，需要在建立工程后，点击&nbsp;菜单栏-&gt;Project-&gt;Properties，弹出菜单里，点击 Configuration Properties-&gt;C/C++-&gt;Language-&gt;OpenMP Support，在下拉菜单里选择Yes。然后才能使用OpenMP。</strong></p> <p><strong><br /></strong></p> <p><strong>下面以并行代码为例，只需要把相应的行注释掉，就是串行代码了！下同。</strong></p> <p><strong>&nbsp;</strong></p> <p><strong>第一个例子(example_1.c):</strong></p> <p><strong>增加一行代码#pragma omp parallel，然后用花括号把你需要放在并行区内的语句括起来，并行区就创建好了。<br /></strong></p> <p><strong>默认情况下，并行区内线程数=系统中核的个数。并行区里每个线程都会去执行并行区中的代码。故对于双核电脑，</strong><strong>并行区中的代码会被执行2次，当然若有输出语句，结果也会被输出2次&nbsp;&nbsp;&nbsp;&nbsp;。</strong></p> <p><br /></p> <p><strong><img src=\"http://image.sciencenet.cn/album/201303/19/1848288317z8wvvsvp87v8.png\" style=\"max-width:500px;\" /><br /></strong></p> <p><br /></p> <p><strong>运行example_1.c，&nbsp;会发现&nbsp;并行区里面的语句会被执行2次（我的电脑是2核的&nbsp;&nbsp;），&nbsp;&nbsp;多次运行，会发现各次运行的结果会不一样，打印到屏幕上结果的顺序是不一定的，这个符合多线程程序的特性。&nbsp;当然，&nbsp;运行过程中也可以观察到CPU的使用率是100%.&nbsp;&nbsp;</strong></p> <p><strong>我运行了2次，结果不同，如下所示：</strong></p> <p><strong><img src=\"http://image.sciencenet.cn/album/201303/19/185642nqlqwilqwlhnuler.png\" style=\"max-width:500px;\" /></strong></p> <p><br /></p> <p><strong><img src=\"http://image.sciencenet.cn/album/201303/19/185939qjm8qjjmqeqmbqjh.png\" style=\"max-width:500px;\" /><br /></strong></p> <p><br /></p> <p><br /></p> <p><br /></p> <p><strong>第二个例子(example_2.c):<br /></strong></p> <p><strong>example_1.c中并行区里每个线程执行的代码是一样的，计算机若有N个核，相当于同时重复执行了N次，并没有提高效率、节省时间。我们希望的是把同一工作分配给不同线程来做，每个线程完成一部分，这样运行速率才会快。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br /></strong></p> <p><strong>#pragma omp for <br />使用这个语句，就可以把一个for循环的工作量分配给不同线程。这个语句后面必须紧跟一个for循环，它只能对循环的工作量进行划分、分配。<br /></strong></p> <p><br /></p> <p><strong><img src=\"http://image.sciencenet.cn/album/201303/19/2012510axonhj91snj9mz6.png\" style=\"max-width:500px;\" /><br /></strong></p> <p><br /></p> <p><strong>可以把多行openmp pragma合并成一行，<br /></strong></p> <p><strong>#pragma omp parallel,&nbsp;#pragma omp for 合并成一行#pragma omp parallel for ，&nbsp;合并后的程序如下：</strong></p> <p><br /></p> <p><strong><img src=\"http://image.sciencenet.cn/album/201303/19/203116kxzugshtwu2oedui.png\" style=\"max-width:500px;\" /></strong></p> <p><br /></p> <p><strong>并行计算的运行用了16.415秒。</strong></p> <p><strong>把第11行（#pragma omp parallel for）注释以后，&nbsp;就成为了传统的串行计算，运行用了29.116秒。<br /></strong></p> <p><br /></p> <p><strong>双核运行的时间大约缩短为单核的二分之一，说明OpenMP还是很强大的。运行过程中也可以观察到CPU的使用率是100%.</strong></p> <p><strong><br /></strong></p> <p><strong><br /></strong></p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></p> <p><strong><br /></strong></p> <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Linux &nbsp;例子(GCC，C语言)</strong></p> <p><strong>源代码和Windows<strong>中的&nbsp;差不多，用<strong>GCC</strong></strong>编译时加上&nbsp;-fopenmp&nbsp;就可以了.</strong></p> <p><strong><br /></strong></p> <p><strong>未完待续。2013年6月1号以后继续纠结这个问题。没办法，又要写英文的期刊论文，又要写硕士毕业论文。</strong><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong></p> <p><strong><br /></strong></p> <p><strong><br /></strong></p> <p><strong><br /></strong></p> <p><strong><br /></strong></p> <p><strong>参考：</strong></p> <p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.openmp.org/\" >http://www.openmp.org</a><br /></strong></p> <p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/1687659.htm\" >http://baike.baidu.com/view/1687659.htm</a><br /></strong></p> <p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cnblogs.com/yangyangcv/archive/2012/03/23/2413335.html\" >http://www.cnblogs.com/yangyangcv/archive/2012/03/23/2413335.html</a><br /></strong></p> <p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"http://linux.chinaunix.net/techdoc/develop/2006/10/19/942441.shtml\" >http://linux.chinaunix.net/techdoc/develop/2006/10/19/942441.shtml</a><br /></strong></p> <p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.rosoo.net/a/201111/15347.html\" >http://www.rosoo.net/a/201111/15347.html</a><br /></strong></p> <p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"http://hi.baidu.com/diwulechao/item/bc6d865c411b813c32e0a932\" >http://hi.baidu.com/diwulechao/item/bc6d865c411b813c32e0a932</a></strong></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/3674653.htm\" ><strong>http://baike.baidu.com/view/3674653.htm</strong></a><br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/1516611.htm\" ><strong>http://baike.baidu.com/view/1516611.htm</strong></a><br /></p> <p><br /></p> <p><strong>Go语言相关网站：</strong></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://code.google.com/p/go/\" ><strong>http://code.google.com/p/go/</strong></a><br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://go-lang.cat-v.org/\" ><strong>http://go-lang.cat-v.org/</strong></a><br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://code.google.com/p/golang-china/\" ><strong>http://code.google.com/p/golang-china/</strong></a><br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://zh.golanger.com/\" ><strong>http://zh.golanger.com/</strong></a><br /></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://tieba.baidu.com/f?kw=go%D3%EF%D1%D4&amp;fr=ala0\" ><strong>http://tieba.baidu.com/f?kw=go%D3%EF%D1%D4&amp;fr=ala0</strong></a><br /></p> <p><strong><a target=\"_blank\" rel=\"nofollow\" href=\"http://studygolang.com/\" >http://studygolang.com/</a></strong><br /></p> <p><strong><br /></strong></p> <p><br /></p>  【编程开发】推荐10款编程工具：为多核开发保驾护航 1453638790171 Text 1dad75de_9beaca2 【编程开发】 <p>早在2001年IBM推出了基于双核的Power4处理器；随后Sun和HP乘风追击，先后推出了基于双核架构的UltraSPARC IV以及PA-RISC8800处理器。但这些面向高端应用的RISC处理器曲高和寡，并没有能够引起广大群众的关注。直到2005年第二季度，Intel发布了基于X86的桌面双核处理器，从此多核才走进平常百姓家。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时至今日，多核处理器的时代已经席卷而来。单核芯片已经渐行渐远了。多核编程既是机遇也是挑战，如何在这个行业大变革中把握方向、与时俱进，成为当务之急。怎么在一个芯片上来顺利处理多CPU内核编程成为了一件棘手的难题，这些多核处理器正在潜移默化地改变着开发人员传统的编程习惯。</p> <p>　　一旦您学会了用并行的方法来处理编程，任何问题就会迎刃而解。并行编程环境过去是很不方便的。但是随着并行计算社区的发展，尤其是多核和多芯片服务器的使用越来越广泛，高性能和并行计算获得了越来越多的支持。因此，需要一种优秀的并行平台。今天，我为大家重磅推荐10款工具，可以帮助大家缓解压力，顺利过渡到多核软件开发中。</p> <p>　　<strong>1、Intel Parallel Studio</strong></p> <p><img src=\"http://image20.it168.com/201204_800x800/1004/ccd395b3ead52b0b.jpg\" style=\"max-width:500px;\" /></p> <p>　　Parallel Studio并行程序开发套件，旨在为基于Microsoft Visual Studio的C与C++程序开发各阶段提供简单、高效的Parallel Studio工具，显著提高应用程序在英特尔多核处理器上的性能。</p> <p>　　英特尔 Parallel Studio由英特尔 Parallel Composer、英特尔 Parallel Inspector以及英特尔 Parallel Amplifier三部分组成，每一款都具有强大的功能，既可各自独立使用，也可一起使用，可快速满足开发人员的并行程序开发需求。它具有较强的线程管理功能，提供优化的编译器和库，还拥有内存错误和线程检查器，以及线程性能分析器。</p> <p>　<strong>　2、Intel Threading Building Blocks</strong></p> <p>&nbsp;<img src=\"http://image20.it168.com/201204_800x800/1004/1ca2bf8e48431a95.jpg\" style=\"max-width:500px;\" /></p> <p>　　在多核的平台上开发并行化的程序，必须合理的利用系统的资源，如与内核数目相匹配的线程，内存的合理访问次序，最大话重用缓存。有时候用户使用低级应用接口创建、管理线程、很难保证应用程序是否处于最佳状态。</p> <p>　　作为Intel Parallel Studio XE (Extreme Edition)的一部分，Intel Threading Building Blocks提供了C++模板库，线程库的接口适合于跨平台移植，允许开发人员按照可用的处理器内核，来部署基于任务的并行应用程序。它提供了一些组件来实现并行编码，非常灵活，适合不同的多核平台，可以很好的解决上面的问题，用户可以不必关注线程，转而重点关注任务。</p> <p>　　<strong>3、Microsoft C ++ AMP</strong></p> <p><img src=\"http://image20.it168.com/201204_800x800/1004/46afe0ff23a90d03.jpg\" style=\"max-width:500px;\" /></p> <p>　　C++ AMP是微软Visual Studio和C++编程语言的新扩展，用于帮助开发人员充分适应现在和未来的高度并行和异构计算环境。C++ AMP标准将是一种开放的规范，它使用C++语言的句法，允许其它编译器集成和支持。通过这个C++ AMP扩展程序，能够让程序员轻松调用CPU和GPU的异构并行计算性能。微软据称这个扩展程序未来将会公开，并且允许其他编译器集成它。目前比较常用的接口标准是OpenCL，而微软推出这样的工具，可以让程序员有另外一个选择。</p> <p>　<strong>　4、Microsoft Visual Studio 2010 和&nbsp;.Net Framework 4</strong></p> <p><img src=\"http://image20.it168.com/201204_800x800/1004/4ff286c1cc3310e2.jpg\" style=\"max-width:500px;\" /></p> <p>　　微软强化了Visual Studio 2010和.NET Framwork 4的功能，它提供了并行扩展套件Parallel Extension，主要由 Task parallel Library、Parallel LINQ、Coordination Data Structures等三部分组成。该并行扩展套件时一个.NET类库，支持声明式和命令式的数据并行、还支持协同的数据结构，允许开发人员编写并行和并发应用程序。</p> <p>　　<strong>5、Rogue Wave Software ThreadSpotter</strong></p> <p><img src=\"http://image20.it168.com/201204_800x800/1004/10f319497edcfdf2.jpg\" style=\"max-width:500px;\" /></p> <p>　　Rogue Wave Software ThreadSpotter是一款工具，在多核和单核系统中用来优化内存、分析内存和线程通信，暴露性能上的问题，并提供解决问题的方案。</p> <p><strong>6、Rogue Wave Software TotalView</strong></p> <p><img src=\"http://image20.it168.com/201204_800x800/1004/d25df8c35f9d9432.jpg\" style=\"max-width:500px;\" /></p> <p>　　Rogue Wave Software TotalView提供了一组调试工具套件，适用于C/C++的调试，可用来查找和纠正代码错误，验证原型和验证码。这些工具支持编译应用程序运行在Linux、Unix和Mac OS X上。</p> <p>　　<strong>7、Eclipse Parallel Tools Platform</strong></p> <p><img src=\"http://image20.it168.com/201204_800x800/1004/cf359adc66e2df2a.jpg\" style=\"max-width:500px;\" /></p> <p>　　这种开源的Eclipse Parallel Tools Platform(PTP)项目主要用来为并行应用程序的开发提供一个高效的平台，它内嵌的IDE支持并行架构和运行时系统，拥有并行调试器，为大多数并行工具提供了扩展支持。Eclipse Parallel Tools Platform是一个一致的基于开放标准的 Eclipse 环境，它允许高性能计算应用程序的开发人员消除开发周期中的发现阶段。有了 Eclipse 和 Java 编程语言的帮助，在机器之间迁移时就不再需要学习另一种高性能计算平台。由于 LANL 和 Eclipse 平台的贡献，现在有了一个用来开发、运行和调试并行应用程序的一致的平台。它可以用来构造一个与网格相似的机器阵列，从而帮助进行高性能计算。可以选择由多少个进程组成应用程序，当应用程序运行时，每个进程可以在单独的机器上运行、执行计算并使用 MPI 在进程之间来回传递数据。PTP&nbsp;创建一个包含所有可用机器的网格，作业可以通过网络在这些机器上运行</p> <p>　<strong>　8、Oracle Solaris Studio</strong></p> <p><img src=\"http://image20.it168.com/201204_800x800/1004/2b9c060a896fdedb.jpg\" style=\"max-width:500px;\" /></p> <p>　　Oracle Solaris Studio是一个针对C、C++和Fortran的开发套件平台，可为Oracle Solaris系统创建快速、可扩展、安全和可靠的企业应用程序。它提供的一些分析工具可以用来优化编译器，提高多线程的性能，使应用程序运行在Solaris、Oracle Linux、和Red Hat Enterprise Linux平台上。Oracle Solaris Studio通过为并行开发提供igongOpenMP 3.1 API的规范，从而来简化多核开发。它还支持Sparc和x86的CPU架构。</p> <p>　　<strong>9、IBM Rational Rhapsody Developer</strong></p> <p><img src=\"http://image20.it168.com/201204_800x800/1004/67065a62382d567b.jpg\" style=\"max-width:500px;\" /></p> <p>　　&middot; IBM Rational Rhapsody Developer是一个面向基于统一建模语言&nbsp;(UML)&nbsp;的嵌入式、实时或技术应用程序软件开发的可视化开发环境。它可以为多核处理器生成代码，同时在部署多核应用程序的时候降低复杂性。它有助于提高整个嵌入式软件开发生命周期(从需求捕获到实施、测试和部署)的生产力。它可以生成完整的嵌入式应用程序，能用来模拟和基于模型的测试及可视化开发、&nbsp;能将需求存储在设计元素和测试用例中，提供模型内的跟踪信息，帮助团队协作管理在不同环境中开发一致性设计的复杂性。与其他 IBM Rational 产品集成，可进行完整的产品生命周期开发。此外，您还可以使用可选的附加软件产品扩展 Rational Rhapsody Developer 的功能。</p> <p>　　<strong>10、Tilera Multicore Development Environment</strong></p> <p><img src=\"http://image20.it168.com/201204_800x800/1004/78a38a4862dc9038.jpg\" style=\"max-width:500px;\" /></p> <p>　　Tilera Multicore Development Environment是一个多核编程平台，它具有Tilera的Tile处理器架构的并行处理能力。它提供了Linux运行时组件、Eclipse IDE，具有图像多核应用程序的调试和分析功能，还支持类似Perl、Python、PHP和 Erlang等语言。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总之，作为一线的编程人员，我们必须直面多核革命带来的冲击。因为从单核到多核并不像处理器时钟频率的提升那样对程序员而言是透明的。对于Windows程序员来说，使用多线程的主要原因之一是为了提高用户体验：如在长时间的计算中提高UI、I/O或者网络的响应速度。而在多核时代我们编写应用程序是为了充分利用多个计算核心，缩短计算时间或者在相同的时间段内计算更多任务。现在用的多核编程工具注意是面向共享存储机制的openMP，主要利用的共享内存保护机制是分布式锁机制。如果我们的编写的程序没有针对多核的特点来设计，那就不能完全获得多核带来的性能提升。在这样一个旧瓶换新酒的时代，希望这十款编程工具能为多核编程人员保驾护航，在软件开发中乘风破浪。</p> <p><br /></p>  【编程开发】socket套接字缓冲区设置 1453457827197 Text 1dad75de_9b8dfa6 【编程开发】 <p>socket发送数据时候先把数据发送到socket缓冲区中，之后接受函数再从缓冲区中取数据，如果发送端特别快的时候，缓冲区很快就被填满（socket默认的是1024&times;8=8192字节），这时候我们应该根据情况设置缓冲区的大小，可以通过setsockopt函数实现</p> <p>&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>int</strong>&nbsp;<strong>setsockopt(</strong><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>SOCKET</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/zhaozy55555/article/details/3327050\" ><span style=\"text-decoration:underline;\" >s</span></a><strong>,<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>int</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/zhaozy55555/article/details/3327050\" ><span style=\"text-decoration:underline;\" >level</span></a><strong>,<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>int</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/zhaozy55555/article/details/3327050\" ><span style=\"text-decoration:underline;\" >optname</span></a><strong>,<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>const char*</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/zhaozy55555/article/details/3327050\" ><span style=\"text-decoration:underline;\" >optval</span></a><strong>,<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>int</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/zhaozy55555/article/details/3327050\" ><span style=\"text-decoration:underline;\" >optlen</span></a><strong><br /></strong><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</strong><br />&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp; eg：</p> <p>&nbsp;&nbsp; int optVal = 1024*1024 ;<br />&nbsp;&nbsp; int optLen = sizeof(int);</p> <p>&nbsp;</p> <p>&nbsp;&nbsp;&nbsp; setsockopt(socket, SOL_SOCKET,SO_RCVBUF,(char*)&amp;optVal,optLen );</p> <p>&nbsp;</p> <p>&nbsp;&nbsp;&nbsp; socket：传输数据的socket</p> <p>&nbsp;&nbsp;&nbsp; SOL_SOCKET：基本套接口&nbsp;<br />&nbsp;&nbsp;&nbsp; SO_RCVBUF：接受数据的缓冲区</p> <p>&nbsp;&nbsp;&nbsp; optVal：&nbsp;缓冲区大小</p> <p>&nbsp;&nbsp;&nbsp; optLen ：指向缓冲区大小变量的长度</p> <p><br /></p> v/+7dOaQXQpnxZ6K5NGX3g== zhangpy 关于这一点，在实际应用中，常常会忘记设置，但是在DSP的网络通信开发中，常常都会涉及！ <br />一般在windows下，再进行高速的图像数据传输的时候，增加缓存是能在一定程度上减少丢数现象的！ 1453645269836 3Wx9vl0wdoE=    【硬件开发】二次电源 1452741243602 Text 1dad75de_9a0fc5d 【硬件开发】 <p>二次电源，即将主电源电能变换为另一种形式或规格的电能的装置，用以满足不同用电设备的需要，是飞行器电源系统的重要组成部分。可将直流电压变换成交流电压或高压直流电压，是常见的应急电源的主要组成部分。<br /></p> <p><br /></p> <p><br /></p>  【编程开发】C/C++如何创建文件夹 1452741139423 Text 1dad75de_9a0fc53 【编程开发】 <p>通过system();函数调用DOS命令来创建文件夹和删除文件、文件夹。创建文件可以用其文件操作实现。&nbsp;<br />system(&quot;md c:\\\\mydir&quot;);//创建一个文件夹&nbsp;<br />system(&quot;rd c:\\\\mydir&quot;);//删除一个文件夹&nbsp;<br />system(&quot;c:\\\\test\\\\myfile.dat&quot;);//删除一个文件。</p> <p><br />标准C++本身不能创建文件夹，但不同编译器本身对这个功能都做了扩展，VC使用 _mkdir(&quot;mydir&quot;)函数来创建（#include &lt;direct.h&gt;)，TC使用mkdir(&quot;mydir&quot;)来创建(#include&nbsp;&lt;dir.h&gt;)。&nbsp;<br />如果只是创建文件夹，还可以利用system(&quot;md mydir&quot;)函数来解决;</p> <p>摘自MSDN:</p> <p>Creates a new directory.</p> <p>int _mkdir(<br />&nbsp;&nbsp; const char *dirname&nbsp;<br />);<br />int _wmkdir(<br />&nbsp;&nbsp; const wchar_t *dirname&nbsp;<br />);</p> <p>Parameters<br />dirname<br />Path for a new directory</p> <p>Return Value<br />Each of these functions returns the value 0 if the new directory was created. On an error, the function returns –1 and sets errno as follows.</p> <p>EEXIST<br />Directory was not created because dirname is the name of an existing file, directory, or device.</p> <p>ENOENT<br />Path was not found.</p> <p>For more information about these and other return codes, see _doserrno, errno, _sys_errlist, and _sys_nerr.</p> <p>Remarks<br />The _mkdir function creates a new directory with the specified dirname. _mkdir can create only one new directory per call, so only the last component of dirname can name a new directory. _mkdir does not translate path delimiters. In Windows NT, both the backslash (&nbsp;\\) and the forward slash (/&nbsp;) are valid path delimiters in character strings in run-time routines.</p> <p>_wmkdir is a wide-character version of _mkdir; the dirname argument to _wmkdir is a wide-character string. _wmkdir and _mkdir behave identically otherwise.</p> <p><br />Example<br />// crt_makedir.c</p> <p>#include &lt;direct.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;stdio.h&gt;</p> <p>int main( void )<br />{<br />&nbsp;&nbsp; if( _mkdir(&nbsp;&quot;\\\\testtmp&quot;&nbsp;)&nbsp;== 0 )<br />&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&nbsp;&quot;Directory '\\\\testtmp' was successfully created\\n&quot;&nbsp;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; system(&nbsp;&quot;dir \\\\testtmp&quot;&nbsp;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _rmdir(&nbsp;&quot;\\\\testtmp&quot;&nbsp;)&nbsp;== 0 )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&nbsp;&quot;Directory '\\\\testtmp' was successfully removed\\n&quot;&nbsp;&nbsp;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&nbsp;&quot;Problem removing directory '\\\\testtmp'\\n&quot;&nbsp;);<br />&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&nbsp;&quot;Problem creating directory '\\\\testtmp'\\n&quot;&nbsp;);<br />}</p> <p>Sample Output<br />Directory '\\testtmp' was successfully created<br /> Volume in drive C has no label.<br /> Volume Serial Number is E078-087A</p> <p> Directory of C:\\testtmp</p> <p>02/12/2002&nbsp; 09:56a &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;DIR&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br />02/12/2002&nbsp; 09:56a &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;DIR&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 File(s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 bytes<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 Dir(s)&nbsp; 15,498,690,560 bytes free<br />Directory '\\testtmp' was successfully removed</p> <p>对文件的删除：</p> <p>转自：&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://zhidao.baidu.com/question/22529744.html?si=1\" >http://zhidao.baidu.com/question/22529744.html?si=1</a></p> <p>C++&nbsp;也有&nbsp;<br />#include &lt;stdio.h&gt;&nbsp;<br /><br />void main( void )&nbsp;<br />{&nbsp;<br />if( remove(&nbsp;&quot;remove.obj&quot;&nbsp;)&nbsp;==&nbsp;-1 )&nbsp;<br />perror(&nbsp;&quot;Could not delete 'REMOVE.OBJ'&quot;&nbsp;);&nbsp;<br />else <br />printf(&nbsp;&quot;Deleted 'REMOVE.OBJ'\\n&quot;&nbsp;);&nbsp;<br />}</p> <p>呵呵，有了这些函数应该可以写一个打包程序了吧。呵呵。。。</p> <p>加油。。。</p> <p><br /></p>  【编程开发】C/C++判断文件/文件夹是否存在 1452741057578 Text 1dad75de_9a0fc4d 【编程开发】 <p>一、判断文件夹是否存在：<br />&nbsp;&nbsp;&nbsp;&nbsp; 1.用CreateDirectory(&quot;.\\\\FileManege&quot;,NULL);如果文件夹FileManege不存在，则创建。<br />&nbsp;&nbsp;&nbsp;&nbsp; 2.或者if(_access(&quot;.\\\\FileManege&quot;,0)==-1)，表示FileManege不存在。<br />&nbsp;&nbsp;&nbsp;&nbsp; 3.或者BOOL PathIsDirectory(LPCTSTR pszPath);</p> <p>二、判断文件是否存在：<br />&nbsp;&nbsp;&nbsp;&nbsp; 1.用if((file=fopen(&quot;.\\\\FileManege\\\\F\\\\F.dat&quot;,&quot;rb&quot;))==NULL)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file=fopen(&quot;.\\\\FileManege\\\\F\\\\F.dat&quot;,&quot;ab+&quot;);&nbsp;//&nbsp;先判断有无文件，没的话新建一个<br />&nbsp;&nbsp;&nbsp;&nbsp; 2.用if(_access(&quot;.\\\\FileManege\\\\F\\\\F.dat&quot;,0)==-1)，表示文件不存在。</p> <p><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数int _access( const char *path, int mode );可以判断文件或者文件夹的mode属性<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode=00;//Existence only<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode=02;//Write permission<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode=04;//Read permission<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode=06;//Read and write permission<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要包含头文件&lt;io.h&gt;。</p> <p><br /></p>  【编程开发】CString与string之间的转化 1452740752292 Text 1dad75de_9a0fc39 【编程开发】 <p>都通过基本类型来转换即可：<br />CString可以转换为基本类型LPCTSTR，LPCTSTR根据项目编码可以是const char*或者const wchar_t*；string可以用c_str()转换为const char*，stringw可以用c_str()转换为const w_char*。而CString和string/w都重载了=赋值操作符，可以把char*或者wchar_t*字符串赋值给CString或者string/w类型的变量，或者调用其构造函数。</p> <p>&nbsp;</p> <p>string to CString比较简单<br />string str=&quot;abcde&quot;;<br />CString cstr(str.c_str());<br /><br />CString to string,要看你的CString用的是UNICODE还是非UNICODE,<br />非UNICODE就简单了<br />CString cs=&quot;abcde&quot;;<br />string str(cs.GetBuffer(cs.GetLength()));<br />UNICODE就麻烦点<br />需要转换一下才行,给个函数你用<br />CString cs=_T(&quot;abcde&quot;);<br />string str=CGeneralUtility::WChar2Ansi(cs.GetBuffer(cs.GetLength()));<br />string CUtility::WChar2Ansi(LPCWSTR pwszSrc)<br />{<br />int nLen = WideCharToMultiByte(CP_ACP, 0, pwszSrc,&nbsp;-1, NULL, 0, NULL, NULL);<br />if (nLen&lt;= 0) return std::string(&quot;&quot;);<br />char* pszDst = new char[nLen];<br />if (NULL&nbsp;== pszDst) return std::string(&quot;&quot;);<br />WideCharToMultiByte(CP_ACP, 0, pwszSrc,&nbsp;-1, pszDst, nLen, NULL, NULL);<br />pszDst[nLen -1]&nbsp;= 0;<br />std::string strTemp(pszDst);<br />delete [] pszDst;<br />return strTemp;<br />}</p> <p>&nbsp;</p> <p>1，string -&gt; CString &nbsp;&nbsp;<br />CString.format(&quot;%s&quot;, string.c_str());&nbsp;&nbsp;&nbsp;<br />&nbsp;<br />2，char -&gt; string &nbsp;&nbsp;<br />string s(char *);&nbsp;&nbsp;&nbsp;<br /><br />3,CString -&gt; string &nbsp;&nbsp;<br />string s(CString.GetBuffer());&nbsp;&nbsp;&nbsp;<br />GetBuffer()后一定要ReleaseBuffer(),否则就没有释放缓冲区所占的空间.</p> <p><br /></p>  【编程开发】C++类构造初始化列表 1452740694935 Text 1dad75de_9a0fc34 【编程开发】 <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cnblogs.com/BlueTzar/articles/1223169.html\" >C++类构造函数初始化列表</a></p> <p>构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。例如：<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif\" style=\"max-width:500px;\" />class CExample {<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />public:<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;int a;<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;float b;<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;//构造函数初始化列表<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp; CExample(): a(0),b(8.8)<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;{}<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;//构造函数内部赋值<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp; CExample()<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;{<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=0;<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b=8.8;<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockEnd.gif\" style=\"max-width:500px;\" />};上面的例子中两个构造函数的结果是一样的。上面的构造函数（使用初始化列表的构造函数）显式的初始化类的成员；而没使用初始化列表的构造函数是对类的成员赋值，并没有进行显式的初始化。初始化和赋值对内置类型的成员没有什么大的区别，像上面的任一个构造函数都可以。对非内置类型成员变量，为了避免两次构造，推荐使用类构造函数初始化列表。但有的时候必须用带有初始化列表的构造函数：<br />1.成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。<br />2.const成员或引用类型的成员。因为const对象或引用类型只能初始化，不能对他们赋值。&nbsp;<br /><br />初始化数据成员与对数据成员赋值的含义是什么？有什么区别？<br />首先把数据成员按类型分类并分情况说明:<br />1.内置数据类型，复合类型（指针，引用）<br />&nbsp;&nbsp;&nbsp;&nbsp;在成员初始化列表和构造函数体内进行，在性能和结果上都是一样的<br />2.用户定义类型（类类型）<br />&nbsp;&nbsp;&nbsp;&nbsp;结果上相同，但是性能上存在很大的差别。因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）<br /><br />Note:<br />初始化列表的成员初始化顺序:<br />&nbsp;&nbsp;&nbsp; C++初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。<br />&nbsp;&nbsp;&nbsp; Example:<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif\" style=\"max-width:500px;\" />class CMyClass {<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp; CMyClass(int x,&nbsp;int y);<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;int m_x;<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/InBlock.gif\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;int m_y;<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockEnd.gif\" style=\"max-width:500px;\" />};<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/None.gif\" style=\"max-width:500px;\" /><br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/None.gif\" style=\"max-width:500px;\" />CMyClass::CMyClass(int x,&nbsp;int y)&nbsp;: m_y(y), m_x(m_y)<br /><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockStart.gif\" style=\"max-width:500px;\" />{<br /></p> <p><img src=\"http://www.cnblogs.com/Images/OutliningIndicators/ExpandedBlockEnd.gif\" style=\"max-width:500px;\" />}</p> <p>你可能以为上面的代码将会首先做m_y=I，然后做m_x=m_y，最后它们有相同的值。但是编译器先初始化m_x，然后是m_y,，因为它们是按这样的顺序声明的。结果是m_x将有一个不可预测的值。有两种方法避免它，一个是总是按照你希望它们被初始化的顺序声明成员，第二个是，如果你决定使用初始化列表，总是按照它们声明的顺序罗列这些成员。这将有助于消除混淆。</p> <p><br /></p>  【编程开发】终止线程的几种方法 1452740505957 Text 1dad75de_9a0fc25 【编程开发】 <p><strong>退出线程可以有四种方法:</strong></p> <p><strong>1.线程函数的return返回(最好这样):<br /></strong>其中用线程函数的return返回,&nbsp;而终止线程是最安全的,&nbsp;在线程函数return返回后,&nbsp;会清理函数内申请的类对象,&nbsp;即调用这些对象的析构函数.&nbsp;然后会自动调用 _endthreadex()函数来清理 _beginthreadex(...)函数申请的资源(主要是创建的tiddata对象).</p> <p><strong>2.调用 _endthreadex()函数&nbsp;或 ExitThread()函数(最好不要):<br /></strong>如果使用这两种方法退出线程,&nbsp;则不会执行线程函数的return语句,&nbsp;所以就不会调用线程函数作用域内申请的类对象的析构函数,&nbsp;会造成内存泄露.</p> <p><strong>剩下两种是在程序设计中一定要避免的.<br />3.用同一个进程中的另一个线程调用 TerminateThread()函数(必须避免);<br />4.终止该线程所在的进程(绝对避免);</strong></p> <p>但是要说_endthreadex完全没有用肯定是不对的，_endthreadex并不是一个过时的函数，正确的使用并不会带来问题。<br />比如在线程的主函数中，return是_endthreadex的一个良好替代，就像main函数里面return是exit()或ExitProccess()的良好替代一样，但是这不表示exit函数没用。比如线程调用了一个子函数，如果子函数决定退出线程，return是没用的，_endthreadex即可终结线程。<br /><br />但是这个设计不好，因为可能造成LZ提出的资源泄漏。尤其考虑到后台线程终结后的资源泄漏比主线程的资源泄漏更要命（主线程退出后，进程就退出了，OS会清理一切资源，无所谓泄露不泄露，而子线程退出后主线程可能还会运行很久，并且可能有大量的同类型的子线程退出，会造成要命的泄露）<br />良好的设计还是返回线程的主函数，让threadproc来决定是不是要退出，从这个意义上说，_endthreadex没有必要。微软也指出，有些程序员就是要调用exit系列函数（ExitThread，ExitProccess等），没辙，只好提供了。</p> <p><br /></p>  【硬件开发】电子元器件几种级别：商业，工业，军品 1452740337385 1452740355198 Text 1dad75de_9a0fc1a 【硬件开发】 <ul> <li><p>军工级、工业级和商业级</p></li> </ul> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;军工级——军用设备如导弹、卫星、坦克和航母里面的电子元器件任何一个部分拿出来都是最先进的，领先工业级10年，&nbsp;领先商业级20年左右，价格最贵，精密度最高&nbsp;<br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工业级——比军工级档次稍微低一点，价格次之，精密度次之&nbsp;<br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;商业级——市面上交易的那种，电脑、手机，你能看到的基本上都是商业级的，比如微软做的芯片就算是商业级里的军工级，价格最便宜，最常见，最实用&nbsp;<br /></p> <ul> <li><p>工作温度范围</p></li> </ul> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;商业级器件的工作温度范围是0℃~+70℃，工业级的是-40℃~+85℃，军品级的是-55℃~+150℃。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外还有些器件有一种汽车工业级的是-40℃~+125℃。</p> <p><br /></p>  【编程开发】C++控制台使用Timer定时器的方法 1452733875543 1452740381900 Text 1dad75de_99fc222 【编程开发】 <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cnblogs.com/Sniper-quay/archive/2011/04/27/2030018.html\" >C++ dll 中使用定时器的方法</a></p> <p>方法一：</p> <p>SetTimer(NULL, 0, 1000,&nbsp;(TIMERPROC)Timer2Proc);</p> <p><br /></p> <p>VOID CALLBACK Timer2Proc(&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hWnd,&nbsp;// handle of window for timer messages <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT uMsg,&nbsp;// WM_TIMER message <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT idEvent,&nbsp;// timer identifier <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwTime // current system time <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;<br />{&nbsp;<br />return;&nbsp;<br />}&nbsp;</p> <p><br /></p> <p>方法二：</p> <p><br /></p> <p>// DLL中的线程函数可以象这样使用Timer <br />UINT ThreadProc(LPVOID)&nbsp;<br />{&nbsp;<br />&nbsp;<br />SetTimer(NULL, 1, 5000, NULL);&nbsp;<br />MSG msg;&nbsp;<br />// PeekMessage 强制系统为该线程建立消息栈&nbsp;<br />PeekMessage(&amp;msg, NULL, NULL, NULL, FALSE);&nbsp;<br />while (GetMessage(&amp;msg, NULL, NULL, NULL))&nbsp;<br />{&nbsp;<br />switch (msg.message)&nbsp;<br />{&nbsp;<br />case WM_TIMER:&nbsp;<br />{&nbsp;<br />//&nbsp;这里每5秒钟执行一次&nbsp;<br />}&nbsp;<br />break;&nbsp;<br />}&nbsp;<br />//TranslateMessage(&amp;msg);&nbsp;<br />//DispatchMessage(&amp;msg);&nbsp;<br />}&nbsp;<br />KillTimer(NULL, 1);&nbsp;<br />return0;&nbsp;<br />}&nbsp;</p> <p><br /></p> <p>方法三：<br />创建一个线程,&nbsp;反复读系统时间不就可以了?&nbsp;如果定时要求不严,用Sleep就可以了</p> <p>大约每100ms 调用一次TimeProc();</p> <p>SetTimer函数和WM_TIMER消息是Win32 api中最基本的玩意儿了，任何初学Win32 api编程的人都应该对此很熟悉吧。在这篇文章中，让我们来深入了解一下和SetTimer相关的使用和应用。&nbsp;<br /><br />　　UINT_PTR SetTimer(&nbsp;<br /><br />　　HWND hWnd,&nbsp;<br /><br />　　UINT_PTR nIDEvent,&nbsp;<br /><br />　　UINT uElapse,&nbsp;<br /><br />　　TIMERPROC lpTimerFunc <br /><br />　　);&nbsp;<br /><br />　　我们经常使用的情况是hWnd不为NULL，lpTimerFunc为NULL，在这种情况下系统每隔nIDEvent毫秒会向hWnd窗口投递WM_TIMER消息。唯一需要注意的是：&nbsp;<br /><br />　　1.自2000起，uElapse范围是USER_TIMER_MINIMUM到USER_TIMER_MAXIMUM。超出得话，uElapse设置为1。&nbsp;<br /><br />　　2.WM_TIMER消息其实是在DispatchMessage函数中直接调用hWnd的窗口过程，并且优先级很低，只有在消息队列中没有其它消息的情况下，DispatchMessage才会考虑WM_TIMER。&nbsp;<br /><br />　　3.使用相同的nIDEvent可以重置这个Timer，并且KillTimer(hWnd,nIDEvent)来销毁这个Timer。&nbsp;<br /><br />　　我们再来考虑hWnd为NULL的情况：&nbsp;<br /><br />　　1.首先，最重要的是KillTimer时，传入的Timer Id必须是SetTimer的返回值，而不是调用SetTimer时传入的nIDEvent参数。&nbsp;<br /><br />　　2.调用SetTimer时，如果nIDEvent为0或者是其它没有被使用的Timer Id，则SetTimer会返回一个新的Timer Id。否则，就是重新设置这个Timer。&nbsp;<br /><br />　　3.如果有lpTimerFunc的话，则lpTimerFunc的参数nIDEvent是SetTimer返回的值，而不是你调用SetTimer时传入的值。&nbsp;<br /><br />　　最后看一下lpTimerFunc不为NULL的情况：lpTimerFunc会在DispatchMessage函数中被直接调用，而不会去调用 hWnd的窗口过程（也就是说收不到这个消息），无论hWnd是不是NULL。（这里，msdn中貌似有点问题，SetTimer的Remark部分说 lpTimerFunc会在默认窗口中被调用，而WM_TIMER中说lpTimerFunc在DispatchMessage中被调用）&nbsp;<br /><br />　　应用&nbsp;<br /><br />　　使用lpTimerFunc可以做一个延时的操作，或者把某些操作推迟到下一个消息循环，而不需要为窗口定义一个新的Timer Id。</p> <p><br /></p>  【机器学习与模式识别】Bootstraping，bagging and boosting 1452578156378 1452740410062 Text 1dad75de_9973ea8 【机器学习与模式识别】 <p>这两天在看关于boosting算法时，看到一篇不错的文章讲bootstrap, jackknife, bagging, boosting, random forest 都有介绍，以下是搜索得到的原文，没找到博客作者的地址，</p> <p>在这里致谢作者的研究。</p> <p>一并列出一些找到的介绍boosting算法的资源：</p> <p>（1）视频讲义，介绍boosting算法，主要介绍AdaBoosing&nbsp;&nbsp;&nbsp; http://videolectures.net/mlss05us_schapire_b/</p> <p>&nbsp;&nbsp;(2)&nbsp;&nbsp;&nbsp;在这个网站的资源项里列出了对于boosting算法来源介绍的几篇文章，可以下载：&nbsp;&nbsp;&nbsp; http://www.boosting.org/tutorials</p> <p>&nbsp;&nbsp;&nbsp;(3)&nbsp;&nbsp;一个博客介绍了许多视觉中常用算法，作者的实验和理解，这里附录的链接是关于使用opencv进行人脸检测的过程和代码，可以帮助理解训练过程是如何完成的：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http://www.cnblogs.com/tornadomeet/archive/2012/03/28/2420936.html</p> <p>（4）这里是一个台湾的电子期刊上关于AdaBoost的介绍:&nbsp; http://140.113.87.114/cvrc/edm/vol_6/tech1.htm</p> <p>（&nbsp;&nbsp;一&nbsp;）</p> <p>Jackknife，Bootstraping, bagging, boosting, AdaBoosting, Rand forest 和 gradient boosting</p> <p>这些术语，我经常搞混淆，现在把它们放在一起，以示区别。(部分文字来自网络，由于是之前记的笔记，忘记来源了，特此向作者抱歉）</p> <p><strong>Bootstraping:</strong>&nbsp;名字来自成语“pull up by your own bootstraps”，意思是依靠你自己的资源，称为自助法，它是一种有放回的抽样方法，它是非参数统计中一种重要的估计统计量方差进而进行区间估计的统计方法。其核心思想和基本步骤如下：<br />　　（1）&nbsp;采用重抽样技术从原始样本中抽取一定数量（自己给定）的样本，此过程允许重复抽样。&nbsp;<br />　　（2）&nbsp;根据抽出的样本计算给定的统计量T。&nbsp;<br />　　（3）&nbsp;重复上述N次（一般大于1000），得到N个统计量T。&nbsp;<br />　　（4）&nbsp;计算上述N个统计量T的样本方差，得到统计量的方差。<br />　　应该说Bootstrap是现代统计学较为流行的一种统计方法，在小样本时效果很好。通过方差的估计可以构造置信区间等，其运用范围得到进一步延伸。</p> <p><strong>Jackknife</strong>：&nbsp;和上面要介绍的Bootstrap功能类似，只是有一点细节不一样，即每次从样本中抽样时候只是去除几个样本（而不是抽样），就像小刀一样割去一部分。</p> <p>(pku， sewm，shinningmonster.)</p> <p>============================================================================================================================</p> <p>下列方法都是上述Bootstraping思想的一种应用。</p> <p><strong>bagging：</strong>bootstrap aggregating的缩写。让该学习算法训练多轮，每轮的训练集由从初始的训练集中随机取出的n个训练样本组成，某个初始训练样本在某轮训练集中可以出现多次或根本不出现，训练之后可得到一个预测函数序列h_1，⋯&nbsp;⋯h_n ，最终的预测函数H对分类问题采用投票方式，对回归问题采用简单平均方法对新示例进行判别。</p> <p>[训练R个分类器f_i，分类器之间其他相同就是参数不同。其中f_i是通过从训练集合中(N篇文档)随机取(取后放回)N次文档构成的训练集合训练得到的。对于新文档d，用这R个分类器去分类，得到的最多的那个类别作为d的最终类别。]</p> <p>&nbsp;</p> <p><strong>boosting:&nbsp;</strong>其中主要的是AdaBoost（Adaptive Boosting）。初始化时对每一个训练例赋相等的权重1／n，然后用该学算法对训练集训练t轮，每次训练后，对训练失败的训练例赋以较大的权重，也就是让学习算法在后续的学习中集中对比较难的训练例进行学习，从而得到一个预测函数序列h_1,⋯, h_m ,&nbsp;其中h_i也有一定的权重，预测效果好的预测函数权重较大，反之较小。最终的预测函数H对分类问题采用有权重的投票方式，对回归问题采用加权平均的方法对新示例进行判别。</p> <p>（类似Bagging方法，但是训练是串行进行的，第k个分类器训练时关注对前k-1分类器中错分的文档，即不是随机取，而是加大取这些文档的概率。)</p> <p>&nbsp;（pku， sewm，shinningmonster.）</p> <p>&nbsp;</p> <p><strong>Bagging与Boosting的区别：</strong>二者的主要区别是取样方式不同。Bagging采用均匀取样，而Boosting根据错误率来取样，因此Boosting的分类精度要优于Bagging。Bagging的训练集的选择是随机的，各轮训练集之间相互独立，而Boostlng的各轮训练集的选择与前面各轮的学习结果有关；Bagging的各个预测函数没有权重，而Boosting是有权重的；Bagging的各个预测函数可以并行生成，而Boosting的各个预测函数只能顺序生成。对于象神经网络这样极为耗时的学习方法。Bagging可通过并行训练节省大量时间开销。</p> <p>bagging和boosting都可以有效地提高分类的准确性。在大多数数据集中，boosting的准确性比bagging高。在有些数据集中，boosting会引起退化--- Overfit。<br />Boosting思想的一种改进型<strong>AdaBoost</strong>方法在邮件过滤、文本分类方面都有很好的性能。</p> <p>&nbsp;</p> <p><strong>gradient boosting</strong>（又叫Mart, Treenet)：Boosting是一种思想，Gradient Boosting是一种实现Boosting的方法，它主要的思想是，每一次建立模型是在之前建立模型损失函数的梯度下降方向。损失函数(loss function)描述的是模型的不靠谱程度，损失函数越大，则说明模型越容易出错。如果我们的模型能够让损失函数持续的下降，则说明我们的模型在不停的改进，而最好的方式就是让损失函数在其梯度（Gradient)的方向上下降。</p> <p><strong>Rand forest：&nbsp;</strong>随机森林，顾名思义，是用随机的方式建立一个森林，森林里面有很多的决策树组成，随机森林的每一棵决策树之间是没有关联的。在得到森林之后，当有一个新的输入样本进入的时候，就让森林中的每一棵决策树分别进行一下判断，看看这个样本应该属于哪一类（对于分类算法），然后看看哪一类被选择最多，就预测这个样本为那一类。&nbsp;在建立每一棵决策树的过程中，有两点需要注意&nbsp;-&nbsp;采样与完全分裂。首先是两个随机采样的过程，random forest对输入的数据要进行行、列的采样。对于行采样，采用有放回的方式，也就是在采样得到的样本集合中，可能有重复的样本。假设输入样本为N个，那么采样的样本也为N个。这样使得在训练的时候，每一棵树的输入样本都不是全部的样本，使得相对不容易出现over-fitting。然后进行列采样，从M个feature中，选择m个(m &lt;&lt; M)。之后就是对采样之后的数据使用完全分裂的方式建立出决策树，这样决策树的某一个叶子节点要么是无法继续分裂的，要么里面的所有样本的都是指向的同一个分类。一般很多的决策树算法都一个重要的步骤&nbsp;-&nbsp;剪枝，但是这里不这样干，由于之前的两个随机采样的过程保证了随机性，所以就算不剪枝，也不会出现over-fitting。&nbsp;按这种算法得到的随机森林中的每一棵都是很弱的，但是大家组合起来就很厉害了。可以这样比喻随机森林算法：每一棵决策树就是一个精通于某一个窄领域的专家（因为我们从M个feature中选择m让每一棵决策树进行学习），这样在随机森林中就有了很多个精通不同领域的专家，对一个新的问题（新的输入数据），可以用不同的角度去看待它，最终由各个专家，投票得到结果。</p> <p><strong>Rand forest与bagging的区别</strong>：1）. Rand forest是选与输入样本的数目相同多的次数（可能一个样本会被选取多次，同时也会造成一些样本不会被选取到），而bagging一般选取比输入样本的数目少的样本；2）. bagging是用全部特征来得到分类器，而rand forest是需要从全部特征中选取其中的一部分来训练得到分类器；&nbsp;一般Rand forest效果比bagging效果好！</p> <p>（&nbsp;&nbsp;二&nbsp;&nbsp;）原文地址：&nbsp;&nbsp;&nbsp; http://blog.sina.com.cn/s/blog_5dd2e9270100c8ko.html</p> <p> bootstrps bagging boosting这几个概念经常用到，现仔细学习了一下：</p> <p>他们都属于集成学习方法，(如：Bagging，Boosting，Stacking)，将训练的学习器集成在一起,原理来源于PAC学习模型（ProbablyApproximately CorrectK）。Kearns和Valiant指出，在PAC学习模型中，若存在一<br />个多项式级的学习算法来识别一组概念，并且识别正确率很高，那么这组概念是强可学习的；而如果学习算法识别一组概念的正确率仅比随机猜测略好，那么这组概念是弱可学习的。他们提出了弱学习算法与强学习算法的等价性问题，即是否可以将弱学习算法提升成强学习算法。如果两者等价，那么在学习概念时，只要找到一个比随机猜测略好的弱学习算法，就可以将其提升为强学习算法，而不必直接去找通常情况下很难获得的强学习算法。</p> <p><strong>bootstraps:</strong>名字来自成语“pull up by your ownbootstraps”，意思是依靠你自己的资源，它是一种有放回的抽样方法，学习中还发现有种叫jackknife的方法，它是每一次移除一个样本。</p> <p><strong>bagging:</strong>bootstrapaggregating的缩写。让该学习算法训练多轮，每轮的训练集由从初始的训练集中随机取出的n个训练倒组成，初始训练例在某轮训练集中可以出现多次或根本不出现训练之后可得到一个预测函数序列h．，⋯⋯h 最终的预测函数H对分类问题采用投票方式，对回归问题采用简单平均方法对新示例进行判别。</p> <p>–(训练R个分类器fi，分类器之间其他相同就是参数不同。其中fi是通过从训练集合中(N篇文档)随机取(取后放回)N次文档构成的训练集合训练得到的。–对于新文档d，用这R个分类器去分类，得到的最多的那个类别作为d的最终类别.)</p> <p><strong>boosting:</strong>其中主要的是AdaBoost（AdaptiveBoosting）。初始化时对每一个训练例赋相等的权重1／n，然后用该学算法对训练集训练t轮，每次训练后，对训练失败的训练例赋以较大的权重，也就是让学习算法在后续的学习中集中对比较难的训练铡进行学习，从而得到一个预测函数序列h一⋯h其中h．也有一定的权重，预测效果好的预测函数权重较大，反之较小。最终的预测函数H对分类问题采用有权重的投票方式，对回归问题采用加权平均的方法对新示例进行判别。(类似Bagging方法，但是训练是串行进行的，第k个分类器训练时关注对前k-1分类器中错分的文档，即不是随机取，而是加大取这些文档的概率).</p> <p><strong>Bagging与Boosting的区别：</strong>在于Bagging的训练集的选择是随机的，各轮训练集之间相互独立，而Boostlng的训练集的选择是独立的，各轮训练集的选择与前面各轮的学习结果有关；Bagging的各个预测函数没有权重，而Boosting是有权重的；Bagging的各个预测函数可以并行生成，而Boosting的各个预测函数只能顺序生成。对于象神经网络这样极为耗时的学习方法。Bagging可通过并行训练节省大量时间开销。　　　bagging和boosting都可以有效地提高分类的准确性。在大多数数据集中，boosting的准确性比bagging高。在有些数据集中，boosting会引起退化。---Overfit</p> <p>文本分类中使用的投票方法（Voting，也叫组合分类器）就是一种典型的集成机器学习方法。它通过组合多个弱分类器来得到一个强分类器，包括Bagging和Boosting两种方式，二者的主要区别是取样方式不同。Bagging采用均匀取样，而Boosting根据错误率来取样，因此Boosting的分类精度要优于Bagging。投票分类方法虽然分类精度较高，但训练时间较长。Boosting思想的一种改进型AdaBoost方法在邮件过滤、文本分类方面都有很好的性能。</p> <p><br /></p> <p><br /></p>  【图像处理】使用Zynq-7000 All Programmable SoC 实现图像传感器色彩校正 1452246524237 1452246572541 Text 1dad75de_98dad0b 【图像处理】,【编程开发】 <p>图像视频传感器广泛用于手机、视频监视产品、汽车以及导弹系统等各种应用。几乎所有这些应用都要求白平衡校正（也称为色彩校正），以便生成无论是在日光、白炽灯、荧光灯下还是其它光照条件下都会产生与人眼视觉相一致的图像色彩。</p> <p>对以前使用ASIC 或ASSP&nbsp;器件的众多开发人员来说，现在用赛灵思FPGA或ZynqTM-7000 All Programmable SoC这样的可编程逻辑器件来实现自动白平衡校正可能会是一个全新的挑战。首先让我们看一下运行在嵌入式处理器上的软件（如运行在Zynq-7000 All Programmable SoC 上的ARM9&nbsp;处理系统）是如何控制定制图像/&nbsp;视频处理逻辑来执行实时像素级色彩/白平衡校正的。</p> <p>要了解是如何实现这一功能，首先需要了解色彩知觉和相机校准这些基本概念。</p> <p>相机校准<br />要测量一个自身不发光或不透光的小型均匀表面物体反射光的色彩和强度，取决于三大函数：光源的光谱功率分布(I(λ))、表面材质的光谱反射特性(R(λ))、成像系统的光谱敏感性&nbsp;(S(λ))。</p> <p>检测器测量到的信号功率可表达为：<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8464-buhuo1.jpg\" style=\"max-width:500px;\" /></p> <p>要得到有彩色图像，摄影与摄像设备与人眼一样，均使用有不同光谱响应的相邻传感器。人的视觉依赖三类光敏视椎细胞来形成色彩知觉。在开发基于人类感知的色彩模型时，国家照明委员会（CIE）定义了三个色彩匹配函数：<img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8486-0002.jpg\" style=\"max-width:500px;\" />&nbsp;。这三个函数可视为三个线性光检测器的光谱敏感度曲线。三个线性光检测器可产生CIE XYZ 三色激励值Px、Py&nbsp;和Pz，这三个值也被统称为CIE&nbsp;标准观察者。</p> <p>数字图像传感器主要采用两种方法测量三色刺激值。一种方法是在固有的单色光敏二极管上加一组滤色片阵列；另一种方法是使用堆叠光敏二极管测量光子吸收深度，这个深度与波长λ&nbsp;成正比。</p> <p>但这两种方法都不能产生与人眼相似的响应。因此，不同的光检测和复制设备的色彩测量值存在差异，即在拍摄具有相同(Iλ)&nbsp;和(Rλ)&nbsp;的相同场景，图像传感器的测量值与观测者的目测值之间也存在差异。</p> <p>因此，相机校准的目的是转换和校正相机或图像传感器测得的三色刺激值，实现与CIE&nbsp;标准观察者相符的光谱响应。</p> <p>白平衡<br />您可观察自然光以及火焰、白织灯或荧光灯等不同光照条件下的任何物体发现人的视觉都会认为物体有相同的颜色。这种现象被称为“颜色适应”或者“色彩恒常性”。但是，如果相机不具备针对不同光源进行调整或自动补偿的功能，获得的色彩就会发生变化。而相机对这种情况进行校正的行为，就称为白平衡校正。</p> <p>图1 右侧的等式分别用于描述光源的光谱、场景中各种物质的反射特性以及检测器的光谱敏感度。这三者共同决定最终的色彩测量。因此即便是采用相同的检测器，测量结果还是会把物体固有的色彩与光源的光谱混合在一起。只要满足下列条件，就有可能实现白平衡，或者说将固有的反射特性R(λ)&nbsp;与光源的光谱I(λ)&nbsp;分离：</p> <p>•&nbsp;采用启发法，比如光源上的空间频率限制，或者先验性地知道物体的色彩。例如，在日光下拍摄场景时，可以预计光源的光谱特性将在整个图像上保持恒定。与此相反，如果将图像投影到白屏幕上，光源的光谱特性会随像素发生显著的变化，但场景（幕布）的反射特性保持恒定。如果光源的特性和发射特性均有显著的变化，就难以将场景中的物体和光源区分开来。</p> <p>•&nbsp;检测器的敏感度S(λ)&nbsp;和光源光谱I(λ)&nbsp;在观测的光谱范围内不会为零。观测者无法获得光源光谱范围外物体的任何反射特性信息。例如，如果场景中用单色红光源照明，蓝色物体和绿色物体都会是黑色。<br /></p> <p>&nbsp;<img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8465-buhuo2.jpg\" style=\"max-width:500px;\" /></p> <p>早期方法<br />在数字成像系统中，已知光源的相机校准问题可以表达为一个离散三维向量函数：<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8466-buhuo3.jpg\" style=\"max-width:500px;\" /></p> <p>其中F(x)&nbsp;为映射向量函数，x 为R、G、B&nbsp;主要色彩分量的离散向量（一般为8&nbsp;位、10&nbsp;位或12&nbsp;位）。根据是否要进行线性映射以及是否要独立校正色彩分量，该映射函数可按照表1分类。<br /></p> <p>&nbsp;<img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8463-biao1.jpg\" style=\"max-width:500px;\" /></p> <p>冯•&nbsp;克里斯假设<br />相机校准最简单也是最常用的方法就是依据冯•&nbsp;克里斯假设[1]。这种方法旨在将色彩转换为LMS 色域，然后每个通道仅使用三个乘法器便可进行校正。该假设假定通过单独调整三种视椎细胞反应的增益，就可以实现人视觉系统的色彩恒定性。这三种视椎细胞反应的增益取决于感知环境，即色彩历史和周边环境。两个辐射光谱f1&nbsp;和f2&nbsp;的视椎细胞反应可以通过适当选择对角适应矩阵D1和D2&nbsp;来匹配，&nbsp;即，&nbsp;使得D1•S•f1&nbsp;=D2•S•f2,。其中S&nbsp;为视椎细胞敏感度矩阵。在LMS（长中短波敏感视椎细胞反应域）中，有：<br /></p> <p>&nbsp;<img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8467-buhuo4.jpg\" style=\"max-width:500px;\" /></p> <p>这种方法的优势在于相对简单，易于实现，仅使用三个并行乘法器，并将其作为数字图像传感器或图像传感器流水线（ISP）的一部分：<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8468-buhuo5.jpg\" style=\"max-width:500px;\" /><br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8469-buhuo6.jpg\" style=\"max-width:500px;\" /></p> <p>在实际实现中，使用RGB 色域替代LMS域来调整通道增益。一种颜色（以白色为代表）通常用相等的R、G、B&nbsp;值来表示。但是，针对某种色彩调整感知视椎细胞反应或R、G、B&nbsp;值不能保证其它色彩也得到如实表达。</p> <p>分量校正<br />对任何特定的色彩分量，冯•&nbsp;克里斯假设只能表达输入和输出之间的线性关系。假设用相似的数据表达（比如每分量8 位、10&nbsp;位或12&nbsp;位），除非 k 等于1.0，否则部分输出动态范围就无法使用，或者部分输入值对应于需要剪切或钳位的值。除了使用乘法器，还可以使用小规模的基于分量的查找表来表达任何定义输入/&nbsp;输出映射的函数。这样在一个模块中就可以实现传感器/&nbsp;显示器的非线性与伽马校正。在采用FPGA&nbsp;图像处理流水线实现方案中，可以使用赛灵思伽马校正IP&nbsp;模块来完成这一运算。</p> <p>完整查找表<br />相机校准可为所有可能的相机输入三色刺激值分配预期值。我们可以将所有可能的输入RGB 值预期值存储在一个大型查找表中，但这种方案有两个弊端。第一个问题是内存大小。对10&nbsp;位的色彩分量而言，&nbsp;这个查找表将达到230&nbsp;字（4GB）的深度，30&nbsp;位的宽度。第二个问题是初始化值。一般来说，通过校正测量，只能建立数十到数百个相机输入值/&nbsp;预期输出值对。其余稀疏的查找表值必须通过内插得到。这种内插工作并不轻松，因为异构分量输入到输出函数并非是单调或平滑的。图2a&nbsp;所示即为R、G、B&nbsp;输入（行）输出（列）值的测量值与预期值对。<br /></p> <p>&nbsp;<img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8470-buhuo7.jpg\" style=\"max-width:500px;\" /></p> <p>通过对内插得到的经验结果进行视觉评估（图2b），结果表明内插法与基于伽马校正和色彩校正矩阵的解决方案相比并没有明显的质量改进。大多数图像或视频处理系统均受制于对外部存储器的访问带宽。大型查找表要求使用外部存储器；逐像素访问需要很高的带宽；而且查找表内容是静态的（难以逐帧重新编程），会限制完整查找表解决方案在嵌入式视频/&nbsp;图像处理应用中的实际使用。<br /></p> <p>&nbsp;<img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8471-buhuo8.jpg\" style=\"max-width:500px;\" /></p> <p>色彩校正矩阵<br />我们在本文中介绍的校正方法将向您演示如何采用3&times;3 矩阵乘法器进行坐标转换，旨在让测得的红、绿和蓝三种色彩分量正交化。这种方法与冯•&nbsp;克里斯方法相比的优势在于所有三个色彩通道都参与了校正过程。比如，在调整绿色通道增益时，可以结合红色通道和蓝色通道的信息。另外，这种方法还适合用同一模块同步进行相机校准和白平衡校正，并逐帧更新矩阵系数以平滑匹配不断变化的光源。</p> <p>白平衡校正使用的两种最简单的算法是灰度世界算法和白点算法。这两种方法均使用RGB&nbsp;色域。</p> <p>灰度世界算法[2]&nbsp;依据这样的启发条件，即虽然场景中的不同物体有截然不同的颜色，场景颜色的平均值（红、绿、蓝三种颜色的平均值）应该是中性的灰色。因此，一帧中R、G、B&nbsp;平均色值之差能体现出光源的颜色信息。校正的作用是进行色彩转换后使得到的平均色值完全相同。灰度世界算法相对容易实现。但是如果场景中出现大型运动物体，这种方法就会产生严重误差，导致原生的场景色彩掉色或变化。</p> <p>白点算法[2]&nbsp;依据这样的假设，即图像中颜色最浅的像素必定是白色或浅灰色。红色、绿色和蓝色通道最大值之间的差值提供的是与光源颜色有关的信息，校正的作用是进行色彩转换后让得到的颜色最大值完全相等。但是，要找出白点，就需要按亮度值对像素排序。另外可能还需要对排序后的列表进行时空滤波，抑制噪声伪影，最后将排序结果汇聚成唯一的白色三元色。使用白点法的优势是易于实现，缺陷则是会造成巨大的误差，可能导致原生场景的色彩掉色。另外这种方法的效果还容易被饱和像素削弱。</p> <p>更加先进的方法发挥色域转换的优势。这样色度可以轻易地与色彩饱和度和亮度隔离，将三维色彩校正问题降低为一维问题。</p> <p>例如，先进行色彩饱和度映射，在YCC、YUV、L*a*b*&nbsp;或LuV&nbsp;色域中建立二维直方图，然后围绕直方图底部周边建立一个凸壳。计算出UV&nbsp;或（Cr，Cb）均值，用于校正色彩，让得到的色彩UV&nbsp;或CbCr&nbsp;直方图位于YUV、YCC、Luv&nbsp;或Lab&nbsp;域中的中性点或灰度点上。这些方法的优势在于能够得到更好的色彩表象，而缺陷则在于需要浮点算法才能实现。</p> <p>所有上述的方法有一个共同的缺陷，就是如果曝光设置不当或者场景光照存在极度的动态范围，就会产生伪影。例如使用带原生色调的高亮光源照明，在图像中产生的饱和像素。典型如火焰位于焦点上的烛光照片，此时会导致完全饱和，图像上出现白色像素。</p> <p>其它改善白平衡结果的方法<br />还有一种色彩校正方法就是将前景和背景分离。数码相机采用的自动对焦与矩阵测光相结合的方法，可以把镜头中心焦点周边的像素与靠近边缘的背景像素在空间上区分开来。这种方法假定拍摄的物体只有几种主要颜色，而且位于图像中心的焦点上。远处的物体靠近边缘，由灰度世界假设主导。</p> <p>另一种方法围绕形状检测。面部或皮肤颜色检测有助于相机识别有预期色调的图像内容。这样只需要对有已知和预期的色调的像素进行白平衡校正。颜色校正就是将这些像素的颜色调整为贴近预期颜色。这种方法的不足之处就是分割和识别逻辑的成本不菲。</p> <p>大多数商业应用采用适应图像内容和拍摄环境的策略，综合应用多种方法。[2]</p> <p>用于相机校准和色彩校正的ISP<br />我们的实现方案采用如图3 所示的典型图像传感器流水线技术。我们采用赛灵思基于可配置逻辑的图像处理内核来构建ISP&nbsp;的硬件部分（见蓝色方框）。同时，我们将相机校准和白平衡算法设计为运行在其中一个嵌入式ARM&nbsp;处理器上的C&nbsp;代码（见粉红色方框）。该ARM处理器还运行嵌入式Linux，为主机PC提供用户界面。<br /></p> <p>&nbsp;<img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8472-buhuo9.jpg\" style=\"max-width:500px;\" /></p> <p>ISP 中与白平衡和相机校准有关的部分是一个反馈环路，包括：<br />•&nbsp;图像统计模块，用于逐帧采集各域的统计数据；<br />•&nbsp;嵌入式驱动程序和应用软件，用于逐帧分析统计信息并对色彩校正模块编程；<br />•&nbsp;色彩校正模块，用于逐像素地执行色彩转换。</p> <p>我们将该ISP 实现为Zynq&nbsp;视频和成像套件（ZVIK）1080&times;60&nbsp;相机图像处理参考设计的组成部分。</p> <p>算法详解<br />为校准传感器的颜色，我们使用现成的颜色观察箱（X-Rite Macbeth Judge II）或灯箱。该设备有四个已知光的标准光源，分别用于模拟日光、冷白荧光灯、暖光荧光灯和白炽灯。我们还使用现成的色靶（X-Rite ColorChecker 24色标准色卡），其色标具有已知的反射特性以及RGB 与sRGB&nbsp;预期值。</p> <p>在开始实现相机校准算法之前，我们首先将色靶放置在灯箱中，与灯箱的灰黑色背景平行。我们将色靶调整到一定位置，让来自所有光源的光照尽量均匀。</p> <p>接下来，在打开所有光源的情况下，我们采集由传感器拍摄的有待校准的图像，此时尚未进行色彩校正（使用“跳过”色彩校正设置：将单位矩阵加载至色彩校正矩阵）。</p> <p>然后使用赛灵思提供的MATLAB&reg;脚本协助补偿镜筒（几何形状）透镜畸变和镜头阴影（光强度在角落处下降）带来的影响。我们使用MATLAB&nbsp;脚本找出图像上的控制点，然后弯曲图像，用以对筒形畸变进行补偿。脚本的其余部分用于根据寄存的ColorChecker&nbsp;色靶背景来估算水平和垂直方向的光强度下降。</p> <p>为衰减测量到的噪声，我们在色标中划出矩形区域。在这些区域中，我们计算出R、G、B&nbsp;像素数据均值，&nbsp;用RGB&nbsp;三元色表达每个色靶。带GUI&nbsp;的MATLAB&nbsp;脚本可帮助找出色标的中心，然后计算出与每个色标的RGB&nbsp;预期值（Re、Ge、Be）对应的平均RGB&nbsp;三元色。<br /></p> <p>&nbsp;<img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8481-tu4-zaijingtouxiaozhengqianbutongguangyuanxiadechuanganqituxiang.jpg\" style=\"max-width:500px;\" /></p> <p>我们采用模拟退火优化法找出色彩校正系数和偏移量。然后使用图3 的色彩校正模块，将未经校正的（R、G、B）三元色转换为校正的（R’、G’、B’）三元色。<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8473-buhuo10.jpg\" style=\"max-width:500px;\" /></p> <p>模拟退火算法的作用是求出一个能够返回标量的误差函数的最小值。在下面的讨论中，用Rk、Gk、Bk 表示测得的色标像素值的子集或超集。用户可以自行限制包含在优化（子集）中的色标数量，也可多次使用某个特定的色标，以增大其在优化过程中的相对权重。整数n&nbsp;代表选优化的色标数量。如果一次优化全部色标，则对X-Rite ColorChecker 24 色标准色卡而言，n&nbsp;则为24。</p> <p>因为优化算法最多只能设置12&nbsp;个变量（CCM&nbsp;系数和偏移量），一般来说不存在有能够将所有测量值精确映射到预期色标值的解决方案。不过该算法的目的是求出误差函数的最小值，从而在所使用的所有色标上实现理想的误差分布。</p> <p>我们设置的误差函数用于计算下列参数之一：<br />• RGB 色域中预期三元色和转换后三元色之间的方差和：<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8474-buhuo11.jpg\" style=\"max-width:500px;\" /></p> <p>• RGB 色域中预期三元色和转换后三元色之间的绝对差和：<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8475-buhuo12.jpg\" style=\"max-width:500px;\" /></p> <p>• YUV 色域中预期三元色和转换后三元色之间的方差和：<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8476-buhuo13.jpg\" style=\"max-width:500px;\" /></p> <p>• YUV 色域中预期三元色和转换后三元色之间的绝对差和：<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8477-buhuo14.jpg\" style=\"max-width:500px;\" /></p> <p>其中U’和V’对应的是R’G’B’值转换到YUV 色域的值。与此类似，误差函数也可设置用于L*u*v*&nbsp;或是 L*a*b*色域。用户可将任何上述误差函数用于仿真退火求最小值。</p> <p>白平衡<br />使用上面介绍的相机校准方法，我们建立了4 个色彩校正系数和偏移量（CCMk, k={1,2,3,4}）。如果能够正确地识别光源，这4 个系数和偏移量就可实现理想的色彩表达。采用运行在嵌入式处理器上的软件实现的白平衡算法需要逐帧完成下列运算。首先根据统计信息估算光源权重（Wk）。权重经低通滤波后，用于补偿场景突变，得到光源概率（pk）。根据权重pk，使用CCMk&nbsp;值对色彩校正矩阵模块进行编程。<br /></p> <p>&nbsp;<img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8482-tu5-butongguangyuanxiadesecaixiaozhengjingtouxiaozhuntuxiang.jpg\" style=\"max-width:500px;\" /></p> <p>这种方法的优势在于，即便场景色彩和光源色彩没有适当分离，&nbsp;校准CCMk 值的线性组合也能限制色彩伪影形成。比如在水下摄影时会面临严重的蓝色调，如果采用灰度世界法等简单的白平衡算法，在补偿时会去除所有的蓝色，导致场景的原生色彩严重失真。</p> <p>对灯箱中不同场景设置下的所有光源k={1,2,3,4}，我们通过根据色度对像素值进行分档并根据亮度值对每个像素加权，还得到二维的场景YUV&nbsp;直方图（亮度加权色度直方图）。这种方法可以去掉黑色像素，或者那些R、G、B&nbsp;值存在少量差异就会在色度域中形成巨大噪声的像素。</p> <p>我们使用掩码，去除可能造成典型光源照明条件下中性（灰色或白色）物体不可能产生的鲜艳颜色对应的直方图分档（图6）。典型的掩码包含的是仅围绕中性（白色）点周围的非零值，这里是大多数光源所处的位置。我们将有掩码的二维直方图值Hk（x，y）&nbsp;和CCMk&nbsp;值硬件编码到运行在嵌入式处理器上的白平衡应用中。<br /></p> <p>&nbsp;<img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8483-tu6-cieseyuzhongbutongwenduxiadeguangyuan.jpg\" style=\"max-width:500px;\" /></p> <p>在实时运算过程中，白平衡应用负责采集相似的二维亮度加权色度直方图。然后给测得的二维直方图加掩码。最后<br />计算四个存储的直方图和测得的直方图之间的绝对差和或方差和：<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8478-buhuo15.jpg\" style=\"max-width:500px;\" /></p> <p>其中Hk（X，Y）&nbsp;是与已知光源{k=1,2,3,4}&nbsp;有关的预先计算出的基准二维直方图，H（x，y）是实时测量的直方图。</p> <p>根据测量的直方图偏差Dk，用下式计算标准化相似值：<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8479-buhuo16.jpg\" style=\"max-width:500px;\" /></p> <p>为避免逐帧色调陡变，我们将标准化相似值按时间进行平滑处理。我们采用简单的低通IIR 滤波器，实现方法为：<br />&lt;img src=&quot;http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8485-buhuo.jpg&quot; alt=&quot;&quot;&nbsp;</p> <p>其中0&lt;c&lt;1，用于控制iir 滤波器的脉冲响应。c=&quot;&quot;&nbsp;值越小，转换就越平滑。c=&quot;&quot;&nbsp;值越大，滤波器对光照条件变化做出响应的速度就越快。</p> <p>最后，我们将预先计算出的色彩校正系数和偏移量（CCMk）线性合并，完成ISP&nbsp;的色彩校正模块的编程（图3）：<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8480-buhuo17.jpg\" style=\"max-width:500px;\" /></p> <p>图7是自然光和荧光灯照明条件下，场景采用实时白平衡算法实现的结果，可以看出感知的图像质量和色彩表达的明显改善。<br /><img src=\"http://xilinx.eetrend.com/files-eetrend-xilinx/article/201306/4180-8484-tu7-buhuodaodeweixiaozhengdechangjingzuotuhejingbaipinghengxiaozhengguodechangjingyoutu.jpg\" style=\"max-width:500px;\" /></p> <p>Zynq 视频与成像套件，加上赛灵思提供的MATLAB&nbsp;脚本，为我们提供的算法提供了补充和实现范例。</p> <p>随着工业、消费和汽车视频应用分辨率和帧率的提高，实时色彩平衡算法的难度正在不断增大。我们在本文介绍的算法阐述了如何使用运行在嵌入式处理器（诸如Zynq&nbsp;处理平台采用的ARM9核）上的软件，控制执行像素级色彩校正的定制图像和视频处理算法。</p> <p>参考资料：<br />1. H.Y.Chong，S.J.Gortler 和T.Zickler，《冯•&nbsp;克里斯假设和色彩恒定的基础》，IEEE&nbsp;计算机视觉国际大会会议纪要，2007&nbsp;年。</p> <p>2. S. Bianco，F.Gasparini 和R.Schettini，《白平衡综合策略》，2007&nbsp;年国际光学工程学会（SPIE）纪要，第39&nbsp;卷，65020D-65020D-9&nbsp;页。</p> <p>------------------------------------</p> <p>转载自http://xilinx.eetrend.com/article/4180</p>  【编程开发】利用windriver开发PCI卡驱动程序 1451964500401 Text 1dad75de_9837fe2 【编程开发】 <p>利用windriver开发PCI卡驱动程序</p> <p>一、开发环境的建立<br />&nbsp;&nbsp;&nbsp; 1)需要安装以下软件：<br />&nbsp;&nbsp;&nbsp; Visual C＋＋→Windows XP DDK→Windriver。<br />&nbsp;&nbsp;&nbsp; 2)安装PCI卡：<br />&nbsp;&nbsp;&nbsp;&nbsp;关闭计算机，在双手释放完静电（或佩戴防静电手套）的情况下，插装开发板到任何一个PCI的插槽内并固紧；<br />&nbsp;&nbsp;&nbsp; 3)PLX公司也提供了SDK软件（可以到<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.plxtech.com/products/sdk/\" >http://www.plxtech.com/products/sdk/</a>下下载）<br />&nbsp;&nbsp;&nbsp; 4)配置系统环境变量（本编译环境为windowsXP+XP_DDK)以便于后续编译，添加DDK的环境变量。(否则编译无法通过)</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=aae9c7c60102v6m5&amp;url=http://s4.sinaimg.cn/orignal/4b024d32313819ffb68f3\" ><img src=\"http://s4.sinaimg.cn/orignal/4b024d32313819ffb68f3\" style=\"max-width:500px;\" /></a><br />二、编译过程（以下为我自己编译的PCIe卡为例）<br />&nbsp;&nbsp;&nbsp;&nbsp;以下介绍windriver编译驱动程序的过程：（注：编译过程在破解版windriver7.00下编译成功，试用版windriver8.01失败！）<br />&nbsp;&nbsp;&nbsp; 1)正确插装开发板后，运行windriver后，在可列出的硬件设备列表中找到开发板：DeviceID 86e1</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=aae9c7c60102v6m5&amp;url=http://s16.sinaimg.cn/orignal/4b024d320443a9df01cdf\" ><img src=\"http://s16.sinaimg.cn/orignal/4b024d320443a9df01cdf\" style=\"max-width:500px;\" /></a><br />&nbsp;&nbsp;&nbsp; 2)windriver检测到了开发板的I/O和Memory的地址映射信息</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=aae9c7c60102v6m5&amp;url=http://s12.sinaimg.cn/orignal/4b024d3262843834fbfbb\" ><img src=\"http://s12.sinaimg.cn/orignal/4b024d3262843834fbfbb\" style=\"max-width:500px;\" /></a><br />&nbsp;&nbsp;&nbsp; 3)选择编译驱动的软件平台</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=aae9c7c60102v6m5&amp;url=http://s8.sinaimg.cn/orignal/4b024d32ff7884ab37117\" ><img src=\"http://s8.sinaimg.cn/orignal/4b024d32ff7884ab37117\" style=\"max-width:500px;\" /></a><br />&nbsp;&nbsp;&nbsp; 4)选择windriver的编译模式（需要选择Kernal Plugin选项来生成核心模式下的驱动程序）</p> <p><br />&nbsp;&nbsp;&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=aae9c7c60102v6m5&amp;url=http://s9.sinaimg.cn/orignal/4b024d327933e2166a7b8\" ><img src=\"http://s9.sinaimg.cn/orignal/4b024d327933e2166a7b8\" style=\"max-width:500px;\" /></a></p> <p>&nbsp;&nbsp;&nbsp; 5)windriver会生成一个编译的工程文件，如pex8311.wdp。最后windriver会调用VC来编译驱动程序文件。生成的工程有两个：KP_PEX83（核心模式驱动程序）和pex8311_diag（驱动程序测试控制台工程）。<br />&nbsp;&nbsp;&nbsp;&nbsp;成功编译后在C:WinDriverwizardmy_projectskermodeobjfre_winxpi386目录下可以找到KP_PEX83.sys，这就是windriver为开发板自动生成的驱动程序。<br />&nbsp;&nbsp;&nbsp; 6)创建INF文件，按向导，填写相应信息后会在C:WinDriver下生成INF文件如：pex8311.inf。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=aae9c7c60102v6m5&amp;url=http://s13.sinaimg.cn/orignal/4b024d321811cce74c81c\" ><img src=\"http://s13.sinaimg.cn/orignal/4b024d321811cce74c81c\" style=\"max-width:500px;\" /></a><br />&nbsp;&nbsp;&nbsp;&nbsp;新建一个文件夹PEX8311，把inf和sys文件拷贝过来并更名为pex8311.inf和pex8311.sys。Windriver生成的inf文件中很多是jungo公司的信息，需要逐一修改为公司的信息。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;修改后的pex8311.sys文件如下：<br />; Generated by Shanghai 3F Electronics Co., Ltd.&nbsp;-&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.3fmedical.com/\" >http://www.3fmedical.com</a>&nbsp;&nbsp;&nbsp;*<br />; Installation file (.inf) for &quot;Ultrasound PCIe Interface Board&quot; device<br />; Copyright (c) 2006 Shanghai 3F Electronics Co., Ltd<br />; ver0.1&nbsp; 2006/09/28</p> <p>; Version Information<br />;&nbsp;-------------------<br />[Version]<br />Signature=&quot;$CHICAGO$&quot;&nbsp;&nbsp;; Represents all Windows OSs<br />Provider=%3F%<br />; You may modify the driver version:<br />DriverVer=09/27/2006, 7.0.0</p> <p>Class=Interface Board<br />ClassGuid={c671678c-82c1-43f3-d700-0049433e9a4b}</p> <p>; Driver Information<br />;&nbsp;------------------<br />[Manufacturer]<br />%Mfg%=DeviceList</p> <p>[DeviceList]<br />&quot; Ultrasound PCIe Interface Board &quot;&nbsp;= Install ,&nbsp; PCI VEN_10B5 &amp; DEV_86E1 &amp; SUBSYS _831110B5 &amp; REV_AA</p> <p>; Installation Section<br />;&nbsp;--------------------<br />[Install]&nbsp;&nbsp;; Installation script for Windows 98/Me<br />CopyFiles=FilesToCopy<br />AddReg=UpDateRegistry<br />Log_Config=Base1</p> <p>[Base1]<br />IRQConfig=3,4,5,7,9,10,11,14,15</p> <p>[Install.NT]&nbsp;&nbsp;; Installation script for Windows 2000/XP/Server 2003<br />CopyFiles=FilesToCopy<br />AddReg=UpDateRegistry<br />[FilesToCopy]<br />pex8311.sys ,,,0x40&nbsp;&nbsp;; 0x40 == COPYFLG_OVERWRITE_OLDER_ONLY</p> <p>[ClassInstall]&nbsp;&nbsp;; Register a new class in Windows 98/Me<br />AddReg=UpDateRegistry</p> <p>[ClassInstall32]&nbsp;&nbsp;; Register a new class in Windows 2000/XP/Server 2003<br />AddReg=UpDateRegistry</p> <p>[UpDateRegistry]<br />HKR,,,,3F<br />HKR,,Icon,,-5<br />HKR,,DevLoader,,*ntkern<br />HKR,,NTMPDriver,, pex8311.sys</p> <p>[ControlFlags]<br />ExcludeFromSelect =&nbsp;*&nbsp;&nbsp;; Remove all devices listed in this INF file from certain user</p> <p>[PreCopySection]<br />HKR,,NoSetupUI,,1</p> <p>; Defining WinDriver6 Service<br />;&nbsp;---------------------------<br />[Install.NT.Services]<br />Addservice=Ultrasound PCIe Interface Board, 0x00000002, Service_Info</p> <p>[Service_Info]<br />ServiceType &nbsp;&nbsp;&nbsp;= 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; SERVICE_KERNEL_DRIVER<br />StartType &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; SERVICE_DEMAND_START<br />ErrorControl &nbsp;&nbsp;= 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; SERVICE_ERROR_NORMAL<br />ServiceBinary &nbsp;=&nbsp;%10%System32Driverspex8311.sys</p> <p>; Source File Information<br />;&nbsp;-----------------------<br />[SourceDisksFiles]<br />pex8311.sys=1 &nbsp;; This indicates that the pex8311.sys file is located on</p> <p>[SourceDisksNames]<br />1=&quot;Shanghai 3F Electronics Co., Ltd Installation Disk&quot;,,&nbsp;</p> <p>[DestinationDirs]<br />DefaultDestDir=10, System32Drivers &nbsp;; The location to which the pex8311.sys</p> <p>;---------------------------------------------------------------;<br />[Strings]<br />3F=&quot;3F Electronics LTD.&quot;<br />Mfg=&quot;Shanghai 3F Electronics Co., Ltd&quot;<br />&nbsp;&nbsp;&nbsp; 7)修改完INF文件后就可以对开发板的驱动程序进行更新，更新驱动程序后，在设备管理器中可以查看到当前更新后的驱动程序工作状态。（系统会自动在C:WINDOWSinf目录下生成一个以oem为头的一个同内容文件，以便日后系统自动完成该硬件设备识别和安装）。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=aae9c7c60102v6m5&amp;url=http://s15.sinaimg.cn/orignal/4b024d328a2de6d5224de\" ><img src=\"http://s15.sinaimg.cn/orignal/4b024d328a2de6d5224de\" style=\"max-width:500px;\" /></a></p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=aae9c7c60102v6m5&amp;url=http://s6.sinaimg.cn/orignal/4b024d3209ce0d8c7d845\" ><img src=\"http://s6.sinaimg.cn/orignal/4b024d3209ce0d8c7d845\" style=\"max-width:500px;\" /></a><br />三、PLX SDK调试开发板<br />&nbsp;&nbsp;&nbsp;&nbsp;重新安装PLX SDK的驱动，重新启动计算机后即可运行PLXMon，并可使用其所有功能，其中最重要的如下图所示，为各种寄存器数值查看功能、EERPOM在线烧写功能。（在此情况下，windriver的驱动暂时失效，需要重新安装重启后有效）。同时，该SDK提供了强大的测试功能，如DMA的本地到PCI和PCI到本地的数据传输测试，以及直从/直主模式下对内存映射空间的数据传输测试。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=aae9c7c60102v6m5&amp;url=http://s9.sinaimg.cn/orignal/4b024d320ac692be32d28\" ><img src=\"http://s9.sinaimg.cn/orignal/4b024d320ac692be32d28\" style=\"max-width:500px;\" /></a></p> <p>&nbsp;&nbsp;&nbsp;利用windriver调试开发板将在其它的文章单独介绍：）</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;后记：安装windriver8.01后，编译初时命令为：ddk_make.bat amd64 free ....,这时无法正常编译,改为winxp后编译通过。ddk_make.bat批处理文件在WinDriverutil目录下，具体的批处理过程可以查看，从中看出amd64和winxp的编译开关的区别。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=aae9c7c60102v6m5&amp;url=http://s4.sinaimg.cn/orignal/4b024d327d6939470e5e3\" ><img src=\"http://s4.sinaimg.cn/orignal/4b024d327d6939470e5e3\" style=\"max-width:500px;\" /></a></p> <p><br /></p>  【图像处理】gamma矫正3 1451958170760 Text 1dad75de_9837d31 【图像处理】,【编程开发】 <p>显示器为什么要Gamma校正1.&nbsp;电视视频γ校正</p> <p>LED显示器的亮度非线性修正，常常被称为γ校正，但准确的说应当是反γ校正，因为前段视频信号经过了γ校正（1/γ），所以需要反γ校正修正回来。为了获得优质的全才显示效果，亮度修正是必不可少的，修正包括γ修正和一致性校正。</p> <p>众所周知，最初的视频显示设备全部使用CRT，但CRT显像管具有非线性的转移特性，其屏幕发出的光强和输出到阴极——栅极间的控制电压功率函数呈非线性关系，可表示为幂函数：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://files.chinaaet.com/images/2012/08/25/7846288843920.png\" ><img src=\"http://files.chinaaet.com/images/2012/08/25/7846292897878.png\" style=\"max-width:500px;\" /></a></p> <p>指数γ的典型值为2.5。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://files.chinaaet.com/images/2012/08/25/7846297119558.png\" ><img src=\"http://files.chinaaet.com/images/2012/08/25/7846302889106.png\" style=\"max-width:500px;\" /></a></p> <p>直接将视频数据送给CRT→亮度非线性失真，相对对比度太大，图像变暗。正如上图所示，CRT由于功率函数非线性的原因，将会线性失真到指数为γ的曲线（即右边红色曲线），所以在视频数据送给CRT之前，先进行1/γ校正（即左边蓝色曲线）（γ&gt;1）</p> <p>历史上，γ修正是对摄像机的视频信号进行补偿，以修正CRT电子枪功率函数的非线性特性，但现在已经广泛应用于整个系统的传输特性的处理。所以，应当从系统角度广义的对系统的非线性特性进行补偿处理，以达到满意的画面效果。</p> <p>常见电视信号NTSC、PAL的γ分别为2.2和2.8.（还有R709，用于HDTV）</p> <p>LCD，PDP，LED等平板显示，特性与CRT不同，因此在接受电视信号时，要不同的修正。为了使得LCD，PDP，LED与CRT有相似的非线性特性，常用数字方法修正→反γ校正（与电视视频处理（CRT）的γ修正成互逆关系，其实就是模拟CRT的功率函数非线性传输特性，使得数据从新被校正回来）：</p> <p>加大γ</p> <p>降低γ</p> <p>电视视频</p> <p>图像相对对比度降低，画面变淡</p> <p>图像相对对比度增加，画面变暗</p> <p>LED显示屏</p> <p>图像相对对比度增加，画面变暗</p> <p>图像相对对比度降低，画面变淡</p>2. LED点阵反γ校正 <p>计算机监视器：CRT，LCD，两者传输特性不同。</p> <p>计算机视频没有关于编码方法的统一标准，也就是说，是否有γ修正或者具体采用的γ值岁软件工具盒显卡的不同而异。</p> <p>由于LED大屏常常从显卡或接口上取得显示信号，所以为了正确的重新图像，有必要确认节目源是否已经加入了γ修正以及γ值的大小。</p> <p>LED显示屏的传输特性基本上是线性的，由于前端的视频一般是进行γ校正过的，因此要进行反γ校正叫数据修正回来，即如下公式：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://files.chinaaet.com/images/2012/08/25/7846306623144.png\" ><img src=\"http://files.chinaaet.com/images/2012/08/25/7846309438443.png\" style=\"max-width:500px;\" /></a></p> <p>典型的可以通过LUT查找表来实现数据的修正，这在FPGA利用ROM能完美实现。为了适应不同的特性和工作环境以及观看爱好，可以选择不同的&nbsp;γ值，例如2.3~2.8，制作多个LUT，做成多条曲线，由用户自行选择.</p> <p>γ值越大，画面对比度越高，高亮区域的层次感越清晰，而较暗的场面会显得较黑，层次不清楚（降低了对比度）。所以γ的值与播放视频的基调有关，如果图像反差小，宜用较小的γ，反之则用γ较大的值。因此户外用大γ，2.8~3.0，室内用小γ，如1.5。</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://files.chinaaet.com/images/2012/08/25/7846313336472.png\" ><img src=\"http://files.chinaaet.com/images/2012/08/25/7846317236778.png\" style=\"max-width:500px;\" /></a></p> <p>当然这些都是对于视频而言，因为视频加了γ校正，对于位图而言，当然就另当别论了……</p> <p>当γ增大，画面对比度提高，层次清晰的同时，将会降低对比度的级数，比如γ=2.8的时候，256级灰度只有180级别，这将会降低视频显示的能力。因此γ校正的同时，通常要提高LUT的输出位数，使得输入级数不变的情况下，可以获得更高的灰度表现能力和更多的色彩标下能力。因此，新的公式如下：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://files.chinaaet.com/images/2012/08/25/7846319738652.png\" ><img src=\"http://files.chinaaet.com/images/2012/08/25/7846322532901.png\" style=\"max-width:500px;\" /></a></p> <p>其中C(k)为校正值，C(k)≤1，k是LUT地址，m为输入级数，n为输出级数，m≤n，γ为定值。</p> <p><br /></p>  【图像处理】gamma矫正2 1451957542046 Text 1dad75de_9837cf2 【图像处理】 <p><img src=\"http://img.blog.csdn.net/20140309130955203\" style=\"max-width:500px;\" /></p> <p>图2中左图为原图，中图为gamma = 1/2.2在校正结果，原图中左半侧的灰度值较高，右半侧的灰度值较低，经过gamma = 1/2.2校正后(中图)，左侧的对比度降低(见胡须)，右侧在对比度提高(明显可以看清面容)，同时图像在的整体灰度值提高。</p> <p>右图为gamma = 2.2在校正结果，校正后，左侧的对比度提高(见胡须)，右侧在对比度降低(面容更不清楚了)，同时图像在的整体灰度值降低。</p> <p>&nbsp;</p> <p>值得一提的是，人眼是按照gamma &lt; 1的曲线对输入图像进行处理的。</p> <p>&nbsp;</p> <p>参考资料：</p> <p>[1]&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://en.wikipedia.org/wiki/Gamma_correction\" >http://en.wikipedia.org/wiki/Gamma_correction</a></p> <p>[2]&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.cambridgeincolour.com/tutorials/gamma-correction.htm\" >http://www.cambridgeincolour.com/tutorials/gamma-correction.htm</a></p> <p>[3]&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/bytefish/opencv/blob/master/misc/tan_triggs.cpp\" >https://github.com/bytefish/opencv/blob/master/misc/tan_triggs.cpp</a></p> <br /> <br /> <p>代码:</p> <p><br /></p> <ol> <li><p>#include &lt;opencv2/core/core.hpp&gt;&nbsp;&nbsp;</p></li> <li><p>#include&nbsp;&lt;opencv2/imgproc/imgproc.hpp&gt;&nbsp;&nbsp;</p></li> <li><p>#include&nbsp;&lt;opencv2/highgui/highgui.hpp&gt;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;</p></li> <li><p>#include&nbsp;&lt;iostream&gt;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;</p></li> <li><p>using&nbsp;namespace cv;&nbsp;&nbsp;</p></li> <li><p>using&nbsp;namespace std;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;</p></li> <li><p>// Normalizes a given image into a value range between 0 and 255.&nbsp;&nbsp;</p></li> <li><p>Mat norm_0_255(const Mat&amp; src)&nbsp;{&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;// Create and return normalized image:&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; Mat dst;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;switch(src.channels())&nbsp;{&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;case 1:&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cv::normalize(src, dst, 0, 255, NORM_MINMAX, CV_8UC1);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;case 3:&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cv::normalize(src, dst, 0, 255, NORM_MINMAX, CV_8UC3);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; src.copyTo(dst);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;return dst;&nbsp;&nbsp;</p></li> <li><p>}&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;</p></li> <li><p>int main(int argc,&nbsp;const&nbsp;char&nbsp;*argv[])&nbsp;{&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;// Get filename to the source image:&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc != 2)&nbsp;{&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt;&nbsp;&quot;usage:&nbsp;&quot;&nbsp;&lt;&lt; argv[0]&nbsp;&lt;&lt;&nbsp;&quot;&nbsp;&lt;image.ext&gt;&quot;&nbsp;&lt;&lt; endl;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;// Load image &amp; get skin proportions:&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//Mat image = imread(argv[1], CV_LOAD_IMAGE_GRAYSCALE);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; Mat image = imread(argv[1], CV_LOAD_IMAGE_COLOR);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;// Convert to floating point:&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; Mat X;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; image.convertTo(X, CV_32FC1);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//image.convertTo(X, CV_32F);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;// Start preprocessing:&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; Mat I;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;float gamma = 1/2.2;&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; pow(X, gamma, I);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;// Draw it on screen:&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; imshow(&quot;Original Image&quot;, image);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; imshow(&quot;Gamma correction image&quot;, norm_0_255(I));&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;//imwrite(&quot;origin.jpg&quot;, image);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; imwrite(&quot;gamma_inv2.2.jpg&quot;, norm_0_255(I));&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;// Show the images:&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp; waitKey(0);&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;// Success!&nbsp;&nbsp;</p></li> <li><p>&nbsp;&nbsp;&nbsp;&nbsp;return 0;&nbsp;&nbsp;</p></li> <li><p>}</p></li> </ol> <p><br /></p>  【图像处理】gamma校正1 1451957456650 Text 1dad75de_9837cec 【图像处理】 <p><strong>问题：什么是Gamma曲线矫正？Gamma曲线矫正是什么意思？</strong><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gamma曲线是一种特殊的色调曲线，当Gamma值等于1的时候，曲线为与坐标轴成45&deg;的直线，这个时候表示输入和输出密度相同。高于1的Gamma值将会造成输出亮化，低于1的Gamma值将会造成输出暗化。总之，我们的要求是输入和输出比率尽可能地接近于1。在显示器、扫描仪、打印机等输入、输出设备中这是一个相当常见并且比较重要的概念。在计算机系统中，由于显卡或者显示器的原因会出现实际输出的图像在亮度上有偏差，而Gamma曲线矫正就是通过一定的方法来矫正图像的这种偏差的方法。一般情况下，当用于Gamma矫正的值大于1时，图像的高光部分被压缩而暗调部分被扩展，当Gamma矫正的值小于1时，图像的高光部分被扩展而暗调部分被压缩，Gamma矫正一般用于平滑的扩展暗调的细节。</p> <p><img src=\"http://www.shenmeshi.com/Science/UploadFiles_8975/200707/20070702180639504.jpg\" style=\"max-width:500px;\" />图1 CRT显示器的亮度响应曲线图</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图1显示的是一般CRT显示器的亮度响应曲线，可以看到其输入电压提高一倍，亮度输出并不是提高一倍，而是接近于两倍，显然这样输出的图像同原来的图像相比就发生了输出亮化的现象，也就是说未经过Gamma矫正的CRT显示器其Gamma值是小于1的。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有经过Gamma矫正的设备会影响最终输出图像的颜色亮度，比如一种颜色由红色和绿色组成，红色的亮度为50%，绿色的亮度为25%，如果一个未经过Gamma矫正的CRT显示器的Gamma值是2.5，那么输出结果的亮度将分别为18%和3%，其亮度大大的降低了。</p> <img src=\"http://www.shenmeshi.com/Science/UploadFiles_8975/200707/20070702180639816.jpg\" style=\"max-width:500px;\" />图2 按图进行曲线补偿 <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了补偿这方面的不足，我们需要使用反效果补偿曲线来让显示器尽可能地输出同输入图像相同的图像，所以这个时候显示器的输入信号应该按照图2所示的曲线进行补偿，这样才能在显示器上得到比较理想的输出结果。</p> <p><img src=\"http://www.shenmeshi.com/Science/UploadFiles_8975/200707/20070702180639169.jpg\" style=\"max-width:500px;\" />图3 理想状态下的曲线</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般的反效果可以直接被赋予存储在帧缓存中的图像，使之Gamma曲线呈非线性，也可以通过RAMDAC进行这种反效果补偿（或者说是Gamma曲线矫正）。这样我们就可以在显示器上看到同我们输入的图像接近的图像了（如图3）。当然图3所示的曲线只是理想状态下的情况，在实际应用中我们并不可能得到如此完美的曲线，所以不同的厂商之间所竞争的就是谁能做到最接近于这个效果。</p> <p><img src=\"http://blufiles.storage.msn.com/y1py4AP6a2TPqu5DBR2zhYH5aVV5jM3aPGRK5b0Vx7GFGx0Hzx5mvT9NdkruLM2DTMNRA0KoarHyJU\" style=\"max-width:500px;\" /></p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显示器的gamma值是用于定义一个显示器的显示特性的数学方法，是决定显示器从黑色到白色的值。简单的说，当显示一个颜色从黑到白时（也就是0到1），显示器的电压也要随之变化，但这个变化不是线性的。因为显示器的物理特性决定了如果电压的变化是线性的，显示出来的亮度就不是线性的，这时，显示的亮度就会很暗。所以，为了保整显示出来的亮度是正常（线性）的，就需要对显示器的电压变化加以校正，这个值就是我们通常所说的gamma值。通常情况只有在调整HDRI图片时和在做动画渲染时会用到。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;γ校正（Gamma Correction，伽玛校正）：所&nbsp;谓伽玛校正就是对图像的伽玛曲线进行编辑，以对图像进行非线性色调编辑的方法，检出图像信号中的深色部分和浅色部分，并使两者比例增大，从而提高图像对比&nbsp;度效果。计算机绘图领域惯以此屏幕输出电压与对应亮度的转换关系曲线，称为伽玛曲线（Gamma Curve）。以传统CRT（Cathode Ray Tube）屏幕的特性而言，该曲线通常是一个乘幂函数，Y=(X+e)γ，其中，Y为亮度、X为输出电压、e为补偿系数、乘幂值（γ）为伽玛值，改变乘幂&nbsp;值（γ）的大小，就能改变CRT的伽玛曲线。典型的Gamma值是0.45，它会使CRT的影像亮度呈现线性。使用CRT的电视机等显示器屏幕，由于对于&nbsp;输入信号的发光灰度，不是线性函数，而是指数函数，因此必需校正。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在电视和图形监视器中，显像管发生的电子束及其生成的图像亮度并不是随显像管的输入电压线性变化，电子流与输入电压相比是按照指数曲线变化的，输入&nbsp;电压的指数要大于电子束的指数。这说明暗区的信号要比实际情况更暗，而亮区要比实际情况更高。所以，要重现摄像机拍摄的画面，电视和监视器必须进行伽玛补&nbsp;偿。这种伽玛校正也可以由摄像机完成。我们对整个电视系统进行伽玛补偿的目的，是使摄像机根据入射光亮度与显像管的亮度对称而产生的输出信号，所以应对图&nbsp;像信号引入一个相反的非线性失真，即与电视系统的伽玛曲线对应的摄像机伽玛曲线，它的值应为1/γ，我们称为摄像机的伽玛值。电视系统的伽玛值约为 2.2，所以电视系统的摄像机非线性补偿伽玛值为0.45。彩色显像管的伽玛值为2.8，它的图像信号校正指数应为1/2.8＝0.35，但由于显像管内&nbsp;外杂散光的影响，重现图像的对比度和饱和度均有所降低，所以现在的彩色摄像机的伽玛值仍多采用0.45。在实际应用中，我们可以根据实际情况在一定范围内&nbsp;调整伽玛值，以获得最佳效果。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天有个朋友问γ校正的用处，这里简单说一下：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伽马校正最初是由于显示器的阴极现象管（也就是物理上所说的示波管的阴极射线版）的成像扭曲引起的，为了不使画面失真所以就用先特殊算法进行校正，此之谓γ校正。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;γ校正的原理是修改显示系统的配色方案，本来显示系统输出的r g b电子枪线性的根据显存中的各个颜色值输出对应的控制电压，但是通过伽码校正可以把某个颜色值对应的输出电压调整高或调整低。达到校正显示系统色泽的目的。同时可以用软件的方法校正，就是对一副图片设定某个颜色的颜色值变换成新的颜色值的对照表，然后用新的颜色值取代原来图片中对应的颜色就行了呀。比如你先编写一个控制rgb各个分量对应关系的曲线调节器，在曲线调节器里面调整控制曲线设置原来颜色多少对应目标颜色多少，然后根据设定的关系，修改要调整色泽的图片每一个像素的颜色就可以了。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数学公式可以深刻和精确的把握一个概念，却不能表达概念的物理意义和本质含义，本贴试图摆脱数学公式的陈述和推导，用言语来解释gamma的本质含义。</p> <p>1什么是gamma？<br />对于CRT显示器，输入电压信号将在屏幕上产生亮度输出，但是显示器的亮度与输入的电压信号不成正比，存在一种失真，如果输入的是黑白图像信号，这种失真将使被显示的图像的中间调偏暗，从而使图像的整体比原始场景偏暗，如果输入的是彩色图像信号，这种失真除了使显示的图像偏暗以外，还会使显示的图像的色调发生偏移。gamma就是这种失真的度量参数。对于CRT显示器，无论什么品牌的，由于其物理原理的一致性，其gamma值几乎是一个常量，为2.5。（注意，gamma＝1.0时不存在失真），由于存在gamma失真，输入电压信号所代表的图像，在屏幕上显示时比原始图像暗。</p> <p>&nbsp;</p> <p>2 &nbsp;&nbsp; gamma概念的演化<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gamma本来是显示器的输出图像对输入信号失真的度量参数。<br />2.1 gamma概念的第一演化（系统gamma和显示器gamma）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于存在显示失真，这样的图像不能应用，所以需要校正这种失真。上文讲到，对于显示器来说，gamma值是常量，不可改变，所以校正过程就只能针对输入的图像电压信号了。这种校正就是将正常的图像电压信号向显示器失真的相反方向去调整，既然失真使图像的中间调变暗，那么在图像电压信号输入到显示器之前，先将该电压信号的中间调调亮，然后再输入到显示器，这样就可以抵消显示器的失真了。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于显示器的gamma值是常量，所以这种校正的幅度也是相对固定的，这种校正幅度的度量参数也叫gamma，这是gamma概念的第一次演化，为了区别这两种不同的概念，此处的gamma又叫做系统gamma（因为对图像电压信号的校正过程发生在电脑系统中），显示器的固有的gamma又叫做显示器gamma。</p> <p><br />2.2 gamma概念的第二次演化<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显示器gamma表示一种失真，系统gamma表示一种校正，这两者共同之处是都表示对原始信号的一种变换，所以gamma概念发展到这里，其一般性含义已经又两层含义，a表示对原始信号的一种变换， b表示这种变换的度量参数。</p> <p>2.3 gamma概念的第三次演化（文件gamma）<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然gamma的一般性含义是对原始信号的一种变换，可想而知，文件gamma也一定表示一种变换，这是一种什么样的变换呢？<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从宏观上讲，被照相机拍摄的物体的亮度是连续变化的，如果将亮度连续变化的被摄物体的图像转换成数字文件（计算机文件）时，无论用数码相机还是扫描仪，都要面临用离散的数值去近似表示连续的物理量的问题。具体来说，一个8位的二进制数字文件，如何编码才能比较精确的表示反差很大的一幅图像？<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这要从人的视觉原理说起。人的眼睛感觉到亮度增加一级的时候，光强（光的能量）将增加一倍，同样，当人的眼睛感觉到亮度减小一级的时候，光强将减少一半。就是说，人的眼睛感觉到的亮度的成比例的线性变化，是由光强的倍数变化引起的。如果将一段连续变化的亮度从暗到亮等差分成a b c d e f g 七段，那么这七段亮度对应的光强不是1 2 3 4 5 6 7，而是1 2 4 8 16 32 64。打个数学比方，人眼感觉到的亮度是等差数列，而光强的物理实在是等比数列！为何如此，因为这样可以确保人眼即适应高亮度的阳光下的景物，又能在夜晚看清星光下的猎物，这是大自然的造化。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数码相机或扫描仪的感光元件，将会把光强变成电信号，然后由模－数转换器件转换成数字信号，继而再存储为数字文件。为了便于讨论，以黑白图像为例，一个黑白图片数字文件中每个象素用一个8位二进制编码表示，8位二进制编码只有256个量级，从0到255。就是说，一幅图片，最亮的地方用255表示，最暗的地方用0表示。这里有一个问题需要我们思考一下：比最亮处（编码255）暗一级的象素的编码值是多少？<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案是128，因为人眼感觉暗一级，光强将减小一半，这样感光元件的输出电压值将减小一半，从而模－数转换器件得到的数字值也是255的一半，即128。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依此类推，比最亮的象素（编码255）暗两级的象素的编码值是64，暗三级是32，暗四级是16，暗五级是8，暗六级是4，暗七级是2，暗八级是1。于是矛盾就出现了:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一问题是，亚当斯将曝光区分为11个等级，这种8位二进制编码方法无法表示11个分区，只表示了9个分区，分别对应的二进制编码值是0－1，1－2，2－4，4－8，8－16，16－32，32－64，64－128，128－255。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更严重的是第二个问题,最亮的分区（128－255）占有8位二进制编码256个量级的一半量级资源，即占有128个量级，分别是128，129，130，……，253,254,255。而最暗的分区只占有8位二进制编码256个量级中的两个量级，分别是0和1，比最亮分区暗四级的分区只占有8位二进制编码256个量级中的8个量级，分别是8，9，……，15，16。这表明这种编码方法在最亮的分区中，表达的亮度细节非常的丰富，超过人眼的识别能力（人眼在亮处可以识别1％的亮度变化），可是在较暗的分区中，表达的亮度细节就少的可怜了，会出现马赛克！<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以需要对感光元件的输出的电压值在模－数转换时做一种变换，使得较暗的分区占有的二进制编码量级多一些，较亮的分区占有的二进制编码量级少一些，从而不至于使图像暗处出现马赛克，也使亮部占有的量级刚好满足人眼的最大识别能力。这样编码的数字文件可以较好的表示反差很大的一幅图像。文件gamma是表示这种变换的度量参数。Windows系统，WWW和sRGB规定文件gamma值为2.2。<br /></p> <p>2.4 gamma概念的第四次演化<br />&nbsp;&nbsp;&nbsp;&nbsp; a表示对原始信号的一种变换，泛指显示器gamma，系统gamma，文件gamma。<br />&nbsp;&nbsp;&nbsp;&nbsp; b表示这种变换的度量参数。<br />&nbsp;&nbsp;&nbsp;&nbsp; c 在不同的上下文环境中，会特指显示器gamma，系统gamma，文件gamma三个概念中的某个具体概念，注意领会。</p> <p>2.5&nbsp;概念总结（四种gamma）<br />2.5.1 gamma<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gamma在不同的上下文环境中，有不同的含义，一个意思是表示对原始信号的一种变换，另一个意思是表示这种变换的度量参数，还可能表示显示器gamma，系统gamma，文件gamma三个概念中的某个具体概念。<br />2.5.2 显示器gamma<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是显示器的物理属性，固定的，不变的，不可校正的。显示器gamma在不同的上下文环境中，有不同的含义，一个意思是指显示器的输出图像对输入信号的失真，另一个意思是指这种失真的具体数值。<br />2.5.3 文件gamma<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对一个给定的数码相片文件，按照相关标准规范,&nbsp;这个gamma是一个定值，所以无需对其校正。如果出于某种特殊需要，一定要改变某数码相片文件的gamma值，这种改变也不能称作“校正”，而是称作“变换”。<br />2.5.4 系统gamma<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统gamma所表示的变换，是计算机系统在读取了照片数字文件之后，在输出到显示器之前的一种变换，对于windows系统它存在于显卡中，是可调节的，可校正的。</p> <p>3 在使用计算机处理数码相片时总要提到gamma校正，这里的gamma校正过程校正什么？<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于显示器gamma和文件gamma是固定不变的，gamma校正过程是校正计算机的系统gamma！，使得显示器gamma、系统gamma、文件gamma三个变换的叠加为1.0,从而使最终显示器的图像和原始场景一样，不存在失真。<br />这就好比密码通信，文件gamma是加密过程，系统gamma和显示器gamma是文件gamma的一种反作用，是解密过程，最后看到的结果和原始信息一样。</p> <p><br /></p>  【编程开发】云台控制协议RS485总线 1451907644125 1451907748848 Text 1dad75de_9824f58 【编程开发】 <p><strong>PELCO-D:</strong><strong><br /><br /></strong><strong>　　数据格式：</strong>1位起始位、8位数据、1位停止位，无效验位。波特率：2400B/S</p> <p><strong>　　命令格式：</strong></p> <p><strong><br /></strong></p> <p>　　1.该协议中所有数值都为十六进制数</p> <p>　　2.同步字节始终为FFH</p> <p>　　3.地址码为摄像机的逻辑地址号，地址范围：00H–FFH</p> <p>　　4.指令码表示不同的动作</p> <p>　　5.数据码1、2分别表示水平、垂直方向速度（00-3FH）,FFH表示“turbo”速度</p> <p>　　6.校验码&nbsp;= MOD[（字节2 +&nbsp;字节3&nbsp;+&nbsp;字节4&nbsp;+&nbsp;字节5&nbsp;+&nbsp;字节6）/100H]</p> <p>　　以地址码0x01为例：</p> <p>　　{0xff,0x01,0x00,0x08,0x00,0xff,0x08,}//上</p> <p>　　{0xff,0x01,0x00,0x10,0x00,0xff,0x10,}//下</p> <p>　　{0xff,0x01,0x00,0x04,0xff,0x00,0x04,}//左</p> <p>　　{0xff,0x01,0x00,0x02,0xff,0x00,0x02,}//右</p> <p>　　{0xff,0x01,0x00,0x20,0x00,0x00,0x21,}//变倍短</p> <p>　　{0xff,0x01,0x00,0x40,0x00,0x00,0x41,}//变倍长</p> <p>　　{0xff,0x01,0x00,0x80,0x00,0x00,0x81,}//聚焦近</p> <p>　　{0xff,0x01,0x01,0x00,0x00,0x00,0x02,}//聚焦远</p> <p>　　{0xff,0x01,0x02,0x00,0x00,0x00,0x03,}//光圈小</p> <p>　　{0xff,0x01,0x04,0x00,0x00,0x00,0x05,}//光圈大</p> <p>　　{0xff,0x01,0x00,0x0b,0x00,0x01,0x0d,}//灯光关</p> <p>　　{0xff,0x01,0x00,0x09,0x00,0x01,0x0b,}//灯光开</p> <p>　　{0xff,0x01,0x00,0x07,0x00,0x01,0x09,}//转至预置点001</p> <p>　　{0xff,0x01,0x00,0x03,0x00,0x01,0x05,}//设置预置点001</p> <p>　　{0xff,0x01,0x00,0x05,0x00,0x01,0x07,}//删除预置点001</p> <p>　　以上对应的停命令均是:</p> <p>　　{0xff,0x01,0x00,0x00,0x00,0x00,0x01,}//停命令</p> <p><strong>PELCO-P:</strong></p> <p>　　<strong>数据格式：</strong>1位起始位、8位数据、1位停止位，无效验位。波特率：9600B/S</p> <p>　　<strong>命令格式：</strong></p> <p>　　1.该协议中所有数值都为十六进制数</p> <p>　　2.STX始终为A0H</p> <p>　　3.地址码为摄像机的逻辑地址号，地址范围：00H–1FH</p> <p>　　4.指令码表示不同的动作</p> <p>　　5.数据码1、2分别表示水平、垂直方向速度（00-3FH）,在有关预制点的操作时，数据码2表示预制点值</p> <p>　　6.ETX始终为AFH</p> <p>　　7.校验码(XOR sum of Bytes 2-6)&nbsp;=&nbsp;字节2 ^&nbsp;字节3&nbsp;^&nbsp;字节4&nbsp;^&nbsp;字节5&nbsp;^&nbsp;字节6</p> <p>　　以地址码0x01为例：</p> <p>　　{0xa0,0x01,0x00,0x08,0x00,0x30,0xaf,0x39,}//上</p> <p>　　{0xa0,0x01,0x00,0x10,0x00,0x30,0xaf,0x21,}//下</p> <p>　　{0xa0,0x01,0x00,0x04,0x10,0x00,0xaf,0x15,}//左</p> <p>　　{0xa0,0x01,0x00,0x02,0x10,0x00,0xaf,0x13,}//右</p> <p>　　{0xa0,0x01,0x00,0x40,0x00,0x00,0xaf,0x41,}//变倍短</p> <p>　　{0xa0,0x01,0x00,0x20,0x00,0x00,0xaf,0x21,}//变倍长</p> <p>　　{0xa0,0x01,0x02,0x00,0x00,0x00,0xaf,0x03,}//聚焦近</p> <p>　　{0xa0,0x01,0x01,0x00,0x00,0x00,0xaf,0x00,}//聚焦远</p> <p>　　{0xa0,0x01,0x08,0x00,0x00,0x00,0xaf,0x09,}//光圈小</p> <p>　　{0xa0,0x01,0x04,0x00,0x00,0x00,0xaf,0x05,}//光圈大</p> <p>　　无命令字发送//灯光关</p> <p>　　无命令字发送//灯光开</p> <p>　　{0xa0,0x01,0x00,0x96,0x00,0x20,0xaf,0xb7,}//自动巡航</p> <p>　　{0xa0,0x01,0x00,0x99,0x00,0x20,0xaf,0xb8,}//关闭自动巡航</p> <p>　　{0xa0,0x01,0x00,0x07,0x00,0x01,0xaf,0x07,}//转至预置点001</p> <p>　　{0xa0,0x01,0x00,0x03,0x00,0x01,0xaf,0x03,}//设置预置点001</p> <p>　　{0xa0,0x01,0x00,0x05,0x00,0x01,0xaf,0x01,}//删除预置点001</p> <p>　　以上对应的停命令均是（上下左右、变倍、聚焦、光圈均有停命令）:</p> <p>　　{0xa0,0x01,0x00,0x00,0x00,0x00,0xaf,0x01,}</p> <p><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;</p> <p><strong>PELCO</strong><strong>（派尔高）协议解析及下载</strong></p> <p><br /></p> <p>在IBMS接口开发中，我们需要用到一些常用的协议，而PELCO (派尔高)的监控器材在我国有很广泛的应用。 PELCO有自己的传输控制协议，当它的产品配套使用时，可以互相兼容。但在某些情况下，由于工程的需要，要求用其它设备(比如电脑)来控制PELCO的矩阵或镜头，这就要求充分了解PELCO的传输协议。&nbsp;<br />&nbsp;&nbsp;&nbsp; PELCO常用的两种协议：PELCO-D协议和PELCO-P协议。<br />- PELCO-D协议解析<br />&nbsp;&nbsp;&nbsp; PELCO-D协议一般用于矩阵和其它设备之间的通信。它的格式如下：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;所有的值都是用的 16进制表示。&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;同步字通常都是&nbsp;$FF。<br />&nbsp;&nbsp;&nbsp;&nbsp;地址码是指与矩阵通信的那台设备的逻辑地址，可以在设备中设置。<br />&nbsp;&nbsp;&nbsp;&nbsp;命令字 1和命令字2设置如下：</p> <p>&nbsp;&nbsp;&nbsp; Sence码与Bit4和Bit3有关。在Bit4和Bit3为1的情况下，如果Sence码为1，则命令就是自动扫描和和摄像机打开；如果Sence码为0，则命令就是手动扫描和摄像机关闭。当然如果Bit4或Bit3为0的话那命令就无效了。<br />&nbsp;&nbsp;&nbsp;&nbsp;数据1表示镜头左右平移的速度，数值从$00(停止)到$3F(高速)，另外还有一个值是$FF，表示最高速。<br />&nbsp;&nbsp;&nbsp;&nbsp;数据2表示镜头上下移动的速度，数值从$00(停止)到$3F(最高速)。<br />&nbsp;&nbsp;&nbsp;&nbsp;校验码是指Byte2到Byte6这5个数的和(若超过255则除以256然后取余数)。<br />- PELCO-P协议解析<br />&nbsp;&nbsp;&nbsp; PELCO-P协议一般采用RS-485传输，波特率为4800，1位起始位和停止位，8位数据位，无校验。其格式如下：</p> <p>&nbsp;&nbsp;&nbsp;起始码是固定值$A0。<br />&nbsp;&nbsp;&nbsp;&nbsp;地址码是设备的逻辑地址，可由接收设备上的DIP开关来设定。<br />&nbsp;&nbsp;&nbsp;&nbsp;数据位1到4的意义如下：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;停止码是固定值&nbsp;$AF 。<br />&nbsp;&nbsp;&nbsp;&nbsp;校验码是 Byte2 到 Byte6 这 5 个数的异或值(XOR)。<br />&nbsp;&nbsp;&nbsp;&nbsp;地址码是从 0编起的，所以地址码$00表示第一台设备。<br />&nbsp;&nbsp;&nbsp; PELCO-D和PELCO-P协议另有一些特殊命令，可对设备进行一些高级控制，但这些应用并不常见，限于篇幅，这里不多作介绍，若需要可从直接下载英文资料。</p> <p>转载自<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.sina.com.cn/s/blog_7d5d42b40100r18e.html\" >http://blog.sina.com.cn/s/blog_7d5d42b40100r18e.html</a></p>  【科普杂谈】独立ISP市场定位分析-image signal processor 1451892389956 Text 1dad75de_981c85b 【科普杂谈】 <p>独立ISP市场定位分析-image signal processor</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://superhy.52rd.net/\" >superhy</a> Post at 2014-6-3 23:36:00</p> <p>&nbsp;&nbsp;&nbsp;快两年没有更新博客，这两年正好在一家做cmos image sensor的公司就职，负责影像调试，客户支持的工作。跑了大大小小的手机平板方案公司若干家。对这个市场，有了更多了解和理解。今年初，业界一个牛人做了个独立的ISP出来（创业两年），把我拉到了创业团队内，主要也是负责影像调试，客户支持的工作，项目管理也必不可少。<br />&nbsp;&nbsp;&nbsp;&nbsp;我很喜欢研究产品定位，最近也有机会看到《定位》这本书，老美几十年前就在研究产品定位，提出了这样的概念。很久没更新博客了，所以借此地，简单分析一下目前的独立ISP 市场定位。<br />&nbsp;&nbsp;&nbsp;&nbsp;目前市面上的ISP以富士通，aptina，OV，艾为，altek，为主，富士通走高大上路线，国产旗舰机若用了富士通的ISP，那必然大书特书，可参考锤子手机发布会。altek也是最近才浮出水面，华为P7的发布会，把台湾的altek带到了台前，使用了altek独立ISP的华为P7的拍照效果还没有看到。但同样使用了altek ISP的HTC one摄像头表现却不敢恭维，室内环境白平衡基本做错的情况下，还敢主打拍照功能？难道HTC做评测的工程师连这个都没有发现？aptina和OV的主业都是卖CMOS sensor，这个对于手机平板公司就有限制，用了他们的ISP，就只能支持他们的cmos sensor，这样被绑架的话，谁愿意用他们的呢？艾为是一家民营企业，推出了一款只支持到5M的ISP，算是国内企业走出的第一步，直接把独立ISP的价格杀到了1美金以下，超高的性价比，也赢得了一些市场。<br />&nbsp;&nbsp;&nbsp;&nbsp;从平台开始说ISP的定位。<br />&nbsp;&nbsp;&nbsp;&nbsp;先说低端手机市场，大多数手机平台都自带了ISP，比如高通，三星，博通大多数，MTK大多数等。2013年，最火的低端手机平台当属MTK6572，三网通吃（双3G），双核，把低端手机平台全部垄断的节奏，展讯营收直降，做展讯平台的方案公司也非死半残的样子。而就是这个MT6572平台，是没有自身集成ISP的平台，因为定位低端，所用CIS也基本是2M像素以下，而2M以下的CIS大多为YUV输出的，就不需要平台去处理raw data 。索性相安无事，后来有些方案公司，想用MT6572平台做一些中端的手机，这时就需要5M的CIS，而5M的YUV sensor少之胜少，以OV为主的OV5640和OV5645取得很大的市场份额，而众所周知的OV的技术支持，懂得人只会呵呵一下。这块市场基本属于真空带，aptina的ISP卖的比cmos sensor都贵了。给艾为的ISP留了一些空间。艾为ISP加一颗raw data的sensor，要比YUV的OV5645还要便宜，这样的价格，还有不俗的影像品质，赢得一席之地也是应该的。最近博通发布了M320和M340的4G平台，也是没有带ISP的，走运营商路线，摄像头定位最高也就5M，又给艾为ISP和低端的OV和aptina留了一些市场。高大上的富士通对此没有感觉。<br />&nbsp;&nbsp;&nbsp;&nbsp;中高端手机平台，全部都集成了ISP，对于不追求差异化设计的中端手机（2000元以内），都使用了平台集成的ISP。但是要得到原厂，如高通，MTK的支持，除非方案公司很大才能得到好的支持，一般客户基本就自己调调，要么就直接默认设置，摄像头效果基本都表现平平。这个市场，基本没ISP公司什么事。<br />&nbsp;&nbsp;&nbsp;&nbsp;高端旗舰机，如三星galaxy系列，oppo find系列，魅族MX系列，HTC one系列，华为P系列等等，基本都使用了独立的ISP，以富士通，altek，OV为主，表现出来的影像效果也都属于上等。定制化的服务，优秀的影像品质，是高端ISP必备的。价格也确实不菲，不过配以稍高的销售价格，还是可以提高手机的旗舰身份。据称高通已经把独立ISP的通道关闭了，所以以后使用高通平台的手机，可能没法使用独立ISP了。<br />&nbsp;&nbsp;&nbsp;&nbsp;平板平台，主要谈谈国内平台厂商出品的，如瑞星微，全志，炬力，盈方微等，使用这些平台的平板，定价千元左右，畅销海内外（出口量很大）。这些平台中高端系列，有些已经集成了ISP，但从客户那里了解到，都没达到客户满意的效果，所以出货基本还是以YUV的5M及以下的低端cmos sensor为主，超过5M的基本可判断为软件插值出来的。这个市场对于价格也是很敏感的，富士通基本不可能沾边，aptina和OV若能降低姿态（特别是降低价格，提升服务），也能取得不少成绩，不过目前看来，艾为的ISP在此市场有大作为。<br />&nbsp;&nbsp;&nbsp;&nbsp;最后，独立ISP的市场逐渐会更多的被平台厂商集成的ISP取代，如何生存？我认为有两条路，一条就是走高端路线，以高于平台自身ISP的影像品质，赢得高端客户的青睐，提供高端差异化的产品。这就需要长期的积累，影像的算法和调试经验，都是需要长期的磨砺，才能达到较高的水平，这一点，国内厂家还得慢慢学习成长。另一条就是走服务路线，独立ISP最大的好处就是可以支持任意一家的cmos sensor，假如拥有一个高水平的支持团队，就可以给很多客户提供最直接的服务，手机平板公司也就不用每天求原厂支持了。出一点点的资金，换得高效的支持，产品周期也会缩短。对于消费电子这么看重时间的行业，这钱花的值得。</p> <p><br /></p>  【图像处理】浅谈图像处理方向就业 1451891063317 Text 1dad75de_981c7c7 【图像处理】,【科普杂谈】 <p>最近版上有不少人在讨论图像处理的就业方向，似乎大部分都持悲观的态度。我想结合我今年找工作的经验谈谈我的看法。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;就我看来，个人觉得图像处理的就业还是不错的。首先可以把图像看成二维、三维或者更高维的信号，从这个意义上来说，图像处理是整个信号处理里面就业形势最好的，因为你不仅要掌握（一维）信号处理的基本知识，也要掌握图像处理（二维或者高维信号处理）的知识。其次，图像处理是计算机视觉和视频处理的基础，掌握好了图像处理的基本知识，就业时就可以向这些方向发展。目前的<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ailab.cn/mode/\" >模式识别</a>，大部分也都是图像<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ailab.cn/mode/\" >模式识别</a>。在实际应用场合，采集的信息很多都是图像信息，比如指纹、条码、人脸、虹膜、车辆等等。说到应用场合，千万不能忘了医学图像这一块，如果有医学图像处理的背景，去一些医疗器械公司或者医疗软件公司也是不错的选择。图像处理对编程的要求比较高，如果编程很厉害，当然就业也多了一个选择方向，并不一定要局限在图像方向。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;下面谈谈我所知道的一些公司信息，不全，仅仅是我所了解到的或者我所感兴趣的，实际远远不止这么多。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;搜索方向<br />&nbsp;&nbsp;&nbsp;&nbsp;基于内容的图像或视频搜索是很多搜索公司研究的热点。要想进入这个领域，必须有很强的编程能力，很好的图像处理和<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ailab.cn/mode/\" >模式识别</a>的背景。要求高待遇自然就不错，目前这方面的代表公司有微软、google、yahoo和百度，个个鼎鼎大名。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;医学图像方向<br />&nbsp;&nbsp;&nbsp;&nbsp;目前在医疗器械方向主要是几个大企业在竞争，来头都不小，其中包括Simens、GE、飞利浦和柯达，主要生产CT和MRI等医疗器材。由于医疗器械的主要功能是成像，必然涉及到对图像的处理，做图像处理的很有机会进入这些公司。它们在国内都设有研发中心，simens的在上海和深圳，GE和柯达都在上海，飞利浦的在沈阳。由于医疗市场是一个没有完全开发的市场，而一套医疗设备的价格是非常昂贵的，所以在这些地方的待遇都还可以，前景也看好。国内也有一些这样的企业比如深圳安科和迈瑞<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;计算机视觉和<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ailab.cn/mode/\" >模式识别</a>方向<br />我没去调研过有哪些公司在做，但肯定不少，比如<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ailab.cn/mode/fingerprint/\" >指纹识别</a>、<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ailab.cn/mode/face/\" >人脸识别</a>、虹膜识别。还有一个很大的方向是车牌识别，这个我倒是知道有一个公司高德威<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ailab.cn/rfid/\" >智能交通</a>似乎做的很不错的样子。目前视频监控是一个热点问题，做跟踪和识别的可以在这个方向找到一席之地。<br />上海法视特位于上海张江高<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ailab.cn/news/tech/\" >科技</a>园区，在视觉和识别方面做的不错。北京的我也知道两个公司：大恒和凌云，都是以图像作为研发的主体。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;视频方向<br />&nbsp;&nbsp;&nbsp;&nbsp;一般的高校或者研究所侧重在标准的制定和修改以及技术创新方面，而公司则侧重在编码解码的硬件实现方面。一般这些公司要求是熟悉或者精通MPEG、H.264或者AVS，选择了这个方向，只要做的还不错，基本就不愁饭碗。由于这不是我所感兴趣的方向，所以这方面的公司的信息我没有收集，但平常在各个bbs或者各种招聘网站经常看到。<br />我所知道的两个公司：诺基亚和pixelworks<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;其他<br />&nbsp;&nbsp;&nbsp;&nbsp;其实一般来说，只要涉及到成像或者图像的基本都要图像处理方面的人。比方说一个成像设备，在输出图像之前需要对原始图像进行增强或者去噪处理，存储时需要对图像进行压缩，成像之后需要对图像内容进行自动分析，这些内容都是图像处理的范畴。下面列举一些与图像有关或者招聘时明确说明需要图像处理方面人才的公司：<br />上海豪威集成电路有限公司（www.ovt.com.cn）<br />中芯微<br />摩托罗拉上海研究院<br />威盛（VIA）<br />松下<br />索尼<br />清华同方<br />三星<br />联影医疗（上海）2010年成立的新公司，公司好像很有钱<br /><br />所有与图像（静止或者运动图像）有关的公司都是一种选择。比如数码相机、显微镜成像、超声成像、工业<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ailab.cn/Intelligent_Robots/\" >机器人</a>控制、显示器、电视、遥感等等，都可以作为求职方向。<br /><br />要求：<br />1、外语。如果进外企，外语的重要性不言而喻。一般外企的第一轮面试都是英语口语面试。<br />2、编程。这方面尤以C＋＋为重，很多公司的笔试都是考c＋＋知识。<br />3、专业水平。如果要找专业相关的工作，研究生期间的研究经历和发表的论文就显的比较重要。<br />4、知识面的宽度。我觉得在研究生期间，除了做好自己的研究方向之外，扩宽一下知识面也有很大的帮助，当然这个知识面指的是图像处理、计算机视觉和<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.ailab.cn/mode/\" >模式识别</a>，知识面越宽，就业时的选择就会越多。<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;图像处理方向毕业的就业面非常广，而且待遇在应届生应该是中上等。其实还是一句话，能力决定一切。只要研究生三年没有白过，根本不愁找不到好工作。祝所有正在读研或者即将读研的朋友将来都能有一份满意的工作。<br /></p>  【图像处理】图像传感器CCD与CMOS的区别 1451889767777 Text 1dad75de_981c746 【图像处理】 <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/6085.htm\" >CCD</a>，英文全称：Charge-coupled Device，中文全称：<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/63129.htm\" >电荷</a>耦合元件。可以称为CCD<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/42116.htm\" >图像</a>传感器。CCD是一种半导体器件，能够把<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/47271.htm\" >光学</a>影像转化为<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/50226.htm\" >数字信号</a>。 CCD上植入的微小光敏物质称作<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/575.htm\" >像素</a>（Pixel）。一块CCD上包含的像素数越多，其提供的<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/905346.htm\" >画面</a>分辨率也就越高。CCD的作用就像胶片一样，但它是把图像像素转换成数字信号。CCD上有许多排列整齐的电容，能感应光线，并将影像转变成数字信号。经由外部电路的控制，每个小电容能将其所带的电荷转给它相邻的电容。</p> <p><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;工业相机按CCD传感器结构分为面阵CCD相机与线阵CCD相机：</p> <p>&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;面阵CCD的优点是可以获取二维图像信息，测量图像直观。缺点是像元总数多，而每行的像元数一般较线阵少，帧幅率受到限制，因此其应用面较广，如面积、形状、尺寸、位置，甚至温度等的测量。由于生产技术的制约，单个面阵CCD的面积很难达到一般工业测量对视场的需求。&nbsp;</p> <p>　　而线阵CCD的优点是一维像元数可以做得很多，而总像元数角较面阵CCD相机少，而且像元尺寸比较灵活，帧幅数高，特别适用于一维动态目标的测量。而且线阵CCD 分辨力高，价格低廉，可满足大多数测量视场的要求，但要用线阵CCD获取二维图像，必须配以扫描运动，而且为了能确定图像每一像素点在被测件上的对应位置，还必须配以光栅等器件以记录线阵CCD每一扫描行的坐标。一般看来，这两方面的要求导致用线阵CCD获取图像有以下不足：图像获取时间长，测量效率低；由于扫描运动及相应的位置反馈环节的存在，增加了系统复杂性和成本；图像精度可能受扫描运动精度的影响而降低，最终影响测量精度。&nbsp;</p> <p>　　即便如此，线阵CCD获取图像的方案在以下几方面仍有其特有的优势：线阵CCD加上扫描机构及位置反馈环节，其成本仍然大大低于同等面积、同等分辨率的面阵CCD；扫描行的坐标由光栅提供，高精度的光栅尺的示值精度可高于面阵CCD像元间距的制造精度，从这个意义上讲，线阵CCD获取的图像在扫描方向上的精度可高于面阵CCD图像；新近出现的线阵CCD&nbsp;亚像元的拼接技术可将两个CCD芯片的像元在线阵的排列长度方向上用光学的方法使之相互错位1／2个像元，相当于将第二片CCD的所有像元依次插入第一片CCD的像元间隙中，间接“减小”线阵CCD像元尺寸，提高了CCD的分辨率，缓解了由于受工艺和材料影响而很难减小CCD像元尺寸的难题，在理论上可获得比面阵CCD更高的分辨率和精度。&nbsp;</p> <p>　　因此，线阵CCD加扫描运动获取图像的方案目前仍使用广泛，尤其是在要求视场大，图像分辨率高的情况下甚至不能用面阵CCD替代。但是，仅有高的分辨率还不能保证有高的图像识别精度，特别是线阵CCD获取的图像虽然分辨率高，但由于受扫描运动精度的影响，其图像较面阵CCD图像更具特殊性。因此，图像识别时不仅要充分利用分辨率高的优势，还必须从算法上克服扫描运动的影响，使机械传动的误差不致直接影响最终的图像识别精度。</p> <p><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCD芯片按尺寸分类：</p> <p><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCD尺寸，亦即摄像机靶面。原多为1/2英寸，现在1/3英寸的已普及化，1/4英寸和1/5英寸也已商品化。</p>　　&nbsp;目前采用的芯片大多数为1/3”和1/4”。在购买摄像头时，特别是对摄像角度有比较严格要求的时候，CCD靶面的大小，CCD与镜头的配合情况将直接影响 <a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/1088626.htm\" >视场角</a>的大小和图像的清晰度。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCD的成像尺寸常用的有1/2&quot;、1/3&quot;等，成像尺寸越小的摄像机的体积可以做得更小些。在相同的 <a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/1585786.htm\" >光学镜头</a>下，成像尺寸越大，视场角越大。&nbsp; <p><br /></p>　　1英寸——靶面尺寸为&nbsp;宽12.7mm*高9.6mm ，对角线16mm。　　2/3英寸——靶面尺寸为&nbsp;宽8.8mm*高6.6mm，对角线11mm。　　1/2英寸——靶面尺寸为&nbsp;宽6.4mm*高4.8mm，对角线8mm。　　1/3英寸——靶面尺寸为&nbsp;宽4.8mm*高3.6mm，对角线6mm。　　1/4英寸——靶面尺寸为&nbsp;宽3.2mm*高2.4mm，对角线4mm。 <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【注：靶面尺寸的宽高比近似等于4∶3，而规格英寸数约为&nbsp;&quot;&nbsp;宽度*2/25.4&nbsp;&quot;&nbsp;】</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>附：</strong>135胶片规格：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;一般135胶片的片基厚度为0.135毫米。135胶卷源于35mm高度的打孔电影胶片，1913年，德国人奥斯卡&middot;巴纳克将其用于他发明的徕卡（Leica）牌小型照相机上，由此形成标准。</p> <p>&nbsp;&nbsp;&nbsp; 35mm指的是胶卷的高度为35mm，由于上下两端有齿孔，所以有效高度为24mm，这种胶片的单幅图像感光面积为<strong>24</strong>mm*<strong>36</strong>mm(对角线<strong>43</strong>.27mm)。</p> <p>&nbsp;&nbsp;&nbsp; 135胶卷前面那个1是怎么回事呢？</p> <p>&nbsp;&nbsp;&nbsp; Oscar Barnack设计的莱卡相机首先使用35mm电影胶片，但是一开始胶片必须先装进可重复使用的暗合里，把片头剪去，才可拍摄。1934年，柯达公司引入了一次性的135胶卷盒，这实际上是德国斯图加特的Nagel相机厂的发明，柯达收购了该厂。柯达于1935年正式推出135柯达彩色胶卷。所以，135的那个1是指有别于可重复使用暗盒的一次性暗盒，135胶卷的完整定义则为“采用一次性暗盒的35mm胶片”。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照度划分，CCD又分为：　　普通型&nbsp;&nbsp;正常工作所需照度1～3LUX　　月光型&nbsp;&nbsp;正常工作所需照度0.1LUX左右　　星光型&nbsp;&nbsp;正常工作所需照度0.01LUX以下　　红外型&nbsp;&nbsp;采用红外灯照明，在没有光线的情况下也可以成像.</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;【注：&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/78647.htm\" >勒克司</a>（lux，法定符号为：lx）照度单位，为距离一个<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/177006.htm\" >光强</a>为1cd的光源，在1米处所接受的照明强度。习称：烛光&middot;米。亦即距离该光源1米处，1平方米面积接受1lm <a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/78726.htm\" >光通量</a>时的照度】</p> <p>&nbsp;&nbsp; CMOS</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/356089.htm\" >CMOS</a>(Complementary Metal-Oxide-Semiconductor)，中文学名为互补金属氧化物半导体，它本是计算机系统内一种重要的芯片，保存了系统引导最基本的资料。CMOS的制造技术和一般计算机芯片没什么差别，主要是利用硅和锗这两种元素所做成的半导体，使其在CMOS上共存着带N（带-电）&nbsp;和 P（带+电）级的半导体，这两个互补效应所产生的电流即可被处理芯片纪录和解读成影像。后来发现CMOS经过加工也可以作为数码摄影中的<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/62698.htm\" >图像传感器</a>，CMOS传感器也可细分为被动式<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/575.htm\" >像素</a>传感器(Passive Pixel Sensor CMOS)与主动式像素传感器(Active Pixel Sensor CMOS)。</p> <p><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;与CCD相比，CMOS具有体积小，耗电量不到CCD的1/10，售价也比CCD便宜1/3的优点。　　与CCD产品相比，CMOS是标准工艺制程，可利用现有的半导体设备，不需额外的投资设备，且品质可随著半导体技术的提升而进步。同时，全球晶圆厂的CMOS生产线较多，日后量产时也有利于成本的降低。另外，CMOS传感器的最大优势，是它具有高度系统整合的条件。理论上，所有图像传感器所需的功能，例如垂直位移、水平位移暂存器、时序控制、CDS、ADC…等，都可放在集成在一颗晶片上，甚至于所有的晶片包括后端晶片（Back-end Chip）、快闪记忆体（Flash RAM）等也可整合成单晶片（SYSTEM-ON-CHIP），以达到降低整机生产成本的目的。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最新CMOS传感器获得广泛应用的一个前提是其所拥有的较高灵敏度、较短曝光时间和日渐缩小的像素尺寸。像素灵敏度的一个衡量尺度是填充因子(感光面积与整个像素面积之比)与量子效率(由轰击屏幕的光子所生成的电子的数量)的乘积。CCD传感器因其技术的固有特性而拥有一个很大的填充因子。而在CMOS图像传感器中，为了实现堪与CCD转换器相媲美的噪声指标和灵敏度水平，人们给CMOS图像传感器装配上了有源像素传感器(APS)，并且导致填充因子降低，原因是像素表面相当大的一部分面积被放大器晶体管所占用，留给光电二极管的可用空间较小。所以，当今CMOS传感器的一个重要的开发目标就是扩大填充因子。赛普拉斯(FillFactory)通过其获得专利授权的一项技术，可以大幅度地提高填充因子，这种技术可以把一颗标准CMOS硅芯片最大的一部分面积变为一块感光区域。　　另外，对于一个典型的工业用图象传感器而言，由于许多场景的拍摄都是在照明条件很差的情况下进行的，因此拥有较大的动态范围将是十分有益的。CMOS图像传感器通过多斜率操作实现了这一目标：转换曲线由倾度不同的直线部分所组成，它们共同形成了一个非线性特征曲线。因此，一幅场景的黑暗部分有可能占据集成模拟-数字转换器转换范围的很大一部分：转换特征曲线在这里最为陡峭，以实现高灵敏度和对比度。特征曲线上半部分的平整化将在图像的明亮部分捕获几个数量级的过度曝光，并以一个更加细致的标度来表现它们。采用多斜率的方式来运作LUPA-4000将使高达90dB的光动态范围与一个10位A/D转换范围相匹配。　　具有VGA分辨率的IM-001系列CMOS图像传感器在此基础上更进一步；它们是专为汽车应用而设计的。其像素由光电二极管组成，可提供高达120dB的自适应动态范围。面向汽车应用的ACM 100相机模块就采用了这些传感器，这种相机模块据称是同类产品中率先面市的全集成化相机解决方案：该视觉解决方案被看作是面向驾驶者保护、防撞、夜视支持和轮胎跟踪导向的未来汽车安全系统的关键元件。　　此外，对于独立于电网的便携式应用而言，以低功耗特性而著称的CMOS技术还具有一个明显的优势：CMOS图像传感器是针对5V和3.3V电源电压而设计的。而CCD芯片则需要大约12V的电源电压，因此不得不采用一个电压转换器，从而导致功耗增加。在总功耗方面，把控制和系统功能集成到CMOS传感器中将带来另一个好处：它去除了与其他半导体元件的所有外部连接线。其高功耗的驱动器如今已遭弃用，这是因为在芯片内部进行通信所消耗的能量要比通过PCB或衬底的外部实现方式低得多。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>&nbsp;&nbsp;&nbsp;&nbsp;附：CMOS主动式像素传感技术的发展史 <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aptina，这个公司名也许有人还不了解。但提到美光半导体，这可是一家鼎鼎有名的存储器公司，当然，除了存储设备，公司的图像传感器同样很出名，随着图像传感器越来越出名，2009年七月，美光将图像传感器部门分拆，也就成了现在的Aptina。</p> <p> CMOS主动式像素传感技术前世今生：</p> <p>&nbsp;谈到CMOS主动式像素传感器技术，我们必须要说一下美国喷气推进实验室(JPL)，没错，就是负责探索者计划的JPL，为了解决CCD抗辐射性能弱的问题，1992年Eric Fossum博士在JPL发明了<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.1718world.com/\" >CMOS主动式像素传感技术</a>。Fossum发现了CMOS传感器在功耗，面积及响应时间方面的优势，非常适合消费电子的应用，1995年，他成立了Photobit公司，第一次实现了CMOS图像传感器技术的商业化发展。</p> <p> Photobit的产品一经推出，就得到了业界的热捧，被用在包括罗技的QuickCam摄像头，Basler高速机器视觉解决方案，Shink的牙齿X光技术以及Gentex的自动切换灯光的镜子等等诸多应用。</p> <p> 2001年，美光收购了Photobit并于次年推出首个图像传感器产品，2006年，又收购了Avago的图像传感器部门，进一步确立了在图像传感器中的领军地位，2008年，出货量达到十亿颗的里程碑。2009年，美光将Aptina分拆，并吸引了包括Riverwood Capital和TPG的风投，自此，Aptina作为独立公司开始运营。2010年，公司收购Insilica，确保了在工艺上的领先地位。</p> <p>在最近iSuppli的一份报告中表示，Aptina市场份额排名第三，位于Sony及OmniVision之后。现在，Aptina的产品已经被用在数以百计的产品中，包括视频会议，电脑，相机，汽车，手机，游戏等多种领域。</p> <p>针对中国推出最出色的2.2微米像素传感器：</p> <p>日前，Aptina推出一款支持电子稳像(EIS)功能的新型1/3英寸原生全高清1080p30视频传感器AR0330CS。此款产品和2.2um的AR0330基本参数相同，最大的不同就是从1080p60变成了30。Aptina公司市场经理李久滔表示，“对于既要求图像质量，又对成本敏感的厂商来说，Aptina的AR0330CS在色彩表现上和AR0330一致，而1080p30也足以满足大多数的应用，包括行车记录仪，手机，数码摄像机等。”</p> <p>&nbsp;关于AR0330的性能表现，说多少也没用，大家看看Aptina自己做的Demo，一下子就可以分出个好坏。需要说明的是，AR0330采用A-Pix技术，对于红光和绿光改进了量子效率，使其对于弱光敏感度得到了很大提升。</p> <p> AR0330CS既支持5.8mm镜头，同时支持6mm镜头，对于用户来讲，无需再更换镜头模组，同时也增加了灵活性选择。现在的行车记录仪都向着高清方向发展，所以成像质量是用户最需要的考虑的，AR0330的高清传感器相比较市面上的VGA摄像头，清晰度高出几倍，另外产品同时具备电子稳像系统，会对颠簸状态的图像进行补偿，非常适合于运动用图像记录仪以及行车记录仪。</p> <p>除此之外，李久滔还介绍了Aptina的一个创新，就是同时支持并行和两路MIPI两种方案，这样可以使用户马上和DSP图像处理方案相结合而无需更换新的方案，并且支持并口的DSP处理器价格都可以接受，这样一来整体的BOM成本并不会提高。</p> <p>AR0330CS可使数码摄像机设计实现大众市场消费者期望的价格敏感点，满足人们日益增长的对高品质高清视频的需求。TCL数码科技有限公司总经理彭秀峰表示：“AR0330CS提供了极其丰富的功能、卓越的弱光性能和令人惊叹的总体视频质量。我们之所以选择AR0330CS，因为它能帮助TCL实现高性能的摄录一体机，并能够和目前市场上价位高得多的产品竞争”。</p> <p>Aptina客户对于该2.2微米像素传感器的早期反馈也非常赞许。由于AR0330CS具有的高性能，在数码摄像机成像传感器领域，Aptina能够向客户提供他们所期待的至高品质。天彩电子有限公司首席执行官邓荣芳表示:“对于高清视频应用，日光下生动鲜艳的色彩呈现需求日益迫切，而这正是我们产品可以利用的AR0330CS强大优势。”</p> <p>&nbsp;&nbsp;</p> <p><br /></p>&nbsp;&nbsp;&nbsp;CCD与CMOS的区别 <p>　&nbsp;&nbsp;&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/18579.htm\" >CCD</a>与<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/62698.htm\" >CMOS</a>传感器是被普遍采用的两种图像传感器，两者都是利用感光二极管(photodiode)进行光电转换，将图像转换为数字数据，而其主要差异是数字数据传送的方式不同。　　&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/66397.htm\" >CCD传感器</a>中每一行中每一个象素的电荷数据都会依次传送到下一个象素中，由最底端部分输出，再经由传感器边缘的放大器进行放大输出；而在CMOS传感器中，每个象素都会邻接一个放大器及A/D转换电路，用类似内存电路的方式将数据输出。　　造成这种差异的原因在于：CCD的特殊工艺可保证数据在传送时不会失真，因此各个象素的数据可汇聚至边缘再进行放大处理；而CMOS工艺的数据在传送距离较长时会产生噪声，因此，必须先放大，再整合各个象素的数据[1]。　　由于数据传送方式不同，因此CCD与CMOS传感器在效能与应用上也有诸多差异，这些差异包括：&nbsp;&nbsp; 1.&nbsp;灵敏度差异：　　由于CMOS传感器的每个象素由四个<a target=\"_blank\" rel=\"nofollow\" href=\"http://baike.baidu.com/view/30363.htm\" >晶体管</a>与一个感光二极管构成(含放大器与A/D转换电路)，使得每个象素的感光区域远小于象素本身的表面积，因此在象素尺寸相同的情况下，CMOS传感器的灵敏度要低于CCD传感器。[1]&nbsp;&nbsp; 2.&nbsp;成本差异：　　由于CMOS传感器采用一般半导体电路最常用的CMOS工艺，可以轻易地将周边电路(如AGC、CDS、Timing generator、或DSP等)集成到传感器芯片中，因此可以节省外围芯片的成本；除此之外，由于CCD采用电荷传递的方式传送数据，只要其中有一个象素不能运行，就会导致一整排的数据不能传送，因此控制CCD传感器的成品率比CMOS传感器困难许多，即使有经验的厂商也很难在产品问世的半年内突破50%的水平，因此，CCD传感器的成本会高于CMOS传感器。[1]&nbsp;&nbsp; 3.&nbsp;分辨率差异：　　CMOS传感器的每个象素都比CCD传感器复杂，其象素尺寸很难达到CCD传感器的水平，因此，当比较相同尺寸的CCD与CMOS传感器时，CCD传感器的分辨率通常会优于CMOS传感器的水平。例如，市面上CMOS传感器最高可达到210万象素的水平(OmniVision的 OV2610，2002年6月推出)，其尺寸为1/2英寸，象素尺寸为4.25μm，但Sony在2002年12月推出了ICX452，其尺寸与 OV2610相差不多(1/1.8英寸)，但分辨率却能高达513万象素，象素尺寸也只有2.78mm的水平。[1]&nbsp;&nbsp; 4.&nbsp;噪声差异：　　由于CMOS传感器的每个感光二极管都需搭配一个放大器，而放大器属于模拟电路，很难让每个放大器所得到的结果保持一致，因此与只有一个放大器放在芯片边缘的CCD传感器相比，CMOS传感器的噪声就会增加很多，影响图像品质。[1]&nbsp;&nbsp; 5.&nbsp;功耗差异：　　CMOS传感器的图像采集方式为主动式，感光二极管所产生的电荷会直接由晶体管放大输出，但CCD传感器为被动式采集，需外加电压让每个象素中的电荷移动，而此外加电压通常需要达到12~18V；因此，CCD传感器除了在电源管理电路设计上的难度更高之外(需外加 power IC)，高驱动电压更使其功耗远高于CMOS传感器的水平。举例来说，OmniVision推出的OV7640(1/4英寸、VGA)，在 30 fps的速度下运行，功耗仅为40mW；而致力于低功耗CCD传感器的Sanyo公司推出的1/7英寸、CIF等级的产品，其功耗却仍保持在90mW 以上。因此CCD发热量比CMOS大，不能长时间在阳光下工作。[1]　　综上所述，CCD传感器在灵敏度、分辨率、噪声控制等方面都优于CMOS传感器，而CMOS传感器则具有低成本、低功耗、以及高整合度的特点。不过，随着CCD与CMOS传感器技术的进步，两者的差异有逐渐缩小的态势，例如，CCD传感器一直在功耗上作改进，以应用于移动通信市场(这方面的代表业者为Sanyo)；CMOS传感器则在改善分辨率与灵敏度方面的不足，以应用于更高端的图像产品。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;目前，CCD是应用在摄影摄像方面的高端技术元件，CMOS则应用于较低影像品质的产品中，它的优点是制造成本较CCD更低，功耗也低得多，这也是市场很多采用USB接口的产品无须外接电源且价格便宜的原因。尽管在技术上有较大的不同，但CCD和CMOS两者性能差距不是很大，只是CMOS摄像头对光源的要求要高一些，但现在该问题已经基本得到解决。目前CCD元件的尺寸多为1/3英寸或者1/4英寸，在相同的分辨率下，宜选择元件尺寸较大的为好。</p> <p>*************************************************************************************************</p> <p><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;其实，CCD也有两种：全帧(full frame)的和隔行(interline)的。这两种CCD的性能区别非常大。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;总的来说，全帧的CCD性能最好。其次是隔行的CCD。CMOS的综合性能最差。</p> <p>&nbsp;&nbsp;&nbsp; full frame CCD最突出的优势是分辨率和动态范围。最弱的地方就是贵，耗电。</p> <p>&nbsp;&nbsp;&nbsp; CMOS最差的地方是分辨率，动态范围和噪声。优势就是便宜，省电。</p> <p>&nbsp;&nbsp;&nbsp; interline CCD比CMOS强的地方在于噪声。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;总的来说，两种CCD的颜色还原都比CMOS强。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;现在一般的消费级数码相机，在宣传上都不说是Full frame CCD还是Interline CCD。当然多数都是后者。专业级的数码相机，肯定是前者。所以，Full frame CCD 和Interline CCD间的区别，都存在于专业级数码相机和消费级机之间。当然，专业级数码相机彩用的大面积CCD带来的好处更突出。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;ＣＣＤ是成熟的技术，五年前或许相对ＣＭＯＳ有很大的优势，但是科学技术是进步的！CMOS绝对不只是過渡期産品！从长远看CMOS更有发展空间！</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;ＣＣＤ发展到今天已经是黔驴技穷，到了一个时期的极限，而ＣＭＯＳ技术却如日中天，不断刷新ＣＣＤ的纪录！已经全面超越了ＣＣＤ。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;像素方面：目前已经产生了高达１８００万像素的ＣＭＯＳ！远远超过了ＣＣＤ的极限。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;动态范围方面：可以说如今的ＣＭＯＳ技术拥有比ＣＣＤ更优异的动态范围，ＩＳＯ的可调范围从ISO50到ISO3200；</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;噪点控制和色彩还原方面：先进的ＣＭＯＳ拥有４个或更多的通道，色彩还原更加自然，暗光线下的错误色彩和噪音信号更少！ＣＭＯＳ噪点控制大大优与ＣＣＤ；</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;同时，ＣＭＯＳ还拥有比ＣＣＤ更省电、更耐用和更可靠的优点。</p> <p><br /></p>  默认库“library”与其他库的使用冲突；使用 /NODEFAULTLIB:library 1451871399324 Text 1dad75de_97f5d01 【编程开发】 <p>您试图与不兼容的库链接。<br /><br />重要事项&nbsp;运行时库现在包含防止混合不同类型的指令。如果试图在同一个程序中使用不同类型的运行时库<br />或使用调试和非调试版本的运行时库，则将收到此警告。例如，如果编译一个文件以使用一种运行时库，<br />而编译另一个文件以使用另一种运行时库（例如单线程运行时库对多线程运行时库），并试图链接它们，<br />则将得到此警告。应将所有源文件编译为使用同一个运行时库。有关更多信息，请参阅使用运行时库（/MD<br />、/ML、/MT、/LD）编译器选项。可以使用链接器的&nbsp;/VERBOSE:LIB 开关来确定链接器搜索的库。如果收到<br />LNK4098，并想创建使用如单线程、非调试运行时库的可执行文件，请使用&nbsp;/VERBOSE:LIB 选项确定链接<br />器搜索的库。链接器作为搜索的库输出的应是 LIBC.lib，而非 LIBCMT.lib、MSVCRT.lib、LIBCD.lib、<br />LIBCMTD.lib 和 MSVCRTD.lib。对每个要忽略的库可以使用&nbsp;/NODEFAULTLIB，以通知链接器忽略错误的运<br />行时库。<br /><br />下表显示根据要使用的运行时库应忽略的库。<br /><br />若要使用此运行时库&nbsp;请忽略这些库&nbsp;<br />单线程&nbsp;(libc.lib) libcmt.lib、msvcrt.lib、libcd.lib、libcmtd.lib、msvcrtd.lib <br />多线程&nbsp;(libcmt.lib) libc.lib、msvcrt.lib、libcd.lib、libcmtd.lib、msvcrtd.lib <br />使用 DLL 的多线程&nbsp;(msvcrt.lib) libc.lib、libcmt.lib、libcd.lib、libcmtd.lib、msvcrtd.lib <br />调试单线程&nbsp;(libcd.lib) libc.lib、libcmt.lib、msvcrt.lib、libcmtd.lib、msvcrtd.lib <br />调试多线程&nbsp;(libcmtd.lib) libc.lib、libcmt.lib、msvcrt.lib、libcd.lib、msvcrtd.lib <br />使用 DLL 的调试多线程&nbsp;(msvcrtd.lib) libc.lib、libcmt.lib、msvcrt.lib、libcd.lib、libcmtd.lib <br /><br />例如，如果收到此警告，并希望创建使用非调试、单线程版本的运行时库的可执行文件，可以将下列选项<br />与链接器一起使用：<br /><br />/NODEFAULTLIB:libcmt.lib /NODEFAULTLIB:msvcrt.lib&nbsp;/NODEFAULTLIB:libcd.lib&nbsp;<br />/NODEFAULTLIB:libcmtd.lib /NODEFAULTLIB:msvcrtd.lib</p> <p>&nbsp;</p> <p>vc2010使用libcurl静态库&nbsp;遇到连接失败的解决方案</p> <p>2010-11-10 15:35</p> <p>下载libcurl的源码，打开lib文件夹下项目，编译为静态链接库。</p> <p>在编译的时候出现问题如下：</p> <p>注：以前在vc2005下用mfc工程并且libcurl用的dll方式没问题，这次vc2008用的sdk并且libcurl用的静态编译，也不知道什么问题引起的</p> <p>HttpWebRequest.obj : error LNK2001:&nbsp;无法解析的外部符号 __imp__curl_slist_free_all<br />1&gt;HttpWebRequest.obj : error LNK2001:&nbsp;无法解析的外部符号 __imp__curl_easy_cleanup<br />1&gt;HttpWebRequest.obj : error LNK2001:&nbsp;无法解析的外部符号 __imp__curl_easy_getinfo<br />1&gt;HttpWebRequest.obj : error LNK2001:&nbsp;无法解析的外部符号 __imp__curl_easy_setopt<br />1&gt;HttpWebRequest.obj : error LNK2001:&nbsp;无法解析的外部符号 __imp__curl_slist_append<br />1&gt;HttpWebRequest.obj : error LNK2001:&nbsp;无法解析的外部符号 __imp__curl_easy_init<br />1&gt;HttpWebRequest.obj : error LNK2001:&nbsp;无法解析的外部符号 __imp__curl_global_init<br />1&gt;HttpWebRequest.obj : error LNK2001:&nbsp;无法解析的外部符号 __imp__curl_easy_perform</p> <p>上网查了好久找到了这个链接：</p> <p>http://bobobobo.wordpress.com/2008/11/08/working-with-curl-getting-started-the-easy-way-on-win32/终于解决了问题</p> <p>具体步骤就是：</p> <p>1、给工程添加依赖的库：项目-&gt;属性-&gt;链接器-&gt;输入-&gt;附加依赖项，把libcurl.lib ws2_32.lib winmm.lib wldap32.lib添加进去</p> <p>注意，debug配置用libcurld.lib</p> <p>2、加入预编译选项：项目-&gt;属性-&gt;c/c++&nbsp;-&gt;预处理器-&gt;预处理器，把&nbsp;&nbsp;;BUILDING_LIBCURL;HTTP_ONLY复制进去（注意不要丢了&quot;;&quot;）</p> <p><br /></p> <p>&nbsp;</p> <p>vc2010使用libcurl静态库&nbsp;遇到连接失败的解决方案</p> <p>2010-11-10 15:35</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>C Run-Time Library Functions for Thread Control</p> <p>2010-11-10 15:45</p> <p>All Win32 programs have at least one thread. Any thread can create additional threads. A thread can complete its work quickly and then terminate, or it can stay active for the life of the program.</p> <p>The LIBCMT and MSVCRT C run-time libraries provide two functions for thread creation and termination:<strong>_beginthread</strong> and <strong>_endthread</strong>.</p> <p>The&nbsp;<strong>_beginthread</strong> function creates a new thread and returns a thread identifier if the operation is successful. The thread terminates automatically if it completes execution, or it can terminate itself with a call to<strong>_endthread</strong>.</p> <blockquote> <strong>Warning</strong>&nbsp;&nbsp; If you are going to call C run-time routines from a program built with LIBCMT.LIB, you must start your threads with the _ <strong>beginthread</strong> function. Do not use the Win32 functions <strong>ExitThread</strong> and <strong>CreateThread</strong>. Using <strong>SuspendThread</strong> can lead to a deadlock when more than one thread is blocked waiting for the suspended thread to complete its access to a C run-time data structure. </blockquote>The _beginthread Function <p>The <a target=\"_blank\" rel=\"nofollow\" href=\"http://msdn.microsoft.com/en-us/kdzttdcb%28VS.71%29.aspx\" >_beginthread</a> function creates a new thread. A thread shares the code and data segments of a process with other threads in the process, but has its own unique register values, stack space, and current instruction address. The system gives CPU time to each thread, so that all threads in a process can execute concurrently.</p> <p>The <strong>_beginthread</strong> function is similar to the <a target=\"_blank\" rel=\"nofollow\" href=\"http://msdn.microsoft.com/en-us/cc429080.aspx\" >CreateThread</a> function in the Win32 API but has these differences:</p> <ul> <li><p>The <strong>_beginthread</strong> function lets you pass multiple arguments to the thread.</p></li> <li><p>The <strong>_beginthread</strong> function initializes certain C run-time library variables. This is important only if you use the C run-time library in your threads.</p></li> <li><p><strong>CreateThread</strong> provides control over security attributes. You can use this function to start a thread in a suspended state.</p></li> </ul> <p>The <strong>_beginthread</strong> function returns a handle to the new thread if successful or –1 if there was an error.</p>The _endthread Function <p>The <a target=\"_blank\" rel=\"nofollow\" href=\"http://msdn.microsoft.com/en-us/hw264s73%28VS.71%29.aspx\" >_endthread</a> function terminates a thread created by <strong>_beginthread</strong>. Threads terminate automatically when they finish. The <strong>_endthread</strong> function is useful for conditional termination from within a thread. A thread dedicated to communications processing, for example, can quit if it is unable to get control of the communications port.</p>See Also <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://msdn.microsoft.com/en-us/y6h8hye8%28VS.71%29.aspx\" >Multithreading with C and Win32</a></p> <p>&nbsp;</p> <p>&nbsp;</p>其他参考资料： <br /> <a target=\"_blank\" rel=\"nofollow\" href=\"http://support.microsoft.com/kb/140584/en-us\" >How to link with the correct C Run-Time (CRT) library</a> <br /> <a target=\"_blank\" rel=\"nofollow\" href=\"http://support.microsoft.com/kb/94248/en-us\" >How To Use the C Run-Time</a> <p><br /></p>  【图像处理】FFmpeg获取DirectShow设备数据的方法 1451833402077 Text 1dad75de_97e9d1e 【图像处理】,【编程开发】 <p>这两天研究了FFmpeg获取DirectShow设备数据的方法，在此简单记录一下以作备忘。本文所述的方法主要是对应Windows平台的。</p> <strong>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列设备</strong> <p><br /></p> <ol> <li><p>ffmpeg -list_devices true -f dshow -i dummy &nbsp;</p></li> </ol> <p>命令执行后输出的结果如下（注：中文的设备会出现乱码的情况）。列表显示设备的名称很重要，输入的时候都是使用“-f dshow -i video=&quot;{设备名}&quot;”的方式。</p> <p><img src=\"http://img.blog.csdn.net/20140730013108120\" style=\"max-width:500px;\" /><br /></p> <p>我自己的机器上列出了以下设备：</p> <p><br /></p> <ol> <li><p>[dshow @0388f5e0] DirectShow video devices &nbsp;</p></li> <li><p>[dshow&nbsp;@0388f5e0]&nbsp;&nbsp;&quot;Integrated Camera&quot;&nbsp;&nbsp;</p></li> <li><p>[dshow @0388f5e0]&nbsp;&quot;screen-capture-recorder&quot;&nbsp;&nbsp;</p></li> <li><p>[dshow&nbsp;@0388f5e0] DirectShow audio devices &nbsp;</p></li> <li><p>[dshow&nbsp;@0388f5e0]&nbsp;&nbsp;&quot;鍐呰楹﹀厠椋?(Conexant20672 SmartAudi&quot;&nbsp;&nbsp;</p></li> <li><p>[dshow @0388f5e0]&nbsp;&nbsp;&quot;virtual-audio-capturer&quot;&nbsp;&nbsp;</p></li> </ol> <p>下文的测试中，使用其中的两个视频输入：&quot;Integrated Camera&quot;和&quot;screen-capture-recorder&quot;。</p> <p>&nbsp;注：音频设备出现乱码，这个问题的解决方法会随后提到。</p> <strong>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取摄像头数据（保存为本地文件或者发送实时流）</strong>2.1.&nbsp;编码为H.264，保存为本地文件 <p>下面这条命令，实现了从摄像头读取数据并编码为H.264，最后保存成mycamera.mkv。</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;Integrated Camera&quot;&nbsp;-vcodec libx264 mycamera.mkv &nbsp;</p></li> </ol> 2.2.&nbsp;直接播放摄像头的数据 <p>使用ffplay可以直接播放摄像头的数据，命令如下：</p> <p><br /></p> <ol> <li><p>ffplay -f dshow -i video=&quot;Integrated Camera&quot;&nbsp;&nbsp;</p></li> </ol> <p>如果设备名称正确的话，会直接打开本机的摄像头，如图所示。</p> <p><img src=\"http://img.blog.csdn.net/20140730012916906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /><br /></p> <p>注：除了使用DirectShow作为输入外，使用VFW也可以读取到摄像头的数据，例如下述命令可以播放摄像头数据：</p> <p><br /></p> <ol> <li><p>ffplay -f vfwcap -i 0 &nbsp;</p></li> </ol> <p>此外，可以使用FFmpeg的list_options查看设备的选项：</p> <p><strong>[plain]</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38284961#\" >view plain</a><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38284961#\" >copy</a><a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/470020\" ><img src=\"https://code.csdn.net/assets/CODE_ico.png\" style=\"max-width:500px;\" /></a><a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/470020/fork\" ><img src=\"https://code.csdn.net/assets/ico_fork.svg\" style=\"max-width:500px;\" /></a></p> <ol> <li><p>ffmpeg -list_options true -f dshow -i video=&quot;Integrated Camera&quot;&nbsp;&nbsp;</p></li> </ol> <br />输出如下： <p><strong>[plain]</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38284961#\" >view plain</a><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38284961#\" >copy</a><a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/470020\" ><img src=\"https://code.csdn.net/assets/CODE_ico.png\" style=\"max-width:500px;\" /></a><a target=\"_blank\" rel=\"nofollow\" href=\"https://code.csdn.net/snippets/470020/fork\" ><img src=\"https://code.csdn.net/assets/ico_fork.svg\" style=\"max-width:500px;\" /></a></p> <ol> <li><p>[dshow @ 03845420] DirectShow video device options &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp; Pin &quot;鎹曡幏&quot;&nbsp;&nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=bgr24&nbsp; min s=640x480 fps=15 max s=640x480 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=bgr24&nbsp; min s=640x360 fps=15 max s=640x360 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=bgr24&nbsp; min s=352x288 fps=15 max s=352x288 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=bgr24&nbsp; min s=320x240 fps=15 max s=320x240 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=bgr24&nbsp; min s=800x448 fps=1 max s=800x448 fps=15 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=bgr24&nbsp; min s=960x544 fps=1 max s=960x544 fps=10 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=bgr24&nbsp; min s=1280x720 fps=1 max s=1280x720 fps=10 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=bgr24&nbsp; min s=424x240 fps=15 max s=424x240 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=yuyv422&nbsp; min s=640x480 fps=15 max s=640x480 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=yuyv422&nbsp; min s=640x360 fps=15 max s=640x360 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=yuyv422&nbsp; min s=352x288 fps=15 max s=352x288 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=yuyv422&nbsp; min s=320x240 fps=15 max s=320x240 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=yuyv422&nbsp; min s=800x448 fps=1 max s=800x448 fps=15 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=yuyv422&nbsp; min s=960x544 fps=1 max s=960x544 fps=10 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=yuyv422&nbsp; min s=1280x720 fps=1 max s=1280x720 fps=10 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; pixel_format=yuyv422&nbsp; min s=424x240 fps=15 max s=424x240 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; vcodec=mjpeg&nbsp; min s=640x480 fps=15 max s=640x480 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; vcodec=mjpeg&nbsp; min s=640x360 fps=15 max s=640x360 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; vcodec=mjpeg&nbsp; min s=352x288 fps=15 max s=352x288 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; vcodec=mjpeg&nbsp; min s=320x240 fps=15 max s=320x240 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; vcodec=mjpeg&nbsp; min s=800x448 fps=15 max s=800x448 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; vcodec=mjpeg&nbsp; min s=960x544 fps=15 max s=960x544 fps=30 &nbsp;</p></li> <li><p>[dshow&nbsp;@ 03845420]&nbsp;&nbsp; vcodec=mjpeg&nbsp; min s=1280x720 fps=15 max s=1280x720 fps=30 &nbsp;</p></li> </ol> <p><br /></p> <p>可以通过输出信息设置摄像头的参数。</p> <p>例如，设置摄像头分辨率为1280x720</p> <p><br /></p> <ol> <li><p>ffplay -s 1280x720 -f dshow -i video=&quot;Integrated Camera&quot;&nbsp;&nbsp;</p></li> </ol> 设置分辨率为424x240 <p><br /></p> <ol> <li><p>ffplay -s 424x240 -f dshow -i video=&quot;Integrated Camera&quot;&nbsp;&nbsp;</p></li> </ol> <br />2.3.&nbsp;编码为H.264，发布UDP <p>下面这条命令，实现了：获取摄像头数据-&gt;编码为H.264-&gt;封装为UDP并发送至组播地址。</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;Integrated Camera&quot;&nbsp;-vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f h264 udp://233.233.233.223:6666 &nbsp;</p></li> </ol> <p>注1：考虑到提高libx264的编码速度，添加了-preset:v ultrafast和-tune:v zerolatency两个选项。</p> <p>注2：高分辨率的情况下，使用UDP可能出现丢包的情况。为了避免这种情况，可以添加–s 参数（例如-s 320x240）调小分辨率。</p>2.4.&nbsp;编码为H.264，发布RTP <p>下面这条命令，实现了：获取摄像头数据-&gt;编码为H.264-&gt;封装为RTP并发送至组播地址。</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;Integrated Camera&quot;&nbsp;-vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f rtp rtp://233.233.233.223:6666&gt;test.sdp &nbsp;</p></li> </ol> <p>注1：考虑到提高libx264的编码速度，添加了-preset:v ultrafast和-tune:v zerolatency两个选项。</p> <p>注2：结尾添加“&gt;test.sdp”可以在发布的同时生成sdp文件。该文件可以用于该视频流的播放。</p>2.5.&nbsp;编码为H.264，发布RTMP <p>下面这条命令，实现了：获取摄像头数据-&gt;编码为H.264-&gt;并发送至RTMP服务器。</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;Integrated Camera&quot;&nbsp;-vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://localhost/oflaDemo/livestream &nbsp;</p></li> </ol> <br /> 2.6.&nbsp;编码为MPEG2，发布UDP <p>与编码为H.264类似，指明-vcodec即可。</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;Integrated Camera&quot;&nbsp;-vcodec mpeg2video -f mpeg2video udp://233.233.233.223:6666 &nbsp;</p></li> </ol> <br /> <p>播放MPEG2的UDP流如下。指明-vcodec为mpeg2video即可</p> <p><br /></p> <ol> <li><p>ffplay -vcodec mpeg2video udp://233.233.233.223:6666 &nbsp;</p></li> </ol> <p>&nbsp;</p> <strong>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;屏幕录制（Windows平台下保存为本地文件或者发送实时流）</strong> <p>Linux下使用FFmpeg进行屏幕录制相对比较方便，可以使用x11grab，使用如下的命令：</p> <p><br /></p> <ol> <li><p>ffmpeg -f x11grab -s 1600x900 -r 50 -vcodec libx264 –preset:v ultrafast –tune:v zerolatency -crf 18 -f mpegts udp://localhost:1234 &nbsp;</p></li> </ol> <p>详细时使用方式可以参考这篇文章：<a target=\"_blank\" rel=\"nofollow\" href=\"http://www.waitwut.info/blog/2013/06/09/desktop-streaming-with-ffmpeg-for-lower-latency/\" >DesktopStreaming With FFmpeg for Lower Latency</a></p> <p>Linux录屏在这里不再赘述。在Windows平台下屏幕录像则要稍微复杂一些。在Windows平台下，使用-dshow取代x11grab。一句话介绍：注册录屏dshow滤镜（例如screen-capture-recorder），然后通过dshow获取录屏图像然后编码处理。</p> <p>因此，在使用FFmpeg屏幕录像之前，需要先安装dshow滤镜。在这里推荐一个软件：screen capture recorder。安装这个软件之后，就可以通过FFmpeg屏幕录像了。</p> <p>&nbsp;</p> <p>screen capture recorder项目主页：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://sourceforge.net/projects/screencapturer/\" >http://sourceforge.net/projects/screencapturer/</a></p> <p>下载地址：</p> <p><a target=\"_blank\" rel=\"nofollow\" href=\"http://sourceforge.net/projects/screencapturer/files\" >http://sourceforge.net/projects/screencapturer/files</a></p> <p>下载完后，一路“Next”即可安装完毕。注意，需要Java运行环境（Java Runtime Environment），如果没有的话下载一个就行。</p> <p>screen capture recorder本身就可以录屏，不过这里我们使用FFmpeg进行录屏。</p> <p><img src=\"http://img.blog.csdn.net/20140730013631727?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /><br /></p>3.1.&nbsp;编码为H.264，保存为本地文件 <p>下面的命令可以将屏幕录制后编码为H.264并保存为本地文件。</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot;&nbsp;-r 5 -vcodec libx264 -preset:v ultrafast -tune:v zerolatency MyDesktop.mkv &nbsp;</p></li> </ol> <p>注：“-r 5”的意思是把帧率设置成5。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>最后得到的效果如下图。</p> <p><img src=\"http://img.blog.csdn.net/20140730013701321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /><br /></p> <p>此外，也可以录声音，声音输入可以分成两种：一种是真人说话的声音，通过话筒输入；一种是虚拟的声音，即录屏的时候电脑耳机里的声音。下面两条命令可以分别录制话筒的声音和电脑耳机里的声音。</p> <p>录屏，伴随话筒输入的声音</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot;&nbsp;-f dshow -i audio=&quot;鍐呰楹﹀厠椋?(Conexant 20672 SmartAudi&quot;&nbsp;-r 5 -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -acodec libmp3lame MyDesktop.mkv &nbsp;</p></li> </ol> <p>上述命令有问题：audio那里有乱码，把乱码ANSI转UTF-8之后，开始测试不行，后来发现是自己疏忽大意，乱码部分转码后为“内装麦克风&nbsp;”，然后接可以正常使用了。因此，命令应该如下图所示：</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot;&nbsp;-f dshow -i audio=&quot;内装麦克风&nbsp;(Conexant 20672 SmartAudi&quot;&nbsp;-r 5 -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -acodec libmp3lame MyDesktop.mkv &nbsp;</p></li> </ol> 注： <p>如果不熟悉ANSI转码UTF-8的话，还有一种更简单的方式查看设备的名称。即不使用FFmpeg查看系统DirectShow输入设备的名称，而使用DirectShow SDK自带的工具GraphEdit（或者网上下一个GraphStudioNext）查看输入名称。</p> <p>打开GraphEdit选择“图像-&gt;插入滤镜”</p> <p><img src=\"http://img.blog.csdn.net/20140921214014292?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /><br /></p> <p>然后就可以通过查看Audio Capture Sources来查看音频输入设备的简体中文名称了。从图中可以看出是“内装麦克风&nbsp;(Conexant 20672 SmartAudi”。</p> <p><img src=\"http://img.blog.csdn.net/20140921214115616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /><br /></p> <p>PS：感觉这条命令适合做讲座之类的时候使用</p> <p>&nbsp;</p> <p>录屏，伴随耳机输入的声音</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot;&nbsp;-f dshow -i audio=&quot;virtual-audio-capturer&quot;&nbsp;-r 5 -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -acodec libmp3lame MyDesktop.mkv &nbsp;</p></li> </ol> <p>PS：测这条命令的时候，这在听歌，因此录制的视频中的音频就是那首歌曲。</p> <p>&nbsp;</p>3.2.&nbsp;编码为H.264，发布UDP <p>下面的命令可以将屏幕录制后编码为H.264并封装成UDP发送到组播地址</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot;&nbsp;-r 5 -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f h264 udp://233.233.233.223:6666 &nbsp;</p></li> </ol> <p>注1：考虑到提高libx264的编码速度，添加了-preset:v ultrafast和-tune:v zerolatency两个选项。</p> <p>注2：高分辨率的情况下，使用UDP可能出现丢包的情况。为了避免这种情况，可以添加–s 参数（例如-s 320x240）调小分辨率。</p>3.3.&nbsp;编码为H.264，发布RTP <p>下面的命令可以将屏幕录制后编码为H.264并封装成RTP并发送到组播地址</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot;&nbsp;-vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f rtp rtp://233.233.233.223:6666&gt;test.sdp &nbsp;</p></li> </ol> <p>注1：考虑到提高libx264的编码速度，添加了-preset:v ultrafast和-tune:v zerolatency两个选项。</p> <p>注2：结尾添加“&gt;test.sdp”可以在发布的同时生成sdp文件。该文件可以用于该视频流的播放。如下命令即可播放：</p> <p><br /></p> <ol> <li><p>ffplay test.sdp &nbsp;</p></li> </ol> 3.4.&nbsp;编码为H.264，发布RTMP <p>原理同上，不再赘述。</p> <p><br /></p> <ol> <li><p>ffmpeg -f dshow -i video=&quot;Integrated Camera&quot;&nbsp;-vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://localhost/oflaDemo/livestream &nbsp;</p></li> </ol> <p>注意：播放RTMP的时候，-max_delay参数会比较明显的影响延迟，将此参数值设定小一些，有利于降低延时。</p> <p><br /></p> <ol> <li><p>ffplay -max_delay 100000 &quot;rtmp://localhost/oflaDemo/livestream live=1&quot;&nbsp;&nbsp;</p></li> </ol> 4.另一种屏幕录制的方式（2014.10.1更新） <p>最近发现FFmpeg还有一个专门用于Windows下屏幕录制的设备：gdigrab。</p> <p>gdigrab是基于GDI的抓屏设备，可以用于抓取屏幕的特定区域。在这里记录一下gdigrab的用法。</p> <p>gdigrab通过设定不同的输入URL，支持两种方式的屏幕抓取：</p> <p>（1）“desktop”：抓取整张桌面。或者抓取桌面中的一个特定的区域。<br />（2）“title={窗口名称}”：抓取屏幕中特定的一个窗口。<br /></p> <p>下面举几个例子。</p> <p>最简单的抓屏：</p> <p><strong>[plain]</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38284961#\" >view plain</a><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38284961#\" >copy</a></p> <ol> <li><p>ffmpeg -f gdigrab -i desktop out.mpg &nbsp;</p></li> </ol> <br />从屏幕的（10,20）点处开始，抓取640x480的屏幕，设定帧率为5 <p><strong>[plain]</strong>&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38284961#\" >view plain</a><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/leixiaohua1020/article/details/38284961#\" >copy</a></p> <ol> <li><p>ffmpeg -f gdigrab -framerate 5 -offset_x 10 -offset_y 20 -video_size 640x480 -i desktop out.mpg &nbsp;</p></li> </ol> <p><br /></p>  【图像处理】3A算法2 1451826922657 Text 1dad75de_97e4072 <p>&nbsp;&nbsp;网络上关于3A算法有若干，但是有算法的很少，有算法和文档的更少，zhuyunchuan的工程就是最后一种，谢谢他将工程开源光大，在此我在这里笔记下我的点滴思考。</p> <p>--------------------------------------------------</p> <p><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;模块的设计目标是，基于TI达芬奇平台的H3A(Hardware 3A，自动白平衡，自动曝光再加上自动聚焦)模块，研究2A算法的一系列特性，取得一种普适性比较好的模型，找出各种模型参数，并在达芬奇平台上具体实现该算法程序。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;笔记：这是利用好现成的平台，寻找最优灿发，其实专业说法就是&nbsp;图像调优，图像质量调节</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;如前所述，软件结合的实现方法既可以取得高性能的硬件加速，又可以通过软件实现新的算法，而且TI的达芬奇平台本身就包括H3A模块，不需要额外的芯片实现，所以成本上也非常具有优势。本项目就是采用软硬件结合的方法，首先通过驱动从H3A硬件模块获取中间数据，然后使用软件算法对中间数据进一步分析，获取控制参数来设置前端的颜色参数和曝光参数。实际上，本项目本身研究的算法模型是各种实现方式都可以使用的，并不局限于软硬件结合的实现方式。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;笔记：据我认识的曝光算法，其实也是硬软结合，以自动曝光算法来说，硬件提供设置曝光和增益的寄存器，软件实现算法最后来设置这些寄存器。</p> <p><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;达芬奇平台的H3A模块中对于自动曝光和自动白平衡使用的是同一个引擎，称之为AE/AWB Engine。该引擎首先将整个视频图像在水平和垂直方向上划分为多个子采样，每个子采样被称为一个窗口，然后以窗口为单位为对视频数据中的子采样的RGB颜色值进行<strong>累加</strong>，累加后的值做一个移位运算后输出中间数据(1.如何做窗口划分&nbsp;2.如何做累加)。可见H3A本身的处理是比较简单的，当然此模块也有一些选项可以配置，比如输出窗口中颜色值最大或者最小的值等等，我们只使用它的基本累加结果。累加值体现了该窗口各颜色值的平均值，这些值可以作为2A算法中色温评估和曝光电平评估的<strong>依据</strong>。对色温进行准确评估后，就可以进行响应控制了：如果色温偏红，就降低红色增益，提高蓝色和绿色增益，对其他颜色同理可推，这就是自动白平衡的基本原理；如果电平偏低(这个应该是亮度电平?)，就增大曝光时间和增益，反之降低曝光时间和增益，这就是自动曝光控制的基本原理。</p> <p>&nbsp;&nbsp;&nbsp;笔记：一句话，这里谈到了核心。一个是统计，AE需要统计画面中&nbsp;每个窗口中的平均亮度，AWB需要统计三个通道的亮度值。</p> <p>另外就是简易说到白平衡和自动曝光的原理。（待补充）</p> <p><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;原理虽然简单，但是整个环节中会有很多重要的细节，这些细节把握不好，得到的结果就会偏差很多或者不稳定。下面是对本项目算法的基本思想的简单描述。</p> <p><br /></p> <p>对于自动白平衡算法，主要难题是准确的找到评价区域，也就是原来是<strong>白色</strong>，被环境光照射后偏色的区域，而到底是偏色还是本来就是这种颜色是无法区分的，通用的做法是找到接近白色的区域，计算其色温，校正的结果就是将改区域的平均颜色校正为白色，评价是否接近白色的标准就非常重要了。本项目参考了基于YUV空间的Nakano，Lee等人提出的根据红色和蓝色色差进行评估的方法，提出了基于HSI空间的基于饱和度的进行评估的方法，前提是先将RGB空间转换为HIS空间。这种方法规避了红色和蓝色分量之间的关系难以处理的问题，饱和度是一个单独的参数，反映了颜色的纯度，一般来说饱和度很低的区域，应该就是原来是白色的区域。这些区域因为被染色了，所以会偏色，但还不至于达到很饱和的程度。</p> <p>笔记：所谓白平衡，就是各种色温环境还原白色，这里提到基于HSI空间的基于饱和度的进行评估白色的方法，待研究</p> <p><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;对于自动曝光算法，主要难题就是处理曝光控制的稳定性和速度的矛盾。当场景变化时，比如由明转暗或者由暗转明，就要对曝光参数做调节，也维持总体的亮度水平。如果调节的过快，由于反馈的作用，可能会引起亮度的振荡，如果调节的过慢，则会由于不能很快适应新的场景而丢失场景信息。本项目要找到一种基于精确的线性化曝光模型的自适应控制方法，在避免振荡的同时，能很快达到期望的亮度水平。同时，这个模型还考虑到交流市电频率下的日光灯，荧光灯，交通红绿灯的暗场亮场问题，通过对曝光时间与市电频率进行同步，并对同步引起曝光时间出现的阶跃进行补偿，最终达到线性状态。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;笔记：画面产生震荡，从能量角度上看，其实就是相邻曝光周期内接受能量不均造成的。为了避免震荡，曝光的设置就有学问，后面详细解释。</p> <p><br /></p> <p>我的笔记一句话汇总：</p> <p>&nbsp;&nbsp;&nbsp;这里的背景解释，说到了使用的硬件平台，同时概要的说明了awb/ae算法的特点和难点</p> <p><br /></p>  【图像处理】3A算法1 1451826773937 1451826887989 Text 1dad75de_97e4063 【图像处理】 <p>由于摄像机和人眼视觉在原理上的不同，在不同场景下记录下来的画面和人眼看上去差别会比较大，主要表现在场景色温的影响和光线强度的影响。人眼对不同物体的色温和光线强度会自动调节，以取得更合适的效果，简单的摄像机则没有此功能，在某些场景下看起来会偏色；同时人眼对亮度的分辨程度动态范围更宽，所以可以同时看到很亮的物体和很暗的物体；而简单的摄像机对信号进行量化后，动态范围大大降低，不能同时看到很亮和很暗的物体。</p> <p>笔记：人眼的亮度适应曲线如下图，可见亮暗有各自适应的区间。普通相机的弱点就是不能同时兼顾亮暗</p> <p><img src=\"http://jpkc.szpt.edu.cn/2007/sdsjs/wlkc/wlkc.files/image006.gif\" style=\"max-width:500px;\" /></p> <p><br /></p> <p>针对上述情况，可以通过调节图像的色温等参数，还有采用调节<strong>曝光时间和增益强度</strong>等方法，提高图像质量，减少和人类视觉上的差异。自动调节比手动设置参数可以适应很多的场景,&nbsp;所以一般情况下都使用自动调节白平衡参数和曝光参数的方法，也就是常说的2A(Auto White Balance &amp; Auto Exposure)处理。</p> <p><br /></p> <p>笔记：自动曝光和自动白平衡就是为了弥补器件弱点而提出来的算法，前者操作曝光和增益，后者适应色温调节参数，最后减少与人眼看到图像的差异。</p> <p><br /></p> <p>2A处理是视频处理流程中比较上游的环节，能够在视频压缩和做其他处理前对图像及其成像条件进行准确的校正非常关键，否则由于图像信息已经损失太多，在其他环节很难再正确的还原，研究鲁棒性高，性能好的2A算法对图像处理非常有意义。</p> <p>目前，2A是图像处理相关产品的必备模块，比如数码相机，数码摄像机，监控用途的网络摄像机等等，都含有2A模块，处理效果也基本令人满意。</p> <p>从软硬件的实现方式来讲，目前2A算法主要有一下几种实现方式：1，专用芯片方式，图像的分析和控制都在芯片上实现，软件只需要设置少数几个参数；2，软件方式，一般是在DSP上运行算法软件，分析原始视频数据，然后进行相应控制，参数可以比较灵活的设置；3，软硬结合方式，专用芯片负责分析原始视频数据并生成中间数据，由软件对该数据进行进一步分析和处理，这种方式可以取得速度和灵活性的折中；4，FPGA方式，一般在成本影响较小的情况下使用，将算法烧到FPGA上运行。</p> <p>笔记：这里谈到算法，其实就是ISP的核心的算法，其中2A加上auto focus合称为3A算法。我所知道的，富士通的ISP，ov的ISP都是使用ASIC芯片，Iphone的ISP使用DSP实现的</p> <p>目前大多算法基于专用芯片来实现的，其缺点是方案成本会升高，而且不能更加灵活的设置参数；另外的缺点就是，各种产品中应用的算法还没有充分优化，处理没有达到最佳的效果。比如，某些知名品牌的数码相机，也会经常拍出曝光过度或者曝光不足的照片；又比如，大部分数字摄像机在对着大区域色块时，该区域会褪色。究其原因，是因为目前的算法模型存在某些缺陷，需要进一步改进。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;笔记：ISP的好坏，往往被细节决定，其中高亮度和低亮度的反应就是典型的测试，还有从高亮度到低亮度的画面平稳性，还有在混合色温条件下的白平衡处理。</p> <p><br /></p>  【图像处理】ISP图像处理芯片-FH8510简介 1451824769953 1451824903420 Text 1dad75de_97e3f80 【图像处理】 <p><strong>一：FH8510 ISP处理芯片简介</strong></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FH8510是一款针对CIS（CMOS Image Sensor）的图像信号处理芯片，它内置强大图像处理引擎，CMOS图像传感器接口，TV编码器，D/A转换器，提供NTSC/PAL的输出，同时也提供ITU.BT656 10Bit的输出，主要应用于中低端标清模拟CCTV摄像机、车载后视摄像机及楼宇对讲摄像机。 FH8510可以支持多种CMOS图像传感器，具有功耗低、分辨率高、配置灵活、定制化程度高等特点。FH8510的缺省配置可以支持OV7740、OV7725，通过外接EEPROM还可以配置更多的CMOS图像传感器。FH8510的OSD采用硬件图像数据解压缩技术，全部的OSD数据可放置在EEPROM内。FH8510提供了一个IR LED和IR CUT控制接口，用户可以设定开、关阀值。</p> <p><img src=\"http://img.blog.csdn.net/20140705111341531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2F2ZW1jdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /><br /></p> <p>二：FH8510内部框图</p> <p><img src=\"http://img.blog.csdn.net/20140705112123796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2F2ZW1jdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /><br /></p> <p>2.1 视频输入<br /></p> <ul> <li><p>支持SVGA、D1、VGA输入</p></li> <li><p>RGB Bayer</p></li> <li><p>最大数据位宽10-bit</p></li> <li><p>时钟正、负沿采样可配置</p></li> <li><p>帧有效、行有效信号极性可配置</p></li> <li><p>最高像素时钟54MHz</p></li> </ul> <p>2.2 图像处理（ISP）&nbsp;</p> <ul> <li><p>RGB Bayer数据格式，Sensor输出窗口坐标随意</p></li> <li><p>自动彩色转黑白</p></li> <li><p>固定模式噪声的消除</p></li> <li><p>坏点的自动检测和消除</p></li> <li><p>Sensor列固定模式噪声消除(外接4KB EEPROM)</p></li> <li><p>暗角补偿(Lens Shade Correction)</p></li> <li><p>镜头中心位置可配置</p></li> <li><p>补偿系数表可配置</p></li> <li><p>自动黑底消除</p></li> <li><p>自适应的2D去噪</p></li> <li><p>图像信息统计</p></li> <li><p>统计窗口数量、位置和大小可配置</p></li> <li><p>统计窗口数目最大数目64个</p></li> <li><p>提供每一个窗口的最大值、最小值和均值</p></li> <li><p>自动曝光，50Hz/60Hz闪烁消除</p></li> <li><p>自动白平衡</p></li> <li><p>基于边缘检测的CFA插值</p></li> <li><p>自动颜色校正，实现可配置的色彩空间转换RGB2RGB</p></li> <li><p>Gamma校正，Gamma表可配置</p></li> <li><p>图像增强</p></li> <li><p>度对比度、色调和饱和度调整</p></li> <li><p>图像锐化(5x5滤波，强度可配)</p></li> <li><p>图像缩放</p></li> <li><p>可配置缩放核，支持无级缩放，匹配Sensor的输出幅面和标清幅面</p></li> <li><p>水平、垂直缩放比例可配置</p></li> <li><p>支持64相位，初始相位独立可配置</p></li> <li><p>图像分辨率</p></li> <li><p>VGA Sensor， 420TVL</p></li> <li><p>D1、SVGA Sensor， 540TVL</p></li> </ul> <p>2.3 视频输出&nbsp;<br /></p> <ul> <li><p>复合视频CVBS (NTSC 720&times;480&nbsp; PAL 720&times;576)</p></li> <li><p>ITU.BT-656 (10Bit)&nbsp;输出（可选）</p></li> </ul> <p> 2.4 OSD </p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1个Graphic层叠加&nbsp;(外接8K EEPROM)<br /></p> <ul> <li><p>Graphic窗口位置可配置</p></li> <li><p>Graphic窗口高、宽可配置</p></li> <li><p>Graphic数据格式可配置(支持无损压缩1~6bpp索引位图)</p></li> <li><p>调色板内容可配置，支持最多64色32bit调色板(ARGB8888格式)</p></li> <li><p>硬件闪烁显示控制</p></li> <li><p>硬件Graphic数据解压缩</p></li> <li><p>硬件Graphic数据DMA传输握手</p></li> </ul> <p>2.5 时钟&nbsp;<br /></p> <ul> <li><p>6MHz晶振</p></li> </ul> <p>2.6 EEPROM配置&nbsp;</p> <ul> <li><p>2K BYTE 支持多种CMOS图像传感器配置</p></li> <li><p>4K BYTE 支持多种CMOS图像传感器配置及列固定模式噪声消除</p></li> <li><p>8K BYTE 支持多种CMOS图像传感器配置、列固定模式噪声消除、OSD</p></li> </ul> <p>三：典型应用场合</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以用的场合有楼宇对讲、安防监控、倒车后视系统，如下框图所示：</p> <p><img src=\"http://img.blog.csdn.net/20140705113117078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2F2ZW1jdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" style=\"max-width:500px;\" /><br /></p> <p>可以直接配合OV7725之类的Sensor的哦。不知道价格如何，看起来性能不错的哦，这颗IC。</p> <p>转载自&nbsp;<a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/wavemcu/article/details/37040625\" >ISP图像处理芯片-FH8510简介</a></p>  【图像处理】ISP 1451824454712 Text 1dad75de_97e3f64 【图像处理】 <p>&nbsp;&nbsp;&nbsp;&nbsp; ISP(Image Signal Processor)，即图像处理，主要作用是对前端图像传感器输出的信号做后期处理，主要功能有线性纠正、噪声去除、坏点去除、内插、白平衡、自动曝光控制等，依赖于ISP才能在不同的光学条件下都能较好的还原现场细节，ISP技术在很大程度上决定了摄像机的成像质量。<br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安防市场过去多使用CCD作为图像传感器，少有CMOS的身影。近年来，相对于已发展成熟的CCD停滞不前的状态，CMOS传感器随着技术发展已逐步打开被CCD独占的市场。但CMOS目前的技术与CCD相比，仍具有感光度低、信噪比高的缺点。这时作为CMOS和CCD摄像机中重要搭配零组件的ISP，因应CMOS的大量出货而引发的更多应用开发，以弥补CMOS在感光度低、信噪比高上的不足。随着人们对画质的关注，ISP已经越来越受到芯片商和摄像机制造商的重视。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;早年芯片市场素有ASIC、DSP之争，现今多家芯片公司基于ASIC或DSP开发出整合度更高、更加适合视频监控需求的片上系统——SoC。SoC将处理器资源、内存资源、编解码算法、外围设备接口等都集成在单个平台上，将大部分功能固化，并对特殊功能需求模块化，以源代码方式给厂商，厂商根据不同应用需求进行二次开发，同时，还可以增加视频协处理器以及其他视频子系统，以强化视频图像处理能力。它综合ASIC、DSP两者优势，协助终端产品客户简化系统设计。不论选用何种芯片方案，可以看到主流芯片大多已整合ISP功能。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集成ISP目前有多种方案，芯片集成ISP后对安防厂家的研发水平要求降低，并同时降低系统成本，随着芯片所集成的ISP功能的不断强大，已可满足大多数场合的应用需求。但对于寻求高端差异化发展的安防厂家来说，目前市场SoC上所集成的ISP并不能满足他们全部的需求，因此市面上也有集成ISP处理算法的DSP或FPGA芯片。据悉，ISP处理在WDR、DNR上有标准化的趋势，50dB/70dB宽动态组件搭配CMOS，在摄像机上已成为标准配备，如Nextchip、pixelplus等。目前国内高清摄像机产品中的ISP一般有以下几个来源：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-厂商自行研发。自行研发ISP处理算法、将算法集成至FPGA。开发具备较强的技术实力，会将传感器的应用发挥到极致。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-第三方研发。第三方直接出售不同的ISP芯片给摄像机厂商配合不同厂商的传感器。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-套片模式。传感器厂商结合自家的传感器配套推向客户，其中的图像处理算法及各种调试工作已完成，厂商只做对接接口即可。套片模式一般被研发实力有限的厂商接纳，同质化现象较严重。</p> <p>下面附上一个招聘要求，可以去度量一下自己的水平是否达到要求：</p> <p>汉邦高科</p> <p>任职要求：</p> <p>1.&nbsp;电子工程、图像与信号处理、计算机等相关专业，本科及以上学历；</p> <p>2.&nbsp;在数字图像处理、视频压缩等方面具有扎实的理论背景知识；&nbsp;</p> <p>3.&nbsp;熟悉Sony、Panasonic、Aptina、OmniVision等常用CCD/CMOS芯片的成像原理及工作流程，至少在下述一个领域有1年以上研发经验：&nbsp;</p> <p>1)&nbsp;熟悉图像预处理和后处理技术：3D降噪、边缘增强、色彩还原、对比度增强、宽动态增强等常用的图像处理算法；&nbsp;</p> <p>2)&nbsp;熟悉3A算法：自动曝光、自动对焦、自动白平衡；&nbsp;</p> <p>4.&nbsp;熟练掌握C/C++，具有嵌入式Linux驱动的开发经验；&nbsp;</p> <p>5.&nbsp;熟练掌握FPGA、DSP等器件编程者优先考虑。</p> <p>海康威视</p> <p>岗位要求：</p> <p>1、本科及以上学历；</p> <p>2、计算机、信号处理、图像处理及信息类专业；</p> <p>3、一年以上ISP调试经验，有信号处理算法如3A控制、色彩校正、tone mapping等技术的优先。</p> <p><br /></p> <p><br /></p>  【图像处理】Image Signal Processor原理分析 1451823818254 Text 1dad75de_97e3f2b 【图像处理】 <p><strong>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前言</strong></p> <p>做为拍照手机的核心模块之一，camera sensor效果的调整，涉及到众多的参数，如果对基本的光学原理及sensor软/硬件对图像处理的原理能有深入的理解和把握的话，对我们的工作将会起&nbsp;到事半功倍的效果。否则，缺乏了理论的指导，只能是凭感觉和经验去碰，往往无法准确的把握问题的关键，不能掌握sensor调试的核心技术，无法根本的解&nbsp;决问题。</p> <p>所以，这里笔者结合自己出于对摄影的爱好所学习的一些图像处理相关的原理，试图通过分析一些与Sensor图像处理相关的因素，和大家分享一下自己的一些理解，共同探讨，共同学习进步。</p> <p><strong>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色彩感应及校正</strong></p> <p><strong>2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理</strong></p> <p>人眼对色彩的识别，是基于人眼对光线存在三种不同的感应单元，不同的感应单元对不同波段的光有不同的响应曲线的原理，通过大脑的合成得到色彩的感知。&nbsp;一般来说，我们可以通俗的用RGB三基色的概念来理解颜色的分解和合成。</p> <p>&nbsp;</p> <p>理论上，如果人眼和sensor对光谱的色光的响应，在光谱上的体现如下的话，基本上对三色光的响应，相互之间不会发生影响，没有所谓的交叉效应。</p> <p>&nbsp;</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/f87becbd8c5447849d9b0ee9c8b3f116.jpg\" style=\"max-width:500px;\" /></p> <p>但是，实际情况并没有如此理想，下图表示了人眼的三色感应系统对光谱的响应情况。可见RGB的响应并不是完全独立的。</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/6e6e52f602a04f398938e9fb4de654bf.gif\" style=\"max-width:500px;\" /></p> <p>下图则表示了某Kodak相机光谱的响应。可见其与人眼的响应曲线有较大的区别。</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/c6312f73043649cd9114aae7b01f34e0.png\" style=\"max-width:500px;\" /></p> <p><strong>2.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对sensor的色彩感应的校正</strong></p> <p>既然我们已经看到sensor对光谱的响应，在RGB各分量上与人眼对光谱的响应通常是有偏差的，当然就需要对其进行校正。不光是在交叉效应上，同样对色彩各分量的响应强度也需要校正。通常的做法是通过一个色彩校正矩阵对颜色进行一次校正。</p> <p><img src=\"http://writeblog.csdn.net/Editor/FCKeditor/editor/%3Chtml%3E%20%20%20%20%3Chead%3E%20%20%20%20%20%20%20%20%3Ctitle%3E%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?/title%3E%20%20%20%20%20%20%20%20%3Cstyle%3E%20%20%20%20%20%20%20%20%20body%20%7Bfont-family:%22Verdana%22;font-weight:normal;font-size:%20.7em;color:black;%7D%20%20%20%20%20%20%20%20%20%20p%20%7Bfont-family:%22Verdana%22;font-weight:normal;color:black;margin-top:%20-5px%7D%20%20%20%20%20%20%20%20%20b%20%7Bfont-family:%22Verdana%22;font-weight:bold;color:black;margin-top:%20-5px%7D%20%20%20%20%20%20%20%20%20H1%20%7B%20font-family:%22Verdana%22;font-weight:normal;font-size:18pt;color:red%20%7D%20%20%20%20%20%20%20%20%20H2%20%7B%20font-family:%22Verdana%22;font-weight:normal;font-size:14pt;color:maroon%20%7D%20%20%20%20%20%20%20%20%20pre%20%7Bfont-family:%22Lucida%20Console%22;font-size:%20.9em%7D%20%20%20%20%20%20%20%20%20.marker%20%7Bfont-weight:%20bold;%20color:%20black;text-decoration:%20none;%7D%20%20%20%20%20%20%20%20%20.version%20%7Bcolor:%20gray;%7D%20%20%20%20%20%20%20%20%20.error%20%7Bmargin-bottom:%2010px;%7D%20%20%20%20%20%20%20%20%20.expandable%20%7B%20text-decoration:underline;%20font-weight:bold;%20color:navy;%20cursor:hand;%20%7D%20%20%20%20%20%20%20%20%3C/style%3E%20%20%20%20%3C/head%3E%20%20%20%20%3Cbody%20bgcolor=%22white%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cspan%3E%3Cdiv%3E%3Cb%3E%3Cfont%20size=%226%22%3E%E9%88%A5?%E9%88%A5%E6%BF%86%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%8E%E8%85%91%E9%90%A8%E5%8B%AC%E6%B9%87%E9%8D%94%E2%80%B3%E6%AB%92%E9%96%BF%E6%AC%92%EE%87%A4%E9%8A%86?hr%20width=100%%20size=1%20color=silver%3E%3C/font%3E%3C/b%3E%3C/div%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cdiv%3E%3Cb%3E%3Cfont%20size=%225%22%3E%20%3Ci%3E%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?/i%3E%20%3C/font%3E%3C/b%3E%3C/div%3E%3C/span%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cfont%20face=%22Arial,%20Helvetica,%20Geneva,%20SunSans-Regular,%20sans-serif%20%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%20%E7%92%87%E5%AD%98%E6%A7%91:%20%3C/b%3E%E9%8E%B5%D1%86%EE%94%91%E8%A4%B0%E6%92%B3%E5%A2%A0%20Web%20%E7%92%87%E9%94%8B%E7%9C%B0%E9%8F%88%E7%86%BC%E6%A3%BF%E9%94%9B%E5%B1%BD%E5%9A%AD%E9%90%9C%E7%89%88%E6%B9%AD%E6%BE%B6%E5%8B%AD%E6%82%8A%E9%90%A8%E5%8B%AB%E7%B4%93%E7%94%AF%E6%90%9E%E2%82%AC%E5%82%9D%EE%87%AC%E5%A6%AB%E2%82%AC%E9%8F%8C%E3%83%A5%E7%88%A2%E9%8F%8D%E5%A0%A3%E7%AA%A1%E9%9F%AA%EE%81%83%E4%BF%8A%E9%8E%AD%EE%88%A4%E7%B4%9D%E6%B5%A0%E3%83%A4%E7%B0%A1%E7%91%99%EF%BD%86%E6%B9%81%E9%8D%8F%E5%AE%A0%EE%87%9A%E9%96%BF%E6%AC%92%EE%87%A4%E6%B5%A0%E3%83%A5%E5%BC%B7%E6%B5%A0%EF%BD%87%E7%88%9C%E6%B6%93%EE%85%9E%EE%87%B1%E9%91%B7%E6%92%AE%E6%95%8A%E7%92%87%EE%88%9C%E6%AE%91%E9%8D%91%E5%93%84%EE%98%A9%E9%90%A8%E5%8B%AE%EE%87%9B%E7%BC%81%E5%97%95%E4%BF%8A%E9%8E%AD%EE%88%98%E2%82%AC?%20%20%20%20%20%20%20%20%20%20%20%20%3Cbr%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%20%E5%AF%AE%E5%82%9A%E7%88%B6%E7%92%87%EF%B8%BE%E7%B2%8F%E6%B7%87%E2%84%83%E4%BC%85:%20%3C/b%3ESystem.ArgumentException:%20%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?br%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%E5%A9%A7%E6%84%B0%E6%95%8A%E7%92%87?%3C/b%3E%20%3Cbr%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Ctable%20width=100%%20bgcolor=%22#ffffcc%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctr%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctd%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ccode%3E%E9%8D%99%EE%81%85%E6%B9%81%E9%8D%A6%E3%84%A8%E7%9A%9F%E7%92%87%E6%9B%9F%C4%81%E5%AF%AE%E5%BF%8E%E7%AC%85%E6%9D%A9%E6%B6%9C%EE%94%91%E7%BC%82%E6%A0%AC%E7%98%A7%E9%8F%83%E8%AE%B9%E7%B4%9D%E9%90%A2%E7%86%B8%E5%9E%9A%E5%A7%9D%E3%82%86%E6%B9%AD%E6%BE%B6%E5%8B%AD%E6%82%8A%E5%AF%AE%E5%82%9A%E7%88%B6%E9%90%A8%E5%8B%AC%E7%B0%AE%E6%B5%A0%EF%BD%87%E7%88%9C%E9%8E%B5%E5%B6%84%E7%B4%B0%E9%8F%84%E5%89%A7%E3%81%9A%E9%8D%91%E7%83%98%E6%BD%B5%E9%8A%86%E5%82%9D%E5%AB%A2%E7%91%95%E4%BD%B8%E6%83%8E%E9%90%A2%E3%84%A6%EE%84%9D%E9%8D%94%E7%86%BB%E5%85%98%E9%94%9B%E5%B2%83%EE%87%AC%E9%8E%B5%D1%86%EE%94%91%E6%B5%A0%E3%83%A4%E7%AC%85%E5%A7%9D%E3%83%A9%EE%80%83%E6%B6%94%E5%AC%A9%E7%AB%B4%E9%94%9B%E5%B2%80%E5%8A%A7%E9%8D%9A%E5%BA%A4%EE%87%AC%E5%A7%B9?URL:%20%3Cbr%3E%3Cbr%3E1.%20%E9%8D%A6%E3%84%A4%E9%AA%87%E9%90%A2%E7%86%BC%E6%95%8A%E7%92%87%EE%88%9C%E6%AE%91%E9%8F%82%E5%9B%A6%E6%AC%A2%E9%90%A8%E5%8B%AF%E3%80%8A%E9%96%AE%E3%84%A6%E5%9D%8A%E9%8D%94%E7%8A%B1%E7%AB%B4%E9%8F%89%E2%99%80%E2%82%AC%E6%B7%92ebug=true%E9%88%A5%E6%BF%87%E5%AF%9A%E6%B5%A0%E3%82%83%E2%82%AC%E5%82%99%E7%B7%A5%E6%BF%A1?%20%3Cbr%3E%3Cbr%3E%20%C2%A0%C2%A0%3C%@%20Page%20Language=%22C%22%20Debug=%22true%22%20%%3E%3Cbr%3E%3Cbr%3E%E9%8E%B4?%3Cbr%3E%3Cbr%3E2.%20%E7%81%8F%E5%97%95%E4%BA%92%E6%B6%93%E5%AC%AC%E6%AE%91%E9%91%BA%E5%82%9B%E5%9D%8A%E9%8D%94%E7%8A%B2%E5%9F%8C%E6%90%B4%E6%97%82%E6%95%A4%E7%BB%8B%E5%AC%AA%E7%B0%AD%E9%90%A8%E5%8B%AF%E5%8E%A4%E7%BC%83%EE%86%BD%E6%9E%83%E6%B5%A0%E6%9C%B5%E8%85%91:%3Cbr%3E%3Cbr%3E%3Cconfiguration%3E%3Cbr%3E%20%C2%A0%C2%A0%C2%A0%3Csystem.web%3E%3Cbr%3E%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3Ccompilation%20debug=%22true%22/%3E%3Cbr%3E%20%C2%A0%C2%A0%C2%A0%3C/system.web%3E%3Cbr%3E%3C/configuration%3E%3Cbr%3E%3Cbr%3E%20%E7%92%87%E9%94%8B%E6%95%9E%E9%8E%B0%E5%BF%A5%E7%B4%9D%E7%BB%97%EE%83%BF%E7%B0%A9%E6%B6%93%EE%81%85%EE%84%9E%E6%A5%A0%E3%82%85%E7%9A%A2%E6%B5%A3%E8%B7%A8%E7%B2%B0%E7%80%B9%E6%B0%AC%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%8E%E8%85%91%E9%90%A8%E5%8B%AC%E5%A2%8D%E9%8F%88%E5%A4%8B%E6%9E%83%E6%B5%A0%E8%B7%BA%E6%B9%AA%E7%92%8B%E5%86%AD%E7%98%AF%E5%A6%AF%E2%80%B3%E7%B4%A1%E6%B6%93%E5%AC%AD%E7%B9%98%E7%90%9B%E5%B2%80%E7%B4%AA%E7%92%87%E6%88%AF%E7%B4%B1%E7%BB%97%EE%83%BF%E7%AB%B4%E6%B6%93%EE%81%85%EE%84%9E%E6%A5%A0%E3%82%84%E7%B2%8E%E6%B5%A3%E8%83%AF%EE%87%9A%E9%90%97%E7%91%B0%E7%95%BE%E9%8F%82%E5%9B%A6%E6%AC%A2%E9%8D%A6%E3%84%A8%E7%9A%9F%E7%92%87%E6%9B%9F%C4%81%E5%AF%AE%E5%BF%8E%E7%AC%85%E6%9D%A9%E6%B6%9C%EE%94%91%E7%BC%82%E6%A0%AC%E7%98%A7%E9%8A%86?br%3E%3Cbr%3E%E9%96%B2%E5%B6%88%EE%9B%A6%E6%B5%9C%E5%AC%AE%E3%80%8D:%20%E6%B5%A0%E3%83%A8%E7%9A%9F%E7%92%87%E6%9B%9F%C4%81%E5%AF%AE%E5%BF%9A%E7%B9%8D%E7%90%9B%E5%B1%BD%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%8E%E7%AB%B4%E7%80%B9%E6%B0%AB%E7%B4%B0%E6%B5%9C%D1%85%E6%95%93%E9%8D%90%E5%91%AD%E7%93%A8/%E9%8E%AC%D1%86%E5%85%98%E7%BB%AF%E8%8D%A4%E7%B2%BA%E5%AF%AE%E2%82%AC%E9%96%BF%E2%82%AC%E9%8A%86%E5%82%9A%E6%B9%AA%E9%96%AE%E3%84%A7%E8%AE%B2%E9%8D%92%E6%89%AE%E6%95%93%E6%B5%9C%D1%84%E6%9F%9F%E5%A6%97%E5%A0%9C%E7%AE%A3%E9%8D%93%E5%B6%8F%E7%B4%9D%E6%90%B4%E6%97%82%E2%80%98%E6%B7%87%E6%BF%86%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%9A%E7%9A%9F%E7%92%87%E6%9B%9E%E5%87%A1%E7%BB%82%E4%BD%BA%E6%95%A4%E9%8A%86?/code%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/td%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/tr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3C/table%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%E9%8D%AB%E5%97%98%E7%88%A4%E7%92%BA%E7%86%BB%E9%87%9C:%3C/b%3E%20%3Cbr%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Ctable%20width=100%%20bgcolor=%22ffffcc%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctr%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctd%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ccode%3E%3Cpre%3E[ArgumentException:%20%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86%E4%BF%94%20%20%20System.Drawing.Image.FromStream%28Stream%20stream,%20Boolean%20useEmbeddedColorManagement,%20Boolean%20validateImageData%29%20+388134%20%20%20System.Drawing.Image.FromStream%28Stream%20stream%29%20+8%20%20%20Dottext.Admin.UploadWord.SaveFile%28HttpPostedFile%20File%29%20+32%20%20%20Dottext.Admin.UploadWord.Page_Load%28Object%20sender,%20EventArgs%20e%29%20+76%20%20%20System.Web.Util.CalliHelper.EventArgFunctionCaller%28IntPtr%20fp,%20Object%20o,%20Object%20t,%20EventArgs%20e%29%20+15%20%20%20System.Web.Util.CalliEventHandlerDelegateProxy.Callback%28Object%20sender,%20EventArgs%20e%29%20+34%20%20%20System.Web.UI.Control.OnLoad%28EventArgs%20e%29%20+99%20%20%20System.Web.UI.Control.LoadRecursive%28%29%20+47%20%20%20System.Web.UI.Page.ProcessRequestMain%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29%20+1061%3C/pre%3E%3C/code%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/td%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/tr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3C/table%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Chr%20width=100%%20size=1%20color=silver%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%E9%90%97%E5%A0%9F%E6%B9%B0%E6%B7%87%E2%84%83%E4%BC%85:%3C/b%3E%C2%A0Microsoft%20.NET%20Framework%20%E9%90%97%E5%A0%9F%E6%B9%B0:2.0.50727.832;%20ASP.NET%20%E9%90%97%E5%A0%9F%E6%B9%B0:2.0.50727.832%20%20%20%20%20%20%20%20%20%20%20%20%3C/font%3E%20%20%20%20%3C/body%3E%3C/html%3E%3C%21--%20[ArgumentException]:%20%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?%20%20%20%E9%8D%A6?System.Drawing.Image.FromStream%28Stream%20stream,%20Boolean%20useEmbeddedColorManagement,%20Boolean%20validateImageData%29%20%20%20%E9%8D%A6?System.Drawing.Image.FromStream%28Stream%20stream%29%20%20%20%E9%8D%A6?Dottext.Admin.UploadWord.SaveFile%28HttpPostedFile%20File%29%20%20%20%E9%8D%A6?Dottext.Admin.UploadWord.Page_Load%28Object%20sender,%20EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.Util.CalliHelper.EventArgFunctionCaller%28IntPtr%20fp,%20Object%20o,%20Object%20t,%20EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.Util.CalliEventHandlerDelegateProxy.Callback%28Object%20sender,%20EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.UI.Control.OnLoad%28EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.UI.Control.LoadRecursive%28%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequestMain%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29[HttpUnhandledException]:%20%E5%AF%AE%E6%9B%9E%E5%BD%82%E7%BB%AB%E8%AF%B2%E7%80%B7%E6%B6%93%E8%A1%A1%E2%82%AC%E6%B7%AAystem.Web.HttpUnhandledException%E9%88%A5%E6%BF%88%E6%AE%91%E5%AF%AE%E5%82%9A%E7%88%B6%E9%8A%86?%20%20%20%E9%8D%A6?System.Web.UI.Page.HandleError%28Exception%20e%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequestMain%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequest%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequest%28%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequestWithNoAssert%28HttpContext%20context%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequest%28HttpContext%20context%29%20%20%20%E9%8D%A6?ASP.uploadword_aspx.ProcessRequest%28HttpContext%20context%29%20%20%20%E9%8D%A6?System.Web.HttpApplication.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute%28%29%20%20%20%E9%8D%A6?System.Web.HttpApplication.ExecuteStep%28IExecutionStep%20step,%20Boolean&amp;%20completedSynchronously%29--%3E%3C%21--%20%E5%A7%9D%E3%82%89%E6%95%8A%E7%92%87%EE%88%9E%E3%80%89%E9%8D%99%EE%88%9D%E5%85%98%E9%8D%96%E5%91%AD%E6%83%88%E9%8F%81%E5%BF%94%E5%8A%85%E6%B7%87%E2%84%83%E4%BC%85%E9%94%9B%E5%B1%BD%E6%B4%9C%E6%B6%93?ASP.NET%20%E9%96%AB%E6%B0%B3%E7%B9%83%20%3CcustomErrors%20mode=%22Off%22/%3E%20%E7%90%9A%EE%82%A6%E5%8E%A4%E7%BC%83%EE%86%BB%E8%B4%9F%E9%8F%84%E5%89%A7%E3%81%9A%E7%92%87%EF%B8%BE%E7%B2%8F%E9%96%BF%E6%AC%92%EE%87%A4%E6%B7%87%E2%84%83%E4%BC%85%E9%8A%86%E5%82%9D%EE%87%AC%E9%91%B0%E5%86%AD%E6%AA%BB%E9%8D%A6%E3%84%A7%E6%95%93%E6%B5%9C%D1%85%E5%B9%86%E6%BE%A7%E5%86%A7%E8%85%91%E6%B5%A3%E8%B7%A8%E6%95%A4%20%3CcustomErrors%20mode=%22On%22/%3E%20%E9%8E%B4?%3CcustomErrors%20mode=%22RemoteOnly%22/%3E%E9%8A%86?-%3E\" style=\"max-width:500px;\" />1</p> <p>该色彩校正的运算通常是由sensor模块集成或后端的ISP完成，软件通过修改相关寄存器得到正确的校正结果。值得注意的一点是，由于RGB -&gt; YUV的转换也是通过一个3*3的变换矩阵来实现的，所以有时候这两个矩阵在ISP处理的过程中会合并在一起，通过一次矩阵运算操作完成色彩的校正和颜色&nbsp;空间的转换。</p> <p><strong>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;颜色空间</strong></p> <p><strong>3.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分类</strong></p> <p>实际上颜色的描述是非常复杂的，比如RGB三基色加光系统就不能涵盖所有可能的颜色，出于各种色彩表达，以及色彩变换和软硬件应用的需求，存在各种各样的颜色模型及色彩空间的表达方式。这些颜色模型，根据不同的划分标准，可以按不同的原则划分为不同的类别。</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/4171118db5f84b23aa6b7907d286eb10.gif\" style=\"max-width:500px;\" /></p> <p>匹配任意可见光所需的三原色光比例曲线</p> <p>&nbsp;</p> <p>对于sensor来说，我们经常接触到的色彩空间的概念，主要是RGB , YUV这两种（实际上，这两种体系包含了许多种不同的颜色表达方式和模型，如sRGB, Adobe RGB, YUV422, YUV420 …）, RGB如前所述就是按三基色加光系统的原理来描述颜色，而YUV则是按照&nbsp;亮度，色差的原理来描述颜色。</p> <p><strong>3.1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RGB &lt;-&gt; YUV的转换</strong></p> <p>不比其它颜色空间的转换有一个标准的转换公式，因为YUV在很大程度上是与硬件相关的，所以RGB与YUV的转换公式通常会多个版本，略有不同。</p> <p>&nbsp;</p> <p>常见的公式如下：</p> <p>Y=0.30R+0.59G+0.11B <br />U=0.493(B－Y)&nbsp;=&nbsp;－0.15R－0.29G+0.44B <br />V=0.877(R－Y)&nbsp;= 0.62R－0.52G－0.10B</p> <p>&nbsp;</p> <p>但是这样获得的YUV值存在着负值以及取值范围上下限之差不为255等等问题，不利于计算机处理，所以根据不同的理解和需求，通常在软件处理中会用到各种不同的变形的公式，这里就不列举了。</p> <p>体现在Sensor上，我们也会发现有些Sensor可以设置YUV的输出取值范围。原因就在于此。</p> <p>从公式中，我们关键要理解的一点是，UV 信号实际上就是蓝色差信号和红色差信号，进而言之，实际上一定程度上间接的代表了蓝色和红色的强度，理解这一点对于我们理解各种颜色变换处理的过程会有很大的帮助。<br /><br /><br /></p> <strong>1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;白平衡</strong> <p><strong>1.1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色温</strong></p> <p>色温的定义：将黑体从绝对零度开始加温，温度每升高一度称为1开氏度(用字母K来表示)，当温度升高到一定程度时候，黑体便辐射出可见光，其光谱成份以及给人的感觉也会着温度的不断升高发生相应的变化。于是，就把黑体辐射一定色光的温度定为发射相同色光光源的色温。</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/1c24593e2c9447ee88b325b9e52b4338.gif\" style=\"max-width:500px;\" /></p> <p>常见光源色温：</p> <p>光源&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色温（K）</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;钨丝灯（白炽灯）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2500-3200k</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;碳棒灯&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4000-5500k</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;荧光灯（日光灯，节能灯）&nbsp;&nbsp; 4500-6500k</p> <p>氙灯&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5600 k</p> <p>炭精灯&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5500～6500k</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;日光平均&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5400k</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;有云天气下的日光&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6500-7000k</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;阴天日光&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12000-18000k</p> <p>&nbsp;</p> <p>随着色温的升高，光源的颜色由暖色向冷色过渡，光源中的能量分布也由红光端向蓝光端偏移。</p> <p>值得注意的是，实际光源的光谱分布各不相同，而色温只是代表了能量的偏重程度，并不反映具体的光谱分布，所以即使相同色温的光源，也可能引起不同的色彩反应。</p> <p>人眼及大脑对色温有一定的生理和心理的自适应性，所以看到的颜色受色温偏移的影响较小，而camera的sersor没有这种能力，所以拍出来的照片不经过白平衡处理的话，和人眼看到的颜色会有较大的偏差（虽然人眼看到的和白光下真实的色彩也有偏差）。</p> <p>太阳光色温随天气和时间变化的原因，与不同频率光的折射率有关：</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/c201cbd504ec4432b879326030b00cfc.gif\" style=\"max-width:500px;\" /></p> <p>波长长的光线，折射率小，透射能力强，波长短的光线，折射率大，容易被散射，折射率低，这也就是为什么交通灯用红色，防雾灯通常是黄色，天空为什么是蓝色的等等现象的原因。</p> <p>知道了这一点，太阳光色温变化的规律和原因也就可以理解和分析了，留给大家自己思考。</p> <p>&nbsp;</p> <p>&nbsp;</p> <p><strong>1.1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色温变化时的色彩校正</strong></p> <p>所以从理论上可以看出，随着色温的升高，要对色温进行较正，否则，物体在这样的光线条件下所表现出来的颜色就会偏离其正常的颜色，因此需要降低 sensor对红色的增益，增加sersor对蓝光的增益。同时在调整参数时一定程度上要考虑到整体亮度的要保持大致的不变，即以YUV来衡量时，Y值要&nbsp;基本保持不变，理论上认为可以参考RGB-&gt;YUV变换公式中，RGB三分量对Y值的贡献，从而确定RGAIN和BGAIN的变化的比例关系。但实&nbsp;际情况比这还要复杂一些，要考虑到不同sensor对R,B的感光的交叉影响和非线性，所以最佳值可能和理论值会有一些偏差。</p> <p><strong>1.1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动白平衡原理</strong></p> <p><strong>1.1.2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理</strong></p> <p>自动白平衡是基于假设场景的色彩的平均值落在一个特定的范围内，如果测量得到结果偏离该范围，则调整对应参数，校正直到其均值落入指定范围。该&nbsp;处理过程可能基于YUV空间，也可能基于RGB空间来进行。对于Sensor来说，通常的处理方式是通过校正R/B增益，使得UV值落在一个指定的范围&nbsp;内。从而实现自动白平衡。</p> <p>&nbsp;</p> <p><strong>1.1.2.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特殊情况的处理</strong></p> <p>在自动白平衡中，容易遇到的问题是，如果拍摄的场景，排除光线色温的影响，其本身颜色就是偏离平均颜色值的，比如大面积的偏向某种颜色的图案如：草地，红旗，蓝天等等，这时候，强制白平衡将其平均颜色调整到灰色附近，图像颜色就会严重失真。</p> <p>因此，通常的做法是：在处理自动白平衡时，除了做为目标结果的预期颜色范围外，另外再设置一对源图像的颜色范围阙值，如果未经处理的图像其颜色均值超出了该阙值的话，根本就不对其做自动白平衡处理。由此保证了上述特殊情况的正确处理。</p> <p>可见，这两对阙值的确定对于自动白平衡的效果起着关键性的作用。</p> <p><strong>1.1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某平台的例子</strong></p> <p>英文代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中文界面&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色温&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;色温&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RGAIN, GGAIN,&nbsp;&nbsp; BGAIN</p> <p>cloud&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阴天&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7500k &nbsp; 0x1D4C, 0x00CD, 0x0085, 0x0080</p> <p>daylight &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日光&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6500k &nbsp; 0x1964, 0x00A3, 0x0080, 0x0088</p> <p>INCANDESCENCE&nbsp;&nbsp;&nbsp;白热光&nbsp;&nbsp;&nbsp; 5000k &nbsp; 0x1388, 0x00A5, 0x0080, 0x0088</p> <p>FLUORESCENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日光灯&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4400k &nbsp; 0x1130, 0x0098, 0x0080, 0x00A8</p> <p>TUNGSTEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;钨丝灯&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2800k &nbsp; 0x0AF0, 0x0080, 0x0081, 0x00A4</p> <p>&nbsp;</p> <p>可以看到随着色温的升高，其变化规律基本符合上节中的理论分析。不过这里多数参数与理论值都有一些偏差，其中日光灯的色温参数设置与理论值有较&nbsp;大的偏差，实际效果也证明该日光灯的参数设置使得在家用日光灯环境下拍摄得到的照片颜色偏蓝。修改其参数后实拍效果明显改善。（再查一些资料可以看到通常&nbsp;会有两种荧光灯色温 4000 和 5000K，目前我所接触到的应该是5000K居多）</p> <p><strong>1.1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调试和验证</strong></p> <p>具体参数的调整，应该在灯箱环境下，使用各种已知色温的标准光源对标准色卡拍摄，在Pc机上由取色工具测量得到其与标准色板的RGB分量上的色彩偏差，相应的调整各分量增益的比例关系。为了更精确的得到结果，曝光量增益的设置在此之前应该相对准确的校正过<br /><br /><strong>颜色相关特效处理</strong></p> <p><strong>1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grayscale （灰阶）</strong></p> <p>灰阶图的效果就是将彩色图片转换为黑白图片。</p> <p><strong>1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论</strong></p> <p>理论上，在YUV空间，将UV分量丢弃，只保留Y分量，这样就可以得到黑白图像，这也是彩色电式机信号能兼容黑白电视机的原理。如下图理论上Y值一样的颜色（右边是用acdsee转成灰度图的效果），在grayscale模式下看应该是一样的颜色。</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/cee8794faf9e4d868c4faeb438e3bb35.png\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/16b74b065fb7435aadbd847b45391998.png\" style=\"max-width:500px;\" /></p> <p>算法上的操作，理论上应该把UV值改成灰色对应数值就可以了。不过根据软件算法和硬件结构的不同，具体代码也会有不同。</p> <p><strong>1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以某平台为例</strong></p> <p>核心的两行代码如下：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET_HUE_U_GAIN(0);</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET_HUE_V_GAIN(0);</p> <p>这里设置UV GAIN为0，如果UV offset设置为128的话，最终得到的UV就是128，这就和理论是相符合的。</p> <p><strong>1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sepia / sepiagreen / sepiablue</strong></p> <p>所谓的复古（绿，蓝）就是在灰阶的基础上，对UV值额外再做了一个offset，将灰度图转换成某种颜色的梯度图。理论上为了获得蓝色效果，应该增加蓝色差信号，减小红色差信号。即增大U，减小V。</p> <p>以sepiablue效果为例，这里的字节的MSB表示符号位：所以88为88，158为-30。</p> <p>&nbsp;&nbsp;&nbsp; SET_HUE_U_GAIN(0);&nbsp;</p> <p>&nbsp;&nbsp;&nbsp; SET_HUE_V_GAIN(0);&nbsp;</p> <p>&nbsp;&nbsp;&nbsp; SET_HUE_U_OFFSET(88);</p> <p>&nbsp;&nbsp;&nbsp; SET_HUE_V_OFFSET(158);</p> <p>&nbsp;<img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/f9a51290716543fc9054c355268d4ad2.png\" style=\"max-width:500px;\" />&nbsp;&nbsp;<img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/edcdce90409a40508c4bec17e0ebcad5.png\" style=\"max-width:500px;\" /></p> <p><strong>1.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;negative</strong></p> <p>所谓负片效果，就是将图像的颜色反转，看起来就像是在看胶片底片时的效果。这从理论上也很容易理解和处理，就是在RGB空间，取其补色，具体的操作就是用255分别减去RGB得到新的RGB值。通常会在ISP中实现该功能。</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/8bb122c0e05c4be595eaf05fdbcf5dd5.jpg\" style=\"max-width:500px;\" />&nbsp;&nbsp;<img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/d2a4690a9e88409492042c35ab9748e1.jpg\" style=\"max-width:500px;\" /></p> <p><strong>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小结</strong></p> <p>理解了原理，要做出其它颜色变换方面的效果就很容易了。</p> <p>基本上，在颜色校正和处理方面，需要考虑的相关参数大致包括：</p> <p>自动WB上下限，自动白平衡时的目标范围，RGB gain, UV gain, UV offset, color correction.有些还会有saturation 和 hue相关的设置。</p> <p>从sensor或ISP硬件处理的流程上说，通常方向是先做RGB gain，再做color correction,最后做YUV空间的处理。所以调整效果的时候，为了减少参数之间的相互影响，基本上也可以按这个顺序来调整参数。<br /><br /><br /></p> <p><strong>1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;亮度感应及曝光</strong></p> <p><strong>1.1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感光宽容度</strong></p> <p>从最明亮到最黑暗，假设人眼能够看到一定的范围，那么胶片（或CCD等电子感光器件）所能表现的远比人眼看到的范围小的多，而这个有限的范围就是感光宽容度。</p> <p>人眼的感光宽容度比胶片要高很多，而胶片的感光宽容度要比数码相机的ccd高出很多！了解这个概念之后，我们就不难了解，为什么在逆光的条件&nbsp;下，人眼能看清背光的建筑物以及耀眼的天空云彩。而一旦拍摄出来，要么就是云彩颜色绚烂而建筑物变成了黑糊糊的剪影，要么就是建筑物色彩细节清楚而原本美&nbsp;丽的云彩却成了白色的一片</p> <p>再看人眼的结构，有瞳孔可以控制通光量，有杆状感光细胞和椎状感光细胞以适应不同的光强，可见即使人眼有着很高的感光宽容度，依然有亮度调节系统，以适应光强变化。</p> <p>那么对于camera sensor来说，正确的曝光就更为重要了！</p> <p><strong>1.1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动曝光和18%灰</strong></p> <p>对于sensor来说，又是如何来判断曝光是否正确呢？很标准的做法就是在YUV空间计算当前图像的Y值的均值。调节各种曝光参数设定（自动或手动），使得该均值落在一个目标值附近的时候，就认为得到了正确的曝光。</p> <p>那么如何确定这个Y的均值，以及如何调整参数使得sensor能够将当前图像的亮度调整到这个范围呢？</p> <p>这就涉及到一个概念 18%灰，一般认为室内室外的景物，在通常的情况下，其平均的反光系数大约为18%，而色彩均值，如前所述，可以认为是一种中灰的色调。这样，可以通过对&nbsp;反光率为18%的灰板拍摄，调整曝光参数，使其颜色接近为中等亮度的灰色（Y值为128）。然后，对于通常的景物，就能自动的得到正确的曝光了。</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/db3139a4c5ac4a149d53f30659f9247d.jpg\" style=\"max-width:500px;\" /></p> <p>&nbsp;</p> <p>当然这种自动判断曝光参数的AE功能不是万能的，对于反光率偏离通常均值的场景，比如雪景，夜景等，用这种方法就无法得到正确的曝光量了。所以在sensor的软件处理模块中，通常还会提供曝光级别的设定功能，强制改变自动曝光的判断标准。比如改变预期的亮度均值等。</p> <p><strong>1.1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;曝光级别设定</strong></p> <p>在多数数码相机和拍照手机上都可以看到曝光级别设定的功能，如前所述，这种设定实际上是在自动曝光的基础上给用户提供一定的曝光控制能力，强制改变camera sensor的曝光判断标准，获得用户想要的效果。</p> <p>通常的做法就是改变Y值均值的预期值，使得sensor在自动曝光时以新的Y预期值为目标，自动调整Exptime 和 AG。</p> <p><strong>1.1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gamma校正</strong></p> <p>曝光的均值正确了，不代表整体图像的亮度分布就和人眼所看到的保持一致了。</p> <p>事实上，人眼对亮度的响应并不是一个线性的比例关系，而各种涉及到光电转换的设备的输入输出特性曲线一般也是非线性的，且表现为幂函数的形式：<strong>y</strong><strong>＝x</strong><strong>n&nbsp;,&nbsp;</strong>所以整个图像系统的传递函数是一个幂函数。g＝&nbsp;g1&times;g2&times;…&times;gn</p> <p>对于sensor来说，其响应倒是接近为线性关系，所以为了在各种设备上正确输出符合人眼对亮度的响应的图像，就需要进行校正。</p> <p>幂函数的指数的倒数就是通常所说的gamma值。</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/a06263c1236946edb92fb75e9ac36716.png\" style=\"max-width:500px;\" /></p> <p>归一化的gamma曲线</p> <p>校正的函数可以表示为&nbsp;<img src=\"http://writeblog.csdn.net/Editor/FCKeditor/editor/%3Chtml%3E%20%20%20%20%3Chead%3E%20%20%20%20%20%20%20%20%3Ctitle%3E%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?/title%3E%20%20%20%20%20%20%20%20%3Cstyle%3E%20%20%20%20%20%20%20%20%20body%20%7Bfont-family:%22Verdana%22;font-weight:normal;font-size:%20.7em;color:black;%7D%20%20%20%20%20%20%20%20%20%20p%20%7Bfont-family:%22Verdana%22;font-weight:normal;color:black;margin-top:%20-5px%7D%20%20%20%20%20%20%20%20%20b%20%7Bfont-family:%22Verdana%22;font-weight:bold;color:black;margin-top:%20-5px%7D%20%20%20%20%20%20%20%20%20H1%20%7B%20font-family:%22Verdana%22;font-weight:normal;font-size:18pt;color:red%20%7D%20%20%20%20%20%20%20%20%20H2%20%7B%20font-family:%22Verdana%22;font-weight:normal;font-size:14pt;color:maroon%20%7D%20%20%20%20%20%20%20%20%20pre%20%7Bfont-family:%22Lucida%20Console%22;font-size:%20.9em%7D%20%20%20%20%20%20%20%20%20.marker%20%7Bfont-weight:%20bold;%20color:%20black;text-decoration:%20none;%7D%20%20%20%20%20%20%20%20%20.version%20%7Bcolor:%20gray;%7D%20%20%20%20%20%20%20%20%20.error%20%7Bmargin-bottom:%2010px;%7D%20%20%20%20%20%20%20%20%20.expandable%20%7B%20text-decoration:underline;%20font-weight:bold;%20color:navy;%20cursor:hand;%20%7D%20%20%20%20%20%20%20%20%3C/style%3E%20%20%20%20%3C/head%3E%20%20%20%20%3Cbody%20bgcolor=%22white%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cspan%3E%3Cdiv%3E%3Cb%3E%3Cfont%20size=%226%22%3E%E9%88%A5?%E9%88%A5%E6%BF%86%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%8E%E8%85%91%E9%90%A8%E5%8B%AC%E6%B9%87%E9%8D%94%E2%80%B3%E6%AB%92%E9%96%BF%E6%AC%92%EE%87%A4%E9%8A%86?hr%20width=100%%20size=1%20color=silver%3E%3C/font%3E%3C/b%3E%3C/div%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cdiv%3E%3Cb%3E%3Cfont%20size=%225%22%3E%20%3Ci%3E%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?/i%3E%20%3C/font%3E%3C/b%3E%3C/div%3E%3C/span%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cfont%20face=%22Arial,%20Helvetica,%20Geneva,%20SunSans-Regular,%20sans-serif%20%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%20%E7%92%87%E5%AD%98%E6%A7%91:%20%3C/b%3E%E9%8E%B5%D1%86%EE%94%91%E8%A4%B0%E6%92%B3%E5%A2%A0%20Web%20%E7%92%87%E9%94%8B%E7%9C%B0%E9%8F%88%E7%86%BC%E6%A3%BF%E9%94%9B%E5%B1%BD%E5%9A%AD%E9%90%9C%E7%89%88%E6%B9%AD%E6%BE%B6%E5%8B%AD%E6%82%8A%E9%90%A8%E5%8B%AB%E7%B4%93%E7%94%AF%E6%90%9E%E2%82%AC%E5%82%9D%EE%87%AC%E5%A6%AB%E2%82%AC%E9%8F%8C%E3%83%A5%E7%88%A2%E9%8F%8D%E5%A0%A3%E7%AA%A1%E9%9F%AA%EE%81%83%E4%BF%8A%E9%8E%AD%EE%88%A4%E7%B4%9D%E6%B5%A0%E3%83%A4%E7%B0%A1%E7%91%99%EF%BD%86%E6%B9%81%E9%8D%8F%E5%AE%A0%EE%87%9A%E9%96%BF%E6%AC%92%EE%87%A4%E6%B5%A0%E3%83%A5%E5%BC%B7%E6%B5%A0%EF%BD%87%E7%88%9C%E6%B6%93%EE%85%9E%EE%87%B1%E9%91%B7%E6%92%AE%E6%95%8A%E7%92%87%EE%88%9C%E6%AE%91%E9%8D%91%E5%93%84%EE%98%A9%E9%90%A8%E5%8B%AE%EE%87%9B%E7%BC%81%E5%97%95%E4%BF%8A%E9%8E%AD%EE%88%98%E2%82%AC?%20%20%20%20%20%20%20%20%20%20%20%20%3Cbr%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%20%E5%AF%AE%E5%82%9A%E7%88%B6%E7%92%87%EF%B8%BE%E7%B2%8F%E6%B7%87%E2%84%83%E4%BC%85:%20%3C/b%3ESystem.ArgumentException:%20%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?br%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%E5%A9%A7%E6%84%B0%E6%95%8A%E7%92%87?%3C/b%3E%20%3Cbr%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Ctable%20width=100%%20bgcolor=%22#ffffcc%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctr%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctd%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ccode%3E%E9%8D%99%EE%81%85%E6%B9%81%E9%8D%A6%E3%84%A8%E7%9A%9F%E7%92%87%E6%9B%9F%C4%81%E5%AF%AE%E5%BF%8E%E7%AC%85%E6%9D%A9%E6%B6%9C%EE%94%91%E7%BC%82%E6%A0%AC%E7%98%A7%E9%8F%83%E8%AE%B9%E7%B4%9D%E9%90%A2%E7%86%B8%E5%9E%9A%E5%A7%9D%E3%82%86%E6%B9%AD%E6%BE%B6%E5%8B%AD%E6%82%8A%E5%AF%AE%E5%82%9A%E7%88%B6%E9%90%A8%E5%8B%AC%E7%B0%AE%E6%B5%A0%EF%BD%87%E7%88%9C%E9%8E%B5%E5%B6%84%E7%B4%B0%E9%8F%84%E5%89%A7%E3%81%9A%E9%8D%91%E7%83%98%E6%BD%B5%E9%8A%86%E5%82%9D%E5%AB%A2%E7%91%95%E4%BD%B8%E6%83%8E%E9%90%A2%E3%84%A6%EE%84%9D%E9%8D%94%E7%86%BB%E5%85%98%E9%94%9B%E5%B2%83%EE%87%AC%E9%8E%B5%D1%86%EE%94%91%E6%B5%A0%E3%83%A4%E7%AC%85%E5%A7%9D%E3%83%A9%EE%80%83%E6%B6%94%E5%AC%A9%E7%AB%B4%E9%94%9B%E5%B2%80%E5%8A%A7%E9%8D%9A%E5%BA%A4%EE%87%AC%E5%A7%B9?URL:%20%3Cbr%3E%3Cbr%3E1.%20%E9%8D%A6%E3%84%A4%E9%AA%87%E9%90%A2%E7%86%BC%E6%95%8A%E7%92%87%EE%88%9C%E6%AE%91%E9%8F%82%E5%9B%A6%E6%AC%A2%E9%90%A8%E5%8B%AF%E3%80%8A%E9%96%AE%E3%84%A6%E5%9D%8A%E9%8D%94%E7%8A%B1%E7%AB%B4%E9%8F%89%E2%99%80%E2%82%AC%E6%B7%92ebug=true%E9%88%A5%E6%BF%87%E5%AF%9A%E6%B5%A0%E3%82%83%E2%82%AC%E5%82%99%E7%B7%A5%E6%BF%A1?%20%3Cbr%3E%3Cbr%3E%20%C2%A0%C2%A0%3C%@%20Page%20Language=%22C%22%20Debug=%22true%22%20%%3E%3Cbr%3E%3Cbr%3E%E9%8E%B4?%3Cbr%3E%3Cbr%3E2.%20%E7%81%8F%E5%97%95%E4%BA%92%E6%B6%93%E5%AC%AC%E6%AE%91%E9%91%BA%E5%82%9B%E5%9D%8A%E9%8D%94%E7%8A%B2%E5%9F%8C%E6%90%B4%E6%97%82%E6%95%A4%E7%BB%8B%E5%AC%AA%E7%B0%AD%E9%90%A8%E5%8B%AF%E5%8E%A4%E7%BC%83%EE%86%BD%E6%9E%83%E6%B5%A0%E6%9C%B5%E8%85%91:%3Cbr%3E%3Cbr%3E%3Cconfiguration%3E%3Cbr%3E%20%C2%A0%C2%A0%C2%A0%3Csystem.web%3E%3Cbr%3E%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3Ccompilation%20debug=%22true%22/%3E%3Cbr%3E%20%C2%A0%C2%A0%C2%A0%3C/system.web%3E%3Cbr%3E%3C/configuration%3E%3Cbr%3E%3Cbr%3E%20%E7%92%87%E9%94%8B%E6%95%9E%E9%8E%B0%E5%BF%A5%E7%B4%9D%E7%BB%97%EE%83%BF%E7%B0%A9%E6%B6%93%EE%81%85%EE%84%9E%E6%A5%A0%E3%82%85%E7%9A%A2%E6%B5%A3%E8%B7%A8%E7%B2%B0%E7%80%B9%E6%B0%AC%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%8E%E8%85%91%E9%90%A8%E5%8B%AC%E5%A2%8D%E9%8F%88%E5%A4%8B%E6%9E%83%E6%B5%A0%E8%B7%BA%E6%B9%AA%E7%92%8B%E5%86%AD%E7%98%AF%E5%A6%AF%E2%80%B3%E7%B4%A1%E6%B6%93%E5%AC%AD%E7%B9%98%E7%90%9B%E5%B2%80%E7%B4%AA%E7%92%87%E6%88%AF%E7%B4%B1%E7%BB%97%EE%83%BF%E7%AB%B4%E6%B6%93%EE%81%85%EE%84%9E%E6%A5%A0%E3%82%84%E7%B2%8E%E6%B5%A3%E8%83%AF%EE%87%9A%E9%90%97%E7%91%B0%E7%95%BE%E9%8F%82%E5%9B%A6%E6%AC%A2%E9%8D%A6%E3%84%A8%E7%9A%9F%E7%92%87%E6%9B%9F%C4%81%E5%AF%AE%E5%BF%8E%E7%AC%85%E6%9D%A9%E6%B6%9C%EE%94%91%E7%BC%82%E6%A0%AC%E7%98%A7%E9%8A%86?br%3E%3Cbr%3E%E9%96%B2%E5%B6%88%EE%9B%A6%E6%B5%9C%E5%AC%AE%E3%80%8D:%20%E6%B5%A0%E3%83%A8%E7%9A%9F%E7%92%87%E6%9B%9F%C4%81%E5%AF%AE%E5%BF%9A%E7%B9%8D%E7%90%9B%E5%B1%BD%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%8E%E7%AB%B4%E7%80%B9%E6%B0%AB%E7%B4%B0%E6%B5%9C%D1%85%E6%95%93%E9%8D%90%E5%91%AD%E7%93%A8/%E9%8E%AC%D1%86%E5%85%98%E7%BB%AF%E8%8D%A4%E7%B2%BA%E5%AF%AE%E2%82%AC%E9%96%BF%E2%82%AC%E9%8A%86%E5%82%9A%E6%B9%AA%E9%96%AE%E3%84%A7%E8%AE%B2%E9%8D%92%E6%89%AE%E6%95%93%E6%B5%9C%D1%84%E6%9F%9F%E5%A6%97%E5%A0%9C%E7%AE%A3%E9%8D%93%E5%B6%8F%E7%B4%9D%E6%90%B4%E6%97%82%E2%80%98%E6%B7%87%E6%BF%86%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%9A%E7%9A%9F%E7%92%87%E6%9B%9E%E5%87%A1%E7%BB%82%E4%BD%BA%E6%95%A4%E9%8A%86?/code%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/td%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/tr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3C/table%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%E9%8D%AB%E5%97%98%E7%88%A4%E7%92%BA%E7%86%BB%E9%87%9C:%3C/b%3E%20%3Cbr%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Ctable%20width=100%%20bgcolor=%22ffffcc%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctr%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctd%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ccode%3E%3Cpre%3E[ArgumentException:%20%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86%E4%BF%94%20%20%20System.Drawing.Image.FromStream%28Stream%20stream,%20Boolean%20useEmbeddedColorManagement,%20Boolean%20validateImageData%29%20+388134%20%20%20System.Drawing.Image.FromStream%28Stream%20stream%29%20+8%20%20%20Dottext.Admin.UploadWord.SaveFile%28HttpPostedFile%20File%29%20+32%20%20%20Dottext.Admin.UploadWord.Page_Load%28Object%20sender,%20EventArgs%20e%29%20+76%20%20%20System.Web.Util.CalliHelper.EventArgFunctionCaller%28IntPtr%20fp,%20Object%20o,%20Object%20t,%20EventArgs%20e%29%20+15%20%20%20System.Web.Util.CalliEventHandlerDelegateProxy.Callback%28Object%20sender,%20EventArgs%20e%29%20+34%20%20%20System.Web.UI.Control.OnLoad%28EventArgs%20e%29%20+99%20%20%20System.Web.UI.Control.LoadRecursive%28%29%20+47%20%20%20System.Web.UI.Page.ProcessRequestMain%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29%20+1061%3C/pre%3E%3C/code%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/td%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/tr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3C/table%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Chr%20width=100%%20size=1%20color=silver%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%E9%90%97%E5%A0%9F%E6%B9%B0%E6%B7%87%E2%84%83%E4%BC%85:%3C/b%3E%C2%A0Microsoft%20.NET%20Framework%20%E9%90%97%E5%A0%9F%E6%B9%B0:2.0.50727.832;%20ASP.NET%20%E9%90%97%E5%A0%9F%E6%B9%B0:2.0.50727.832%20%20%20%20%20%20%20%20%20%20%20%20%3C/font%3E%20%20%20%20%3C/body%3E%3C/html%3E%3C%21--%20[ArgumentException]:%20%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?%20%20%20%E9%8D%A6?System.Drawing.Image.FromStream%28Stream%20stream,%20Boolean%20useEmbeddedColorManagement,%20Boolean%20validateImageData%29%20%20%20%E9%8D%A6?System.Drawing.Image.FromStream%28Stream%20stream%29%20%20%20%E9%8D%A6?Dottext.Admin.UploadWord.SaveFile%28HttpPostedFile%20File%29%20%20%20%E9%8D%A6?Dottext.Admin.UploadWord.Page_Load%28Object%20sender,%20EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.Util.CalliHelper.EventArgFunctionCaller%28IntPtr%20fp,%20Object%20o,%20Object%20t,%20EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.Util.CalliEventHandlerDelegateProxy.Callback%28Object%20sender,%20EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.UI.Control.OnLoad%28EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.UI.Control.LoadRecursive%28%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequestMain%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29[HttpUnhandledException]:%20%E5%AF%AE%E6%9B%9E%E5%BD%82%E7%BB%AB%E8%AF%B2%E7%80%B7%E6%B6%93%E8%A1%A1%E2%82%AC%E6%B7%AAystem.Web.HttpUnhandledException%E9%88%A5%E6%BF%88%E6%AE%91%E5%AF%AE%E5%82%9A%E7%88%B6%E9%8A%86?%20%20%20%E9%8D%A6?System.Web.UI.Page.HandleError%28Exception%20e%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequestMain%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequest%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequest%28%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequestWithNoAssert%28HttpContext%20context%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequest%28HttpContext%20context%29%20%20%20%E9%8D%A6?ASP.uploadword_aspx.ProcessRequest%28HttpContext%20context%29%20%20%20%E9%8D%A6?System.Web.HttpApplication.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute%28%29%20%20%20%E9%8D%A6?System.Web.HttpApplication.ExecuteStep%28IExecutionStep%20step,%20Boolean&amp;%20completedSynchronously%29--%3E%3C%21--%20%E5%A7%9D%E3%82%89%E6%95%8A%E7%92%87%EE%88%9E%E3%80%89%E9%8D%99%EE%88%9D%E5%85%98%E9%8D%96%E5%91%AD%E6%83%88%E9%8F%81%E5%BF%94%E5%8A%85%E6%B7%87%E2%84%83%E4%BC%85%E9%94%9B%E5%B1%BD%E6%B4%9C%E6%B6%93?ASP.NET%20%E9%96%AB%E6%B0%B3%E7%B9%83%20%3CcustomErrors%20mode=\" style=\"max-width:500px;\" />'&gt;1，通常对于Window的输出显示系统，gamma值为2.2，而对于苹果的输出显示系统和打印系统来说，gamma值为1.8。</p> <p>实际上，sensor在做gamma校正的时候，通常也一并作了从raw格式的10bit的数据到8bit数据的转换，所以这时候的公式可以表示为&nbsp;<img src=\"http://blog.csdn.net/colorant/archive/2007/12/03/%3Chtml%3E%20%20%20%20%3Chead%3E%20%20%20%20%20%20%20%20%3Ctitle%3E%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?/title%3E%20%20%20%20%20%20%20%20%3Cstyle%3E%20%20%20%20%20%20%20%20%20body%20%7Bfont-family:%22Verdana%22;font-weight:normal;font-size:%20.7em;color:black;%7D%20%20%20%20%20%20%20%20%20%20p%20%7Bfont-family:%22Verdana%22;font-weight:normal;color:black;margin-top:%20-5px%7D%20%20%20%20%20%20%20%20%20b%20%7Bfont-family:%22Verdana%22;font-weight:bold;color:black;margin-top:%20-5px%7D%20%20%20%20%20%20%20%20%20H1%20%7B%20font-family:%22Verdana%22;font-weight:normal;font-size:18pt;color:red%20%7D%20%20%20%20%20%20%20%20%20H2%20%7B%20font-family:%22Verdana%22;font-weight:normal;font-size:14pt;color:maroon%20%7D%20%20%20%20%20%20%20%20%20pre%20%7Bfont-family:%22Lucida%20Console%22;font-size:%20.9em%7D%20%20%20%20%20%20%20%20%20.marker%20%7Bfont-weight:%20bold;%20color:%20black;text-decoration:%20none;%7D%20%20%20%20%20%20%20%20%20.version%20%7Bcolor:%20gray;%7D%20%20%20%20%20%20%20%20%20.error%20%7Bmargin-bottom:%2010px;%7D%20%20%20%20%20%20%20%20%20.expandable%20%7B%20text-decoration:underline;%20font-weight:bold;%20color:navy;%20cursor:hand;%20%7D%20%20%20%20%20%20%20%20%3C/style%3E%20%20%20%20%3C/head%3E%20%20%20%20%3Cbody%20bgcolor=%22white%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cspan%3E%3Cdiv%3E%3Cb%3E%3Cfont%20size=%226%22%3E%E9%88%A5?%E9%88%A5%E6%BF%86%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%8E%E8%85%91%E9%90%A8%E5%8B%AC%E6%B9%87%E9%8D%94%E2%80%B3%E6%AB%92%E9%96%BF%E6%AC%92%EE%87%A4%E9%8A%86?hr%20width=100%%20size=1%20color=silver%3E%3C/font%3E%3C/b%3E%3C/div%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cdiv%3E%3Cb%3E%3Cfont%20size=%225%22%3E%20%3Ci%3E%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?/i%3E%20%3C/font%3E%3C/b%3E%3C/div%3E%3C/span%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cfont%20face=%22Arial,%20Helvetica,%20Geneva,%20SunSans-Regular,%20sans-serif%20%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%20%E7%92%87%E5%AD%98%E6%A7%91:%20%3C/b%3E%E9%8E%B5%D1%86%EE%94%91%E8%A4%B0%E6%92%B3%E5%A2%A0%20Web%20%E7%92%87%E9%94%8B%E7%9C%B0%E9%8F%88%E7%86%BC%E6%A3%BF%E9%94%9B%E5%B1%BD%E5%9A%AD%E9%90%9C%E7%89%88%E6%B9%AD%E6%BE%B6%E5%8B%AD%E6%82%8A%E9%90%A8%E5%8B%AB%E7%B4%93%E7%94%AF%E6%90%9E%E2%82%AC%E5%82%9D%EE%87%AC%E5%A6%AB%E2%82%AC%E9%8F%8C%E3%83%A5%E7%88%A2%E9%8F%8D%E5%A0%A3%E7%AA%A1%E9%9F%AA%EE%81%83%E4%BF%8A%E9%8E%AD%EE%88%A4%E7%B4%9D%E6%B5%A0%E3%83%A4%E7%B0%A1%E7%91%99%EF%BD%86%E6%B9%81%E9%8D%8F%E5%AE%A0%EE%87%9A%E9%96%BF%E6%AC%92%EE%87%A4%E6%B5%A0%E3%83%A5%E5%BC%B7%E6%B5%A0%EF%BD%87%E7%88%9C%E6%B6%93%EE%85%9E%EE%87%B1%E9%91%B7%E6%92%AE%E6%95%8A%E7%92%87%EE%88%9C%E6%AE%91%E9%8D%91%E5%93%84%EE%98%A9%E9%90%A8%E5%8B%AE%EE%87%9B%E7%BC%81%E5%97%95%E4%BF%8A%E9%8E%AD%EE%88%98%E2%82%AC?%20%20%20%20%20%20%20%20%20%20%20%20%3Cbr%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%20%E5%AF%AE%E5%82%9A%E7%88%B6%E7%92%87%EF%B8%BE%E7%B2%8F%E6%B7%87%E2%84%83%E4%BC%85:%20%3C/b%3ESystem.ArgumentException:%20%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?br%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%E5%A9%A7%E6%84%B0%E6%95%8A%E7%92%87?%3C/b%3E%20%3Cbr%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Ctable%20width=100%%20bgcolor=%22#ffffcc%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctr%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctd%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ccode%3E%E9%8D%99%EE%81%85%E6%B9%81%E9%8D%A6%E3%84%A8%E7%9A%9F%E7%92%87%E6%9B%9F%C4%81%E5%AF%AE%E5%BF%8E%E7%AC%85%E6%9D%A9%E6%B6%9C%EE%94%91%E7%BC%82%E6%A0%AC%E7%98%A7%E9%8F%83%E8%AE%B9%E7%B4%9D%E9%90%A2%E7%86%B8%E5%9E%9A%E5%A7%9D%E3%82%86%E6%B9%AD%E6%BE%B6%E5%8B%AD%E6%82%8A%E5%AF%AE%E5%82%9A%E7%88%B6%E9%90%A8%E5%8B%AC%E7%B0%AE%E6%B5%A0%EF%BD%87%E7%88%9C%E9%8E%B5%E5%B6%84%E7%B4%B0%E9%8F%84%E5%89%A7%E3%81%9A%E9%8D%91%E7%83%98%E6%BD%B5%E9%8A%86%E5%82%9D%E5%AB%A2%E7%91%95%E4%BD%B8%E6%83%8E%E9%90%A2%E3%84%A6%EE%84%9D%E9%8D%94%E7%86%BB%E5%85%98%E9%94%9B%E5%B2%83%EE%87%AC%E9%8E%B5%D1%86%EE%94%91%E6%B5%A0%E3%83%A4%E7%AC%85%E5%A7%9D%E3%83%A9%EE%80%83%E6%B6%94%E5%AC%A9%E7%AB%B4%E9%94%9B%E5%B2%80%E5%8A%A7%E9%8D%9A%E5%BA%A4%EE%87%AC%E5%A7%B9?URL:%20%3Cbr%3E%3Cbr%3E1.%20%E9%8D%A6%E3%84%A4%E9%AA%87%E9%90%A2%E7%86%BC%E6%95%8A%E7%92%87%EE%88%9C%E6%AE%91%E9%8F%82%E5%9B%A6%E6%AC%A2%E9%90%A8%E5%8B%AF%E3%80%8A%E9%96%AE%E3%84%A6%E5%9D%8A%E9%8D%94%E7%8A%B1%E7%AB%B4%E9%8F%89%E2%99%80%E2%82%AC%E6%B7%92ebug=true%E9%88%A5%E6%BF%87%E5%AF%9A%E6%B5%A0%E3%82%83%E2%82%AC%E5%82%99%E7%B7%A5%E6%BF%A1?%20%3Cbr%3E%3Cbr%3E%20%C2%A0%C2%A0%3C%@%20Page%20Language=%22C#%22%20Debug=%22true%22%20%%3E%3Cbr%3E%3Cbr%3E%E9%8E%B4?%3Cbr%3E%3Cbr%3E2.%20%E7%81%8F%E5%97%95%E4%BA%92%E6%B6%93%E5%AC%AC%E6%AE%91%E9%91%BA%E5%82%9B%E5%9D%8A%E9%8D%94%E7%8A%B2%E5%9F%8C%E6%90%B4%E6%97%82%E6%95%A4%E7%BB%8B%E5%AC%AA%E7%B0%AD%E9%90%A8%E5%8B%AF%E5%8E%A4%E7%BC%83%EE%86%BD%E6%9E%83%E6%B5%A0%E6%9C%B5%E8%85%91:%3Cbr%3E%3Cbr%3E%3Cconfiguration%3E%3Cbr%3E%20%C2%A0%C2%A0%C2%A0%3Csystem.web%3E%3Cbr%3E%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%3Ccompilation%20debug=%22true%22/%3E%3Cbr%3E%20%C2%A0%C2%A0%C2%A0%3C/system.web%3E%3Cbr%3E%3C/configuration%3E%3Cbr%3E%3Cbr%3E%20%E7%92%87%E9%94%8B%E6%95%9E%E9%8E%B0%E5%BF%A5%E7%B4%9D%E7%BB%97%EE%83%BF%E7%B0%A9%E6%B6%93%EE%81%85%EE%84%9E%E6%A5%A0%E3%82%85%E7%9A%A2%E6%B5%A3%E8%B7%A8%E7%B2%B0%E7%80%B9%E6%B0%AC%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%8E%E8%85%91%E9%90%A8%E5%8B%AC%E5%A2%8D%E9%8F%88%E5%A4%8B%E6%9E%83%E6%B5%A0%E8%B7%BA%E6%B9%AA%E7%92%8B%E5%86%AD%E7%98%AF%E5%A6%AF%E2%80%B3%E7%B4%A1%E6%B6%93%E5%AC%AD%E7%B9%98%E7%90%9B%E5%B2%80%E7%B4%AA%E7%92%87%E6%88%AF%E7%B4%B1%E7%BB%97%EE%83%BF%E7%AB%B4%E6%B6%93%EE%81%85%EE%84%9E%E6%A5%A0%E3%82%84%E7%B2%8E%E6%B5%A3%E8%83%AF%EE%87%9A%E9%90%97%E7%91%B0%E7%95%BE%E9%8F%82%E5%9B%A6%E6%AC%A2%E9%8D%A6%E3%84%A8%E7%9A%9F%E7%92%87%E6%9B%9F%C4%81%E5%AF%AE%E5%BF%8E%E7%AC%85%E6%9D%A9%E6%B6%9C%EE%94%91%E7%BC%82%E6%A0%AC%E7%98%A7%E9%8A%86?br%3E%3Cbr%3E%E9%96%B2%E5%B6%88%EE%9B%A6%E6%B5%9C%E5%AC%AE%E3%80%8D:%20%E6%B5%A0%E3%83%A8%E7%9A%9F%E7%92%87%E6%9B%9F%C4%81%E5%AF%AE%E5%BF%9A%E7%B9%8D%E7%90%9B%E5%B1%BD%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%8E%E7%AB%B4%E7%80%B9%E6%B0%AB%E7%B4%B0%E6%B5%9C%D1%85%E6%95%93%E9%8D%90%E5%91%AD%E7%93%A8/%E9%8E%AC%D1%86%E5%85%98%E7%BB%AF%E8%8D%A4%E7%B2%BA%E5%AF%AE%E2%82%AC%E9%96%BF%E2%82%AC%E9%8A%86%E5%82%9A%E6%B9%AA%E9%96%AE%E3%84%A7%E8%AE%B2%E9%8D%92%E6%89%AE%E6%95%93%E6%B5%9C%D1%84%E6%9F%9F%E5%A6%97%E5%A0%9C%E7%AE%A3%E9%8D%93%E5%B6%8F%E7%B4%9D%E6%90%B4%E6%97%82%E2%80%98%E6%B7%87%E6%BF%86%E7%B0%B2%E9%90%A2%E3%84%A7%E2%96%BC%E6%90%B4%E5%BF%9A%E7%9A%9F%E7%92%87%E6%9B%9E%E5%87%A1%E7%BB%82%E4%BD%BA%E6%95%A4%E9%8A%86?/code%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/td%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/tr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3C/table%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%E9%8D%AB%E5%97%98%E7%88%A4%E7%92%BA%E7%86%BB%E9%87%9C:%3C/b%3E%20%3Cbr%3E%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Ctable%20width=100%%20bgcolor=%22#ffffcc%22%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctr%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ctd%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Ccode%3E%3Cpre%3E[ArgumentException:%20%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86%E4%BF%94%20%20%20System.Drawing.Image.FromStream%28Stream%20stream,%20Boolean%20useEmbeddedColorManagement,%20Boolean%20validateImageData%29%20+388134%20%20%20System.Drawing.Image.FromStream%28Stream%20stream%29%20+8%20%20%20Dottext.Admin.UploadWord.SaveFile%28HttpPostedFile%20File%29%20+32%20%20%20Dottext.Admin.UploadWord.Page_Load%28Object%20sender,%20EventArgs%20e%29%20+76%20%20%20System.Web.Util.CalliHelper.EventArgFunctionCaller%28IntPtr%20fp,%20Object%20o,%20Object%20t,%20EventArgs%20e%29%20+15%20%20%20System.Web.Util.CalliEventHandlerDelegateProxy.Callback%28Object%20sender,%20EventArgs%20e%29%20+34%20%20%20System.Web.UI.Control.OnLoad%28EventArgs%20e%29%20+99%20%20%20System.Web.UI.Control.LoadRecursive%28%29%20+47%20%20%20System.Web.UI.Page.ProcessRequestMain%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29%20+1061%3C/pre%3E%3C/code%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/td%3E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C/tr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3C/table%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cbr%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Chr%20width=100%%20size=1%20color=silver%3E%20%20%20%20%20%20%20%20%20%20%20%20%3Cb%3E%E9%90%97%E5%A0%9F%E6%B9%B0%E6%B7%87%E2%84%83%E4%BC%85:%3C/b%3E%C2%A0Microsoft%20.NET%20Framework%20%E9%90%97%E5%A0%9F%E6%B9%B0:2.0.50727.832;%20ASP.NET%20%E9%90%97%E5%A0%9F%E6%B9%B0:2.0.50727.832%20%20%20%20%20%20%20%20%20%20%20%20%3C/font%3E%20%20%20%20%3C/body%3E%3C/html%3E%3C%21--%20[ArgumentException]:%20%E9%8D%99%E5%82%9B%E6%9A%9F%E9%8F%83%E7%8A%B3%E6%99%A5%E9%8A%86?%20%20%20%E9%8D%A6?System.Drawing.Image.FromStream%28Stream%20stream,%20Boolean%20useEmbeddedColorManagement,%20Boolean%20validateImageData%29%20%20%20%E9%8D%A6?System.Drawing.Image.FromStream%28Stream%20stream%29%20%20%20%E9%8D%A6?Dottext.Admin.UploadWord.SaveFile%28HttpPostedFile%20File%29%20%20%20%E9%8D%A6?Dottext.Admin.UploadWord.Page_Load%28Object%20sender,%20EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.Util.CalliHelper.EventArgFunctionCaller%28IntPtr%20fp,%20Object%20o,%20Object%20t,%20EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.Util.CalliEventHandlerDelegateProxy.Callback%28Object%20sender,%20EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.UI.Control.OnLoad%28EventArgs%20e%29%20%20%20%E9%8D%A6?System.Web.UI.Control.LoadRecursive%28%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequestMain%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29[HttpUnhandledException]:%20%E5%AF%AE%E6%9B%9E%E5%BD%82%E7%BB%AB%E8%AF%B2%E7%80%B7%E6%B6%93%E8%A1%A1%E2%82%AC%E6%B7%AAystem.Web.HttpUnhandledException%E9%88%A5%E6%BF%88%E6%AE%91%E5%AF%AE%E5%82%9A%E7%88%B6%E9%8A%86?%20%20%20%E9%8D%A6?System.Web.UI.Page.HandleError%28Exception%20e%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequestMain%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequest%28Boolean%20includeStagesBeforeAsyncPoint,%20Boolean%20includeStagesAfterAsyncPoint%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequest%28%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequestWithNoAssert%28HttpContext%20context%29%20%20%20%E9%8D%A6?System.Web.UI.Page.ProcessRequest%28HttpContext%20context%29%20%20%20%E9%8D%A6?ASP.uploadword_aspx.ProcessRequest%28HttpContext%20context%29%20%20%20%E9%8D%A6?System.Web.HttpApplication.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute%28%29%20%20%20%E9%8D%A6?System.Web.HttpApplication.ExecuteStep%28IExecutionStep%20step,%20Boolean&amp;%20completedSynchronously%29--%3E%3C%21--%20%E5%A7%9D%E3%82%89%E6%95%8A%E7%92%87%EE%88%9E%E3%80%89%E9%8D%99%EE%88%9D%E5%85%98%E9%8D%96%E5%91%AD%E6%83%88%E9%8F%81%E5%BF%94%E5%8A%85%E6%B7%87%E2%84%83%E4%BC%85%E9%94%9B%E5%B1%BD%E6%B4%9C%E6%B6%93?ASP.NET%20%E9%96%AB%E6%B0%B3%E7%B9%83%20%3CcustomErrors%20mode=%22Off%22/%3E%20%E7%90%9A%EE%82%A6%E5%8E%A4%E7%BC%83%EE%86%BB%E8%B4%9F%E9%8F%84%E5%89%A7%E3%81%9A%E7%92%87%EF%B8%BE%E7%B2%8F%E9%96%BF%E6%AC%92%EE%87%A4%E6%B7%87%E2%84%83%E4%BC%85%E9%8A%86%E5%82%9D%EE%87%AC%E9%91%B0%E5%86%AD%E6%AA%BB%E9%8D%A6%E3%84%A7%E6%95%93%E6%B5%9C%D1%85%E5%B9%86%E6%BE%A7%E5%86%A7%E8%85%91%E6%B5%A3%E8%B7%A8%E6%95%A4%20%3CcustomErrors%20mode=%22On%22/%3E%20%E9%8E%B4?%3CcustomErrors%20mode=%22RemoteOnly%22/%3E%E9%8A%86?-%3E%22%20alt=%22%22%20/%3E1%3C/span%3E%E3%80%82%3C/p%3E%3Cdiv%3E%E7%94%B1%E4%BA%8E%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E9%9C%80%E8%A6%81%E6%B6%88%E8%80%97%E5%A4%A7%E9%87%8F%E7%9A%84CPU%E6%97%B6%E9%97%B4%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%9E%E9%99%85%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%8C%E5%BE%80%E5%BE%80%E6%98%AF%E5%B0%86gamma%E6%9B%B2%E7%BA%BF%E7%94%A8%E6%AF%94%E5%A6%8212%E6%AE%B5%E7%BA%BF%E6%AE%B5%E8%BF%9B%E8%A1%8C%E6%8B%9F%E5%90%88%E3%80%82%E8%BF%99%E6%A0%B7%E5%8F%AA%E9%9C%80%E8%A6%81%E4%BF%9D%E5%AD%9813%E4%B8%AA%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%94%A8%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E6%88%96%E6%9F%A5%E8%A1%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8Cgamma%E6%A0%A1%E6%AD%A3%E3%80%82%E8%A6%81%E8%B0%83%E6%95%B4gamma%E6%A0%A1%E6%AD%A3%E5%AE%9E%E9%99%85%E4%B8%8A%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%B0%83%E6%95%B4%E8%BF%9913%E4%B8%AA%E7%82%B9%E7%9A%84%E6%95%B0%E5%80%BC%E3%80%82%3C/div%3E%3Cdiv%3E%E5%8E%9F%E5%88%99%E4%B8%8A%EF%BC%8C%E5%9C%A8%E6%8B%8D%E6%91%84%E5%A6%82%E4%B8%8B%E5%9B%BE%E7%81%B0%E9%98%B6%E7%9A%84%E8%89%B2%E6%9D%BF%E6%97%B6%EF%BC%8C%E8%83%BD%E5%88%86%E8%BE%A8%E5%87%BA%E7%9A%84%E7%BA%A7%E6%95%B0%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E3%80%82%3C/div%3E%3Cdiv%20style=%22MARGIN-TOP:%206pt%22%3E%3Cimg%20alt=%22%22%20src=%22http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/0e512796b90a4b21b342b52a58a667d3.gif%22%20/%3E%3C/div%3E%3Cdiv%3E%3Cstrong%3E%3Cfont%20size=%224%22%3E%3Cspan%3E1.1.5%3Cspan%20style=%22FONT:%207pt\" style=\"max-width:500px;\" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对比度</p> <p>对比度的调整在一定程度上说，其实也就是对gamma曲线的调整，增大对比度就是提高Gamma值。对于图像处理来说，也有在硬件gamma校正后，单独由软件再进行一次类似的幂函数变换来调整对比度。</p> <p><strong>1.1.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;曝光参数的调整</strong></p> <p>曝光强度的调整，可以通过改变曝光时间，也可以通过改变亮度增益AG来实现。</p> <p>曝光时间受到桢频的限制，比如摄像时要求15帧每秒的话，这时候曝光时间最长就不能超过1/15s，可能还有别的条件限制，实际的曝光时间还要短，在光线弱的情况下，单独调整曝光时间就无法满足帧频的需要了。</p> <p>这时候还可以调整增益AG，来控制曝光的增益，降低曝光时间。但是，这样做的缺点是以牺牲图像质量为代价的，AG的增强，伴随的必然是信噪比的降低，图像噪声的增强。</p>所以，以图像质量为优先考虑的时候，曝光参数的调节通常是优先考虑调节曝光时间，其次在考虑曝光增益。当然曝光时间也不能过长以免由于抖动造成图像的模糊，而在拍摄运动场景时，对曝光时间的要求就更高了 <br /> <br /> <br /> <br /> <p><strong>1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抗噪处理</strong></p> <p>AG 的增大，不可避免的带来噪点的增多，此外，如果光线较暗，曝光时间过长，也会增加噪点的数目（从数码相机上看，主要是因为长时间曝光，感光元件温度升高，&nbsp;电流噪声造成感光元件噪点的增多），而感光元件本身的缺陷也是噪点甚至坏点的来源之一。因此，通常sensor集成或后端的ISP都带有降噪功能的相关设&nbsp;置。</p> <p><strong>1.1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动时机</strong></p> <p>根据噪点形成的原因，主要是AG或Exptime超过一定值后需要启动降噪功能，因此通常需要确定这两个参数的阙值，过小和过大都不好。</p> <p>从下面的降噪处理的办法将会看到，降噪势附带的带来图像质量的下降，所以过早启动降噪功能，在不必要的情况下做降噪处理不但增加处理器或ISP的负担，还有可能适得其反。而过迟启动降噪功能，则在原本需要它的时候，起不到相应的作用。</p> <p><strong>1.1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判定原则和处理方式</strong></p> <p>那么如何判定一个点是否是噪点呢？我们从人是如何识别噪点的开始讨论，对于人眼来说，判定一个点是噪点，无外乎就是这一点的亮度或颜色与边上大&nbsp;部分的点差异过大。从噪点产生的机制来说，颜色的异常应该是总是伴随着亮度的异常，而且对亮度异常的处理工作量比颜色异常要小，所以通常sensor ISP的判定原则是一个点的亮度与周围点的亮度的差值大于一个阙值的时候，就认为该点是一个噪点。</p> <p>处理的方式，通常是对周围的点取均值来替代原先的值，这种做法并不增加信息量，类似于一个模糊算法。</p> <p>对于高端的数码相机，拥有较强的图像处理芯片，在判定和处理方面是否有更复杂的算法，估计也是有可能的。比如亮度和颜色综合作为标准来判定噪&nbsp;点，采用运算量更大的插值算法做补偿，对于sensor固有的坏点，噪点，采用屏蔽的方式抛弃其数据（Nikon就是这么做的，其它厂商应该也如此）等&nbsp;等。</p> <p><strong>1.1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;效果</strong></p> <p>对于手机sensor来说，这种降噪处理的作用有多大，笔者个人认为应该很有限，毕竟相对数码相机，手机sensor的镜头太小，通光量小，所&nbsp;以其基准AG势必就比相机的增益要大（比如相当于普通家用数码相机ISO800的水平），这样才能获得同样的亮度，所以电流噪声带来的影响也就要大得多。&nbsp;这样一来，即使最佳情况，噪点也会很多，数据本身的波动就很大，这也就造成我们在手机照片上势必会看到的密密麻麻的花点，如果全部做平均，降低了噪点的同&nbsp;时，图像也会变得模糊，所以手机噪点的判断阙值会设得比较高，以免涉及面过大，模糊了整体图像。这样一来一是数据本身就差，二是降噪的标准也降低了，造成&nbsp;总体效果不佳。</p> <p><strong>1.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数码变焦</strong></p> <p>数码变焦可以有两种形式：</p> <p>其一，是通过插值算法，对图像进行插值运算，将图像的尺寸扩大到所需的规格，这种算法就其效果而言，并不理想，尤其是当使用在手机上的时候，手&nbsp;机上的摄像头本身得到的数据就有较大的噪声，再插值的话，得到的图像几乎没法使用。实际上，即使是数码相机的数码变焦功能也没有太大的实用价值。如果插值&nbsp;算法没有硬件支持，则需要在应用层实现。我司某平台的数码变焦用的就是该种办法。</p> <p>&nbsp;</p> <p>其二，其实是一种伪数码变焦的形式，当摄像头不处在最大分辨率格式的情况下，比如130万像素的sensor使用640*480的规格拍照时，&nbsp;仍旧设置sersor工作在1280*960的分辨率下，而后通过采集中央部分的图像来获取640*480的照片，使得在手机上看来所拍物体尺寸被放大了&nbsp;一倍。也有很多手机采用的是这种数码变焦方式，这种办法几乎不需要额外的算法支持，对图像质量也没有影响，缺点是只有小尺寸情况下可以采用。此外在DV方&nbsp;式下也可以实现所谓的数码变焦放大拍摄功能。（这应该是一个卖点，对Dv来说，这种数码变焦还是有实际意义的）</p> <p>要采用这种变焦模式，驱动需要支持windowing功能，获取所需部分的sensor图像数据。</p> <p><strong>1.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;频闪抑制功能</strong></p> <p><strong>1.3.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;何谓频闪</strong></p> <p>日常使用的普通光源如白炽灯、日光灯、石英灯等都是直接用220/50Hz交流电工作，每秒钟内正负半周各变化50次，因而导致灯光在1秒钟内发生100（50&times;2）次的闪烁，再加上市电电压的不稳定，灯光忽明忽暗，这样就产生了所谓的“频闪”。</p> <p>下表显示了几种光源的光强波动情况：</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/b12c140a31644ea1a98d9423e0039a03.gif\" style=\"max-width:500px;\" /></p> <p>因为人眼对光强变化有一定的迟滞和适应性，所以通常看不出光源的亮度变化。但是依然还是会增加眼睛的疲劳程度。所以市场上才会有所谓的无频闪灯销售。</p> <p><strong>1.3.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对频闪的抑制</strong></p> <p>对于camera sensor来说，没有人眼的迟滞和适应过程，所以对光源亮度的变化是比较敏感的。如果不加抑制，在预览和DV模式下，可能会有明显的图像的明亮变化闪烁的现象发生。</p> <p>如何解决呢？考虑到频闪的周期性，在一个周期内，光源亮度的累积值，应该是大体一致的，所以，如果控制曝光的时间是频闪周期的整倍数，那么每一帧图像的亮度就大体是一致的了，这样就可以有效地抑制频闪对图像亮度的影响。</p> <p>所以，在自动曝光的模式下，sensor会根据频闪的频率，调整曝光时间为其周期的整倍数。&nbsp;因为各地的交流电的频率不同，所以有50Hz/60Hz之分。</p> <p>在具体设置相关Sensor寄存器的时候，要根据电流频率和sensor的时钟频率，分辨率等，计算出频闪周期对应的时钟周期数等。<br /><br /><br /><br /></p> <p><strong>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前言</strong></p> <p>&nbsp;</p> <p>自然界的颜色千变万化，为了给颜色一个量化的衡量标准，就需要建立色彩空间模型来描述各种各样的颜色，由于人对色彩的感知是一个复杂的生理和心&nbsp;理联合作用的过程，所以在不同的应用领域中为了更好更准确的满足各自的需求，就出现了各种各样的色彩空间模型来量化的描述颜色。我们比较常接触到的就包括 RGB / CMYK / YIQ / YUV / HSI等等。</p> <p>&nbsp;</p> <p>对于数字电子多媒体领域来说，我们经常接触到的色彩空间的概念，主要是RGB , YUV这两种（实际上，这两种体系包含了许多种具体的颜色表达方式和模型，如sRGB, Adobe RGB, YUV422, YUV420 …）, RGB是按三基色加光系统的原理来描述颜色，而YUV则是按照&nbsp;亮度，色差的原理来描述颜色。</p> <p>&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使只是RGB YUV这两大类色彩空间，所涉及到的知识也是十分丰富复杂的，在下自知不具备足够的相关专业知识，所以本文主要针对工程领域的应用及算法进行讨论。</p> <p>&nbsp;</p> <p><strong>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YUV相关色彩空间模型</strong></p> <p><strong>2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YUV 与 YIQ YcrCb</strong></p> <p>对于YUV模型，实际上很多时候，我们是把它和YIQ / YCrCb模型混为一谈的。</p> <p>实际上,YUV模型用于PAL制式的电视系统，Y表示亮度，UV并非任何单词的缩写。</p> <p>YIQ模型与YUV模型类似，用于NTSC制式的电视系统。YIQ颜色空间中的I和Q分量相当于将YUV空间中的UV分量做了一个33度的旋转。</p> <p>YCbCr颜色空间是由YUV颜色空间派生的一种颜色空间，主要用于数字电视系统中。从RGB到YCbCr的转换中，输入、输出都是8位二进制格式。</p> <p>三者与RGB的转换方程如下：</p> <p>RGB -&gt; YUV</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/5a0a8fcdac3943389702410494f6a44d.png\" style=\"max-width:500px;\" /></p> <p>实际上也就是：</p> <p>Y=0.30R+0.59G+0.11B ， U=0.493(B－Y)&nbsp;， V=0.877(R－Y)</p> <p>&nbsp;</p> <p>RGB -&gt; YIQ</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/f65bb56f676f48efb02ef08468fff8e8.gif\" style=\"max-width:500px;\" /></p> <p>&nbsp;</p> <p>RGB -&gt; YCrCb</p> <p><img src=\"http://p.blog.csdn.net/images/p_blog_csdn_net/colorant/ff0ff0facd2c4fb1b8c5d828ae45db25.png\" style=\"max-width:500px;\" /></p> <p>从公式中，我们关键要理解的一点是，UV / CbCr信号实际上就是蓝色差信号和红色差信号，进而言之，实际上一定程度上间接的代表了蓝色和红色的强度，理解这一点对于我们理解各种颜色变换处理的过程会有很大的帮助。</p> <p>我们在数字电子多媒体领域所谈到的YUV格式，实际上准确的说，是以YcrCb色彩空间模型为基础的具有多种存储格式的一类颜色模型的家族（包&nbsp;括YUV444 / YUV422 / YUV420 / YUV420P等等）。并不是传统意义上用于PAL制模拟电视的YUV模型。这些YUV模型的区别主要在于UV数据的采样方式和存储方式，这里就不详述。</p> <p>而在Camera Sensor中，最常用的YUV模型是 YUV422格式，因为它采用4个字节描述两个像素，能和RGB565模型比较好的兼容。有利于Camera Sensor和Camera controller的软硬件接口设计。</p> <p>&nbsp;</p> <p><strong>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YUV2RGB快速算法分析</strong></p> <p>这里指的YUV实际是YcrCb了 8 ) YUV2RGB的转换公式本身是很简单的，但是牵涉到浮点运算，所以，如果要实现快速算法，算法结构本身没什么好研究的了，主要是采用整型运算或者查表来加快计算速度。</p> <p>首先可以推导得到转换公式为：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R = Y + 1.4075 *（V-128）</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G = Y – 0.3455 *（U&nbsp;–128）&nbsp;– 0.7169 *（V&nbsp;–128）</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B = Y + 1.779 *（U&nbsp;– 128）</p> <p><strong>3.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整型算法</strong></p> <p>要用整型运算代替浮点运算，当然是要用移位的办法了，我们可以很容易得到下列算法：</p> <p>&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u = YUVdata[UPOS]&nbsp;- 128;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v = YUVdata[VPOS]&nbsp;- 128;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> <p>rdif = v +&nbsp;((v&nbsp;* 103)&nbsp;&gt;&gt; 8);</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invgdif =&nbsp;((u&nbsp;* 88)&nbsp;&gt;&gt; 8)&nbsp;+((v * 183)&nbsp;&gt;&gt; 8);</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bdif = u +(&nbsp;(u*198)&nbsp;&gt;&gt; 8);</p> <p>&nbsp;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r = YUVdata[YPOS]&nbsp;+ rdif;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g = YUVdata[YPOS]&nbsp;- invgdif;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b = YUVdata[YPOS]&nbsp;+ bdif;</p> <p>&nbsp;</p> <p>为了防止出现溢出，还需要判错计算的结果是否在0-255范围内，做类似下面的判断。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r&gt;255)</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r=255;</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r&lt;0)</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r=0;</p> <p>要从RGB24转换成RGB565数据还要做移位和或运算：</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RGBdata[1]&nbsp;=(&nbsp;(r &amp; 0xF8)&nbsp;|&nbsp;( g &gt;&gt; 5)&nbsp;);</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RGBdata[0]&nbsp;=(&nbsp;((g &amp; 0x1C)&nbsp;&lt;&lt; 3)&nbsp;|&nbsp;( b &gt;&gt; 3)&nbsp;);</p> <p><strong>3.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;部分查表法</strong></p> <p>查表法首先可以想到的就是用查表替代上述整型算法中的乘法运算。</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rdif = fac_1_4075[u];</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invgdif = fac_m_0_3455[u]&nbsp;+ fac_m_0_7169[v];</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bdif = fac_1_779[u];</p> <p>这里一共需要4个1维数组，下标从0开始到255，表格共占用约1K的内存空间。uv可以不需要做减128的操作了。在事先计算对应的数组元素的值的时候计算在内就好了。</p> <p>对于每个像素，部分查表法用查表替代了2次减法运算和4次乘法运算，4次移位运算。但是，依然需要多次加法运算和6次比较运算和可能存在的赋值操作，相对第一种方法运算速度提高并不明显。</p> <p><strong>3.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全查表法</strong></p> <p>那么是否可以由YUV直接查表得到对应的RGB值呢？乍一看似乎不太可能，以最复杂的G的运算为例，因为G与YUV三者都相关，所以类似 G=YUV2G[Y][U][V]这样的算法，一个三维下标尺寸都为256的数组就需要占用2的24次方约16兆空间，绝对是没法接受的。所以目前多数都&nbsp;是采用部分查表法。</p> <p>但是，如果我们仔细分析就可以发现，对于G我们实际上完全没有必要采用三维数组，因为Y只与UV运算的结果相关，与UV的个体无关，所以我们可以采用二次查表的方法将G的运算简化为对两个二维数组的查表操作，如下：</p> <p>G = yig2g_table[ y ][ uv2ig_table[ u ][ v ]&nbsp;]；</p> <p>而RB本身就只和YU或YV相关，所以这样我们一共需要4个8*8的二维表格，需要占用4乘2的16次方共256K内存。基本可以接受。但是对于手机这样的嵌入式运用来说，还是略有些大了。</p> <p>进一步分析，我们可以看到，因为在手机等嵌入式运用上我们最终是要把数据转换成RGB565格式送到LCD屏上显示的，所以，对于RGB三分量&nbsp;来说，我们根本不需要8bit这么高的精度，为了简单和运算的统一起见，对每个分量我们其实只需要高6bit的数据就足够了，所以我们可以进一步把表格改&nbsp;为4个6*6的二维表格，这样一共只需要占用16K内存！在计算表格元素值的时候还可以把最终的溢出判断也事先做完。最后的算法如下：</p> <p>&nbsp;</p> <p>y&nbsp;=&nbsp;(YUVdata[Y1POS]&nbsp;&gt;&gt; 2);</p> <p>u =&nbsp;(YUVdata[UPOS]&nbsp;&gt;&gt; 2);</p> <p>&nbsp;&nbsp;&nbsp; v =&nbsp;(YUVdata[VPOS]&nbsp;&gt;&gt; 2);</p> <p>&nbsp;&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp; r = yv2r_table[ y ][ v ];</p> <p>&nbsp;&nbsp;&nbsp; g = yig2g_table[ y ][ uv2ig_table[ u ][ v ]&nbsp;];</p> <p>&nbsp;&nbsp;&nbsp; b = yu2b_table[ y ][ u ];</p> <p>&nbsp;&nbsp;&nbsp;</p> <p>&nbsp;&nbsp;&nbsp; RGBdata[1]&nbsp;=(&nbsp;(r &amp; 0xF8)&nbsp;|&nbsp;( g &gt;&gt; 5)&nbsp;);</p> <p>&nbsp;&nbsp;&nbsp; RGBdata[0]&nbsp;=(&nbsp;((g &amp; 0x1C)&nbsp;&lt;&lt; 3)&nbsp;|&nbsp;( b &gt;&gt; 3)&nbsp;);</p> <p>&nbsp;</p> <p>这样相对部分查表法，我们增加了3次移位运算，而进一步减少了4次加法运算和6次比较赋值操作。</p> <p>在计算表格元素数值的时候，要考虑舍入和偏移等因数使得计算的中间结果满足数组下标非负的要求，需要一定的技巧：</p> <p>采用完全查表法，相对于第一种算法，最终运算速度可以有比较明显的提高，具体性能能提高多少，要看所在平台的CPU运算速度和内存存取速度的相&nbsp;对比例。内存存取速度越快，用查表法带来的性能改善越明显。在我的PC上测试的结果性能大约能提高35%。而在某ARM平台上测试只提高了约15%。</p> <p><strong>3.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进一步的思考</strong></p> <p>实际上，上述算法：</p> <p>&nbsp;&nbsp;&nbsp; RGBdata[1]&nbsp;=(&nbsp;(r &amp; 0xF8)&nbsp;|&nbsp;( g &gt;&gt; 5)&nbsp;);</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RGBdata[0]&nbsp;=(&nbsp;((g &amp; 0x1C)&nbsp;&lt;&lt; 3)&nbsp;|&nbsp;( b &gt;&gt; 3)&nbsp;);</p> <p>中的&nbsp;(r &amp; 0xF8)&nbsp;和&nbsp;( b &gt;&gt; 3)&nbsp;等运算也完全可以在表格中事先计算出来。另外，YU / YV的取值实际上不可能覆盖满6*6的范围，中间有些点是永远取不到的无输入，RB的运算也可以考虑用5*5的表格。这些都可能进一步提高运算的速度，减&nbsp;小表格的尺寸。</p> <p>另外，在嵌入式运用中，如果可能尽量将表格放在高速内存如SRAM中应该比放在SDRAM中更加能发挥查表法的优势。</p> <p><strong>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RGB2YUV ?</strong></p> <p>目前觉得这个是没法将3维表格的查表运算化简为2维表格的查表运算了。只能用部分查表法替代其中的乘法运算。</p> <p>另外，多数情况下，我们需要的还是YUV2RGB的转换，因为从Sensor得到的数据通常我们会用YUV数据，此外JPG和MPEG实际上也是基于YUV格式编码的，所以要显示解码后的数据需要的也是YUV2RGB的运算 8 ）运气运气。</p> <p><br /></p>  【图像处理】ISP图像处理算法之---Demosaic 1451823611542 Text 1dad75de_97e3f17 【图像处理】 <p>目前市场上主流传感器为Coms传感器，sensor出来的的数据格式为bayer数据格式，这种格式，每个像素点只有三个颜色通道中的一个，如图1所示</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图1&nbsp; bayer数据格式</p> <p>Demosaic的目的就是有bayer数据恢复出完整的RGB数据。</p> <p>方法：色差和色比，一般用色差的理论</p> <p>常见算法：双线性，基于梯度，自适应，及其他一些方法，具体原理网上都能查的到，此处不一一介绍，最后贴几张自己做的一个Demosaic和常见算法的一个对比</p> <p><br /></p> <p><img src=\"http://img.blog.csdn.net/20151218152500750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" style=\"max-width:500px;\" /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原图</p> <p><img src=\"http://img.blog.csdn.net/20151218152722981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" style=\"max-width:500px;\" /><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双线性插值<img src=\"http://img.blog.csdn.net/20151218152831233?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" style=\"max-width:500px;\" /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于梯度插值</p> <p><img src=\"http://img.blog.csdn.net/20151218152915139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" style=\"max-width:500px;\" /><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自适应插值</p> <p><img src=\"http://img.blog.csdn.net/20151218152953069?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" style=\"max-width:500px;\" /><br /></p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于差值的插值方法</p> <p><img src=\"http://img.blog.csdn.net/20151218153028550?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" style=\"max-width:500px;\" /><br /></p> <p>自己的方法</p> <p><br /></p>  【图像处理】CMOS图像传感器的工作原理及研究 1451822644354 Text 1dad75de_97e3eb7 【图像处理】 ",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}